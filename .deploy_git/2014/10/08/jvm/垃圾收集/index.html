
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>内存分配与垃圾收集 | ming15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming15">
    

    
    <meta name="description" content="引用计数算法引用计数算法很难解决对象之间相互循环引用的问题123456789101112131415161718public class ReferenceCountingGC &amp;#123;    public Object instance = null;    private static final int _1MB = 1024 * 1024;    private byte[] bigS">
<meta property="og:type" content="article">
<meta property="og:title" content="内存分配与垃圾收集">
<meta property="og:url" content="http://www.ming15.wang/2014/10/08/jvm/垃圾收集/index.html">
<meta property="og:site_name" content="ming15">
<meta property="og:description" content="引用计数算法引用计数算法很难解决对象之间相互循环引用的问题123456789101112131415161718public class ReferenceCountingGC &amp;#123;    public Object instance = null;    private static final int _1MB = 1024 * 1024;    private byte[] bigS">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95a.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95b.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95a.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95b.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20%20-%20%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95a.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20%20-%20%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95b.jpg">
<meta property="og:image" content="https://blogs.oracle.com/jonthecollector/resource/Collectors.jpg">
<meta property="og:updated_time" content="2016-03-15T11:47:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内存分配与垃圾收集">
<meta name="twitter:description" content="引用计数算法引用计数算法很难解决对象之间相互循环引用的问题123456789101112131415161718public class ReferenceCountingGC &amp;#123;    public Object instance = null;    private static final int _1MB = 1024 * 1024;    private byte[] bigS">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95a.jpg">

    
    <link rel="alternative" href="/atom.xml" title="ming15" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ming15" title="ming15"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ming15">ming15</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 17728547076946147000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/垃圾收集/" title="内存分配与垃圾收集" itemprop="url">内存分配与垃圾收集</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引用计数算法"><span class="toc-number">1.</span> <span class="toc-text">引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#根搜索算法"><span class="toc-number">1.1.</span> <span class="toc-text">根搜索算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈引用"><span class="toc-number">1.2.</span> <span class="toc-text">再谈引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配"><span class="toc-number">2.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新生代"><span class="toc-number">2.1.</span> <span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#老年代"><span class="toc-number">2.2.</span> <span class="toc-text">老年代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态年龄判断"><span class="toc-number">2.2.1.</span> <span class="toc-text">动态年龄判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间分配担保"><span class="toc-number">2.3.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收算法"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清除算法"><span class="toc-number">3.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法"><span class="toc-number">3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-整理算法"><span class="toc-number">3.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">3.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集器"><span class="toc-number">4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial收集器"><span class="toc-number">4.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew收集器"><span class="toc-number">4.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavege收集器"><span class="toc-number">4.3.</span> <span class="toc-text">Parallel Scavege收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old收集器"><span class="toc-number">4.4.</span> <span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-old收集器"><span class="toc-number">4.5.</span> <span class="toc-text">Parallel old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS收集器"><span class="toc-number">4.6.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1收集器"><span class="toc-number">4.7.</span> <span class="toc-text">G1收集器</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数算法很难解决对象之间相互循环引用的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC obj1 = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC obj2 = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        obj1.instance = obj2;</span><br><span class="line">        obj2.instance = obj1;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>这个算法的基本思想是:通过一系列的名为”GC Roots”的对象作为起始点, 从这些起始点开始向下搜索,搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链时,则证明这个对象是不可到达的.</p>
<p>在java语言里, 可作为GC Roots的对象包括以下几种:</p>
<ol>
<li>虚拟机栈(栈帧中的本地变量表)中的引用对象.</li>
<li>方法区中的类静态属性引用的对象.</li>
<li>方法区中的常量引用对象</li>
<li>本地方法栈中JNI的引用的对象</li>
</ol>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>JDK1.2之后,java对引用的概念进行了拓充,将引用分为强引用,软引用,弱引用,虚引用</p>
<ol>
<li>强引用: 指的是在代码之中普遍存在的,类似<code>Object obj = new Object()</code> 这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象</li>
<li>软引用: 用来描述一些还有用,但是并非重要的对象.对于软引用关联着的对象,在系统将要发生内存溢出之前,将会把这些对象列进回收范围之中并进行第二次回收.如果这次回收还是没有足够的内存,才会抛出内存溢出异常.</li>
<li>弱饮用: 当垃圾收集器工作时,无论是否内存足够,都将回收掉只被若饮用关联的对象</li>
<li>虚引用: 一个对象是否是有虚引用的存在,完全不会对其生成时间构成影响,也无法通过虚引用来取得一个对象实例.为一个对象设置虚引用关联的唯一目的是希望在其被收集器回收时收到一个系统通知.</li>
</ol>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ol>
<li>新生代GC(<code>Minor GC</code>)：新生代GC, Java对象大多都朝生夕灭,所以<code>Minor GC</code>非常频繁,回收速度也比较快.</li>
<li>老年代GC(<code>Major GC/Full GC</code>)：老年代GC,出现了Major GC,经常会伴随至少一次的Minor GC. MajorGC的速度一般会比Minor GC慢10倍以上.</li>
</ol>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代分为Eden区和Survivor区(Eden有一个, Survivor有俩个, 参考复制算法).</p>
<p>大多数情况下,对象在新生代<code>Eden</code>区中分配.当<code>Eden</code>区没有足够的空间进行分配时,虚拟机将发起一次<code>Minor GC</code>, 将存活下来的对象移动到一个Survivor区中</p>
<blockquote>
<p>虚拟机提供了<code>-XX:+PrintGCDetails</code>这个收集器日志参数,告诉虚拟机在发生垃圾收集行为时打印内存回收日志,并且在进程退出的时候输出当前内存各区域的分配情况.</p>
</blockquote>
<p>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">	    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<ol>
<li>首先在堆中分配3个2MB大小和1个4MB大小的byte数组, 在运行时通过<code>-Xms20M、 -Xmx20M</code>和<code>-Xmn10M</code>这3个参数限制Java堆大小为20MB,且不可扩展,其中10MB分配给新生代,剩下的10MB分配给老年代.</li>
<li><code>-XX:SurvivorRatio=8</code>决定了新生代中Eden区与一个<code>Survivor</code>区的空间比例是8比1,从输出的结果也能清晰地看到<code>“eden space 8192K、from space 1024K、to space 1024K”</code>的信息,新生代总可用空间为<code>9216KB</code>(<code>Eden</code>区+1个<code>Survivor</code>区的总容量).</li>
<li>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次Minor GC,这次GC的结果是新生代6651KB变为148KB,而总内存占用量则几乎没有减少(因为allocation1、2、3三个对象都是存活的,虚拟机几乎没有找到可回收的对象).</li>
<li>这次GC发生的原因是给allocation4分配内存的时候,发现Eden已经被占用了6MB,剩余空间已不足以分配allocation4所需的4MB内存,因此发生Minor GC.GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间(Survivor空间只有1MB大小),所以只好通过分配担保机制提前转移到老年代去.</li>
<li>这次GC结束后,4MB的allocation4对象被顺利分配在Eden中.因此程序执行完的结果是Eden占用4MB(被allocation4占用),Survivor空闲,老年代被占用6MB(被allocation1、2、3占用)</li>
</ol>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>大对象和长期存活的对象会进入老年代</p>
<p>所谓大对象就是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长的字符串及数组. 如果连续出现多个大对象, 会导致老年代频繁发生<code>Full GC</code>, 因此在写程序时应该避免频繁出现大对象.</p>
<p>我们可以使用<code>-XX:PretenureSizeThreshold</code>参数令大于这个值的对象直接在老年代中分配. 这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(新生代采用复制算法收集内存).</p>
<p>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8</span><br><span class="line">  * -XX:PretenureSizeThreshold=3145728</span><br><span class="line">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	　<span class="keyword">byte</span>[] allocation;</span><br><span class="line">	　allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];  <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到Eden空间几乎没有被使用,而老年代10MB的空间被使用了40%,也就是4MB的allocation对象直接就分配在老年代中,这是因为<code>PretenureSizeThreshold</code>被设置为3MB(就是3145728B,这个参数不能与<code>-Xmx</code>之类的参数一样直接写3MB),因此超过3MB的对象都会直接在老年代中进行分配.</p>
<blockquote>
<p>注意<code>PretenureSizeThreshold</code>参数只对Serial和ParNew两款收集器有效,<code>Parallel Scavenge</code>收集器不认识这个参数,<code>Parallel Scavenge</code>收集器一般并不需要设置.如果遇到必须使用此参数的场合,可以考虑ParNew加CMS的收集器组合.</p>
</blockquote>
<p>虚拟机给每个对象定义了一个对象年龄(Age)计数器.如果对象在Eden出生并经过第一次Minor GC后仍然存活,    并且能被Survivor容纳的话,将被移动到Survivor空间中,并将对象年龄设为1.对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁)时,就会被晋升到老年代中.对象晋升老年代的年龄阈值,可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置.</p>
<p>大家可以分别以<code>-XX:MaxTenuringThreshold=1</code>和<code>-XX:MaxTenuringThreshold=15</code>两种设置来执行刚才示例. 例子中allocation1对象需要256KB的内存空间,Survivor空间可以容纳.当MaxTenuringThreshold=1时,allocation1对象在第二次GC发生时进入老年代,新生代已使用的内存GC后会非常干净地变成0KB.而MaxTenuringThreshold=15时,第二次GC发生后,allocation1对象则还留在新生代Survivor空间,这时候新生代仍然有404KB的空间被占用.</p>
<p>实例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M</span><br><span class="line">  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span><br><span class="line">  * -XX:+PrintTenuringDistribution</span><br><span class="line">  */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">	 allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">	  <span class="comment">// 什么时候进入老年代取决于XX:MaxTenuringThreshold设置</span></span><br><span class="line">	 allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	 allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	 allocation3 = <span class="keyword">null</span>;</span><br><span class="line">	 allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h4><p>为了能更好地适应不同程序的内存状况,虚拟机并不总是要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代,如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等到<code>MaxTenuringThreshold</code>中要求的年龄.</p>
<p>例如下例中设置参数<code>-XX: MaxTenuringThreshold=15</code>,会发现运行结果中<code>Survivor</code>的空间占用仍然为0%,而老年代比预期增加了<code>6%</code>,也就是说<code>allocation1、allocation2</code>对象都直接进入了老年代,而没有等到15岁的临界年龄.因为这两个对象加起来已经达到了512KB,并且它们是同年的,满足同年对象达到Survivor空间的一半规则.我们只要注释掉其中一个对象的new操作,就会发现另外一个不会晋升到老年代中去了.</p>
<p>示例代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final int _1MB = 1024 #### 1024;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M</span><br><span class="line">  * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span><br><span class="line">  * -XX:+PrintTenuringDistribution</span><br><span class="line">  */</span><br><span class="line">@SuppressWarnings("unused")</span><br><span class="line">public static void testTenuringThreshold2() &#123;</span><br><span class="line">	 byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">	 allocation1 = new byte[_1MB / 4];</span><br><span class="line">	  // allocation1+allocation2大于survivor空间的一半</span><br><span class="line">	 allocation2 = new byte[_1MB / 4];</span><br><span class="line">	 allocation3 = new byte[4 #### _1MB];</span><br><span class="line">	 allocation4 = new byte[4 #### _1MB];</span><br><span class="line">	 allocation4 = null;</span><br><span class="line">	 allocation4 = new byte[4 #### _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC时,虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小,如果大于,则改为直接进行一次Full GC.如果小于,则查看HandlePromotionFailure设置是否允许担保失败;如果允许,那只会进行Minor GC;如果不允许,则也要改为进行一次Full GC.</p>
<p>前面提到过,新生代使用复制收集算法,但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份,因此当出现大量对象在Minor GC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保,让Survivor    无法容纳的对象直接进入老年代.与生活中的贷款担保类似,老年代要进行这样的担保,前提是老年代本身还有容纳这些对象的    剩余空间,一共有多少对象会活下来,在实际完成内存回收之前是无法明确知道的,所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值,与老年代的剩余空间进行比较,决定是否进行Full GC来让老年代腾出更多空间.</p>
<p>取平均值进行比较其实仍然是一种动态概率的手段,也就是说如果某次Minor GC存活后的对象突增,远远高于平均值的话,依然会导致担保失败(Handle Promotion Failure).如果出现了HandlePromotionFailure失败,    那就只好在失败后重新发起一次Full GC.虽然担保失败时绕的圈子是最大的,但大部分情况下都还是会将    HandlePromotionFailure开关打开,避免Full GC过于频繁,</p>
<p>示例代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final int _1MB = 1024 #### 1024;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M</span><br><span class="line">  * -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure</span><br><span class="line">  */</span><br><span class="line">@SuppressWarnings("unused")</span><br><span class="line">public static void testHandlePromotion() &#123;</span><br><span class="line">	 byte[] allocation1, allocation2, allocation3,</span><br><span class="line">	 allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">	 allocation1 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation2 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation3 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation1 = null;</span><br><span class="line">	 allocation4 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation5 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation6 = new byte[2 #### _1MB];</span><br><span class="line">	 allocation4 = null;</span><br><span class="line">	 allocation5 = null;</span><br><span class="line">	 allocation6 = null;</span><br><span class="line">	 allocation7 = new byte[2 #### _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95a.jpg" alt="标记-清除算法"><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95b.jpg" alt="标记-清除算法"></p>
<p>算法分为标记和清除俩个部分. 首先标记出要所有要回收的对象, 然后统一回收掉所有被标记的对象.</p>
<p>这种算法的缺点主要是:</p>
<ol>
<li>效率问题. 标记和清除的效率都不高.</li>
<li>空间问题. 标记和清除之后会存在大量不连续空间碎片. 空间碎片太多可能导致,在程序以后运行过程中需要分配较大对象时,无法找到足够的内存连续内存,而不得不提前触发另一次的垃圾收集动作.</li>
</ol>
<p>算法伪代码</p>
<p>NEW操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">New():</span><br><span class="line">    ref &lt;- allocate()  <span class="comment">//分配新的内存到ref指针</span></span><br><span class="line">    <span class="keyword">if</span> ref == <span class="function"><span class="keyword">null</span></span><br><span class="line">       <span class="title">collect</span><span class="params">()</span>  <span class="comment">//内存不足,则触发垃圾收集</span></span><br><span class="line">       ref &lt;- <span class="title">allocate</span><span class="params">()</span></span><br><span class="line">       <span class="keyword">if</span> ref </span>== <span class="keyword">null</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="string">"Out of Memory"</span>   <span class="comment">//垃圾收集后仍然内存不足,则抛出Out of Memory错误</span></span><br><span class="line">          <span class="keyword">return</span> <span class="function">ref</span><br><span class="line"></span><br><span class="line">atomic <span class="title">collect</span><span class="params">()</span>:</span><br><span class="line">    <span class="title">markFromRoots</span><span class="params">()</span></span><br><span class="line">    <span class="title">sweep</span><span class="params">(HeapStart,HeapEnd)</span></span></span><br></pre></td></tr></table></figure></p>
<p>mark算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markFromRoots():</span><br><span class="line">    worklist &lt;- empty</span><br><span class="line">    <span class="keyword">for</span> each fld in Roots  <span class="comment">//遍历所有mutator根对象</span></span><br><span class="line">        ref &lt;- *fld</span><br><span class="line">        <span class="keyword">if</span> ref != <span class="keyword">null</span> &amp;&amp; isNotMarked(ref)  <span class="comment">//如果它是可达的而且没有被标记的,直接标记该对象并将其加到worklist中</span></span><br><span class="line">           setMarked(ref)</span><br><span class="line">           add(worklist,ref)</span><br><span class="line">           mark()</span><br><span class="line">mark():</span><br><span class="line">    <span class="function"><span class="keyword">while</span> not <span class="title">isEmpty</span><span class="params">(worklist)</span></span><br><span class="line">          ref &lt;- <span class="title">remove</span><span class="params">(worklist)</span>  <span class="comment">//将worklist的最后一个元素弹出,赋值给ref</span></span><br><span class="line">          <span class="keyword">for</span> each fld in <span class="title">Pointers</span><span class="params">(ref)</span></span><br><span class="line">          <span class="comment">//遍历ref对象的所有指针域,如果其指针域(child)是可达的,直接标记其为可达对象并且将其加入worklist中</span></span><br><span class="line">          <span class="comment">//通过这样的方式来实现深度遍历,直到将该对象下面所有可以访问到的对象都标记为可达对象.</span></span><br><span class="line">                child &lt;- *fld</span><br><span class="line">                <span class="keyword">if</span> child !</span>= <span class="keyword">null</span> &amp;&amp; isNotMarked(child)</span><br><span class="line">                   setMarked(child)</span><br><span class="line">                   add(worklist,child)</span><br></pre></td></tr></table></figure></p>
<p>sweep算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sweep(start,end):</span><br><span class="line">    scan &lt;- start</span><br><span class="line">   <span class="keyword">while</span> scan &lt; <span class="function">end</span><br><span class="line">       <span class="keyword">if</span> <span class="title">isMarked</span><span class="params">(scan)</span></span><br><span class="line">          <span class="title">setUnMarked</span><span class="params">(scan)</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="title">free</span><span class="params">(scan)</span></span><br><span class="line">      scan &lt;- <span class="title">nextObject</span><span class="params">(scan)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题, 复制算法将可用内存按照容量划分为大小相等的俩块,每次只使用其中的一块. 当这一块内存用完了,就将还活着的对象复制到另一块上面,然后再把已经使用过的内存一次清理掉.<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95a.jpg" alt="复制算法a"><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95b.jpg" alt="复制算法b"></p>
<blockquote>
<p>商业虚拟机都采用这种算法来收集新生代. 由于大多数的新生代对象都是朝生夕死, 因此按照1:1 的比例分配新生代内存代价就有点高了. 因此现在的做法一般是将新生代分为一块<br>较大的Eden区和俩块较小的Survivor区. 每次都使用Eden和一块Survivor区,当回收时, 将Eden还活着的对象一次性拷贝到另一块Survivor区,最后清理掉Eden区和刚才使用过的Survivor区.<br>HotSpot默认Eden和Survivor的大小比例是8:1, 也就是每次新生代可用内存空间为90%(8 + 1), 如果发现剩余的存活对象多余10%,另一块Survivor不够的话,需要依赖其他内存(老年代)进行分配担保.</p>
</blockquote>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>由于新生代的对象是朝生夕死的，因此复制算法每次复制的对象都不会太多, 但是老年代都是一些大对象, 如果在老年代仍然采用复制算法的话, 效率会变低, 因此提出了标记-整理算法. 标记过程和”标记-清除算法”一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存.</p>
<p><a href="http://www.jianshu.com/p/698eb5e1ccb9" target="_blank" rel="external">标记整理算法</a><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20%20-%20%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95a.jpg" alt="标记  - 整理算法a"><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/jvm/%E6%A0%87%E8%AE%B0%20%20-%20%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95b.jpg" alt="标记  - 整理算法b"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>这种算法的思想是:把java堆分为新生代和老年代,这样就可以根据各个年代的特点采用最适当的收集算法.</p>
<p>在新生代,每次垃圾收集时发现有大批对象死去,只有少量对象存活,那就采用复制算法,只要付出少量存活对象的复制成本就可以完成收集. 而老年代对象存活效率高,没有额外的空间对它进行分配担保,就必须采用”标记清除”或者”标记整理”来进行回收</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://blogs.oracle.com/jonthecollector/resource/Collectors.jpg" alt="https://blogs.oracle.com/jonthecollector/resource/Collectors.jpg"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本、历史最悠久的收集器,曾经（在JDK 1.3.1之前）是虚拟机<code>新生代</code>收集的唯一选择.</p>
<p>作为单线程收集器, 它不仅仅只会使用一个CPU或一条收集线程完成GC,更重要的是在它进行GC时, 其他的工作线程也必须暂停工作, 直到它收集结束. 这在多线程的应用中是难以接受的. 但是桌面应用程序会将虚拟机设置为Client模式, 这种模式下单线程收集一百兆左右的新生代内存时间完全可以控制在一百毫秒以内, 这种停顿只要是不发生的太频繁, 用户是完全可以接受的. 而且对于 限定单个CPU的环境来说,<code>Serial</code>收集器由于没有线程交互的开销,专心做垃圾收集自然可以获得最高的单线程收集效率.</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><code>ParNew</code>收集器其实就是<code>Serial</code>收集器的多线程版本,除了使用多线程进行垃圾收集之外,其余行为包括Serial收集器可用的所有控制参数（例如：<code>-XX:SurvivorRatio</code>、 <code>-XX:PretenureSizeThreshold</code>、<code>-XX:HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样.</p>
<blockquote>
<p>需要指出的是, ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器,其中有一个与性能无关但很重要的原因是,除了Serial收集器外,目前只有它能与CMS收集器配合工作.</p>
</blockquote>
<p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果,甚至由于存在线程交互的开销,该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器.当然,随着可以使用的CPU的数量的增加,它对于GC时系统资源的利用还是很有好处的.它默认开启的收集线程数与CPU的数量相同,在CPU非常多（譬如32个,现在CPU动辄就4核加超线程,服务器超过32个逻辑CPU的情况越来越多了）的环境下,可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数.</p>
<p>注意，从ParNew收集器开始,后面还将会接触到几款并发和并行的收集器.在大家可能产生疑惑之前,有必要先解释两个名词：并发和并行.这两个名词都是并发编程中的概念,在谈论垃圾收集器的上下文语境中,他们可以解释为：</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作,但此时用户线程仍然处于等待状态.</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的,可能会交替执行）,用户程序继续运行,而垃圾收集程序运行于另一个CPU上.</li>
</ul>
<h3 id="Parallel-Scavege收集器"><a href="#Parallel-Scavege收集器" class="headerlink" title="Parallel Scavege收集器"></a>Parallel Scavege收集器</h3><p>Parallel Scavenge收集器也是一个新生代收集器,它也是使用复制算法的收集器,又是并行的多线程收集器……看上去和ParNew都一样,那它有什么特别之处呢？</p>
<p>它的关注点与其他收集器不同,CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间,而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）.</p>
<blockquote>
<p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）,虚拟机总共运行了100分钟,其中垃圾收集花掉1分钟,那吞吐量就是99%.</p>
</blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序,良好的响应速度能提升用户的体验;而高吞吐量则可以最高效率地利用CPU时间,尽快地完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务.</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量,分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code>参数.</p>
<ul>
<li><p><code>MaxGCPauseMillis</code> : 参数允许的值是一个大于0的毫秒数,收集器将尽力保证内存回收花费的时间不超过设定值.不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快,GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些,收集300MB新生代肯定比收集500MB快吧,这也直接导致垃圾收集发生得更频繁一些,原来10秒收集一次、每次停顿100毫秒,现在变成5秒收集一次、每次停顿70毫秒.停顿时间的确在下降,但吞吐量也降下来了.</p>
</li>
<li><p><code>GCTimeRatio</code> : 参数的值应当是一个大于0小于100的整数,也就是垃圾收集时间占总时间的比率,相当于是吞吐量的倒数.如果把此参数设置为19,那允许的最大GC时间就占总时间的5%（即1 /（1+19））,默认值为99,就是允许最大1%（即1 /（1+99））的垃圾收集时间.</p>
</li>
</ul>
<p>由于与吞吐量关系密切,Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器.除上述两个参数之外,Parallel Scavenge收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>值得关注.</p>
<ul>
<li><code>-XX:+UseAdaptiveSizePolicy</code> :这是一个开关参数,当这个参数打开之后,就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了,虚拟机会根据当前系统的运行情况收集性能监控信息,动态调整这些参数以提供最合适的停顿时间或最大的吞吐量,这种调节方式称为GC自适应的调节策略（GC Ergonomics）.<blockquote>
<p>如果读者对于收集器运作原理不太了解,手工优化存在困难的时候,使用Parallel Scavenge收集器配合自适应调节策略,把内存管理的调优任务交给虚拟机去完成将是一个很不错的选择.只需要把基本的内存数据设置好（如-Xmx设置最大堆）,然后使用<code>MaxGCPauseMillis</code>参数（更关注最大停顿时间）或<code>GCTimeRatio</code>参数（更关注吞吐量）给虚拟机设立一个优化目标,那具体细节参数的调节工作就由虚拟机完成了.自适应调节策略也是<code>Parallel Scavenge</code>收集器与<code>ParNew</code>收集器的一个重要区别.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程,而不必先进行Minor GC</p>
</blockquote>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本,它同样是一个单线程收集器,使用“标记-整理”算法.这个收集器的主要意义也是被Client模式下的虚拟机使用.如果在Server模式下,它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用,另外一个就是作为CMS收集器的后备预案,在并发收集发生Concurrent Mode Failure的时候使用.</p>
<h3 id="Parallel-old收集器"><a href="#Parallel-old收集器" class="headerlink" title="Parallel old收集器"></a>Parallel old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程和“标记－整理”算法.这个收集器是在JDK 1.6中才开始提供的,在此之前,新生代的Parallel Scavenge收集器一直处于比较尴尬的状态.原因是,如果新生代选择了Parallel Scavenge收集器,老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）.由于单线程的老年代Serial Old收集器在服务端应用性能上的“拖累”,即便使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果,又因为老年代收集中无法充分利用服务器多CPU的处理能力,在老年代很大而且硬件比较高级的环境中,这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”.</p>
<p>直到Parallel Old收集器出现后,“吞吐量优先”收集器终于有了比较名副其实的应用组合,在注重吞吐量及CPU资源敏感的场合,都可以优先考虑Parallel Scavenge加Parallel Old收集器.</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><blockquote>
<p>在JDK 1.5时期,HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器Concurrent Mark Sweep）,这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器,它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作.</p>
</blockquote>
<p>不幸的是,CMS收集器作为老年代的收集器,却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作,所以在JDK1.5中使用CMS来收集老年代的时候,新生代只能选择ParNew或Serial收集器中的一个.ParNew收集器也是使用<code>-XX: +UseConcMarkSweepGC</code>选项后的默认新生代收集器,也可以使用 <code>-XX:+UseParNewGC</code>选项来强制指定它.</p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器.目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上,这类应用尤其重视服务的响应速度,希望系统停顿时间最短,以给用户带来较好的体验.CMS收集器就非常符合这类应用的需求.</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的,它的运作过程相对于前面几种收集器来说要更复杂一些,整个过程分为4个步骤,包括：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”.初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快,并发标记阶段就是进行GC Roots Tracing的过程,而重新标记阶段则是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远比并发标记的时间短.</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中,收集器线程都可以与用户线程一起工作,所以总体上来说,CMS收集器的内存回收过程是与用户线程一起并发地执行的.通过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间.</p>
<p>CMS是一款优秀的收集器,它的最主要优点在名字上已经体现出来了：并发收集、低停顿,Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）.但是CMS还远达不到完美的程度,它有以下三个显著的缺点：</p>
<p>CMS收集器对CPU资源非常敏感.其实,面向并发设计的程序都对CPU资源比较敏感.在并发阶段,它虽然不会导致用户线程停顿,但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢,总吞吐量会降低.CMS默认启动的回收线程数是（CPU数量+3）/ 4,也就是当CPU在4个以上时,并发回收时垃圾收集线程最多占用不超过25%的CPU资源.但是当CPU不足4个时（譬如2个）,那么CMS对用户程序的影响就可能变得很大,如果CPU负载本来就比较大的时候,还分出一半的运算能力去执行收集器线程,就可能导致用户程序的执行速度忽然降低了50%,这也很让人受不了.为了解决这种情况,虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种,所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样,就是在并发标记和并发清理的时候让GC线程、用户线程交替运行,尽量减少GC线程的独占资源的时间,这样整个垃圾收集的过程会更长,但对用户程序的影响就会显得少一些,速度下降也就没有那么明显,但是目前版本中,i-CMS已经被声明为“deprecated”,即不再提倡用户使用.</p>
<p>CMS收集器无法处理浮动垃圾（Floating Garbage）,可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生.由于CMS并发清理阶段用户线程还在运行着,伴随程序的运行自然还会有新的垃圾不断产生,这一部分垃圾出现在标记过程之后,CMS无法在本次收集中处理掉它们,只好留待下一次GC时再将其清理掉.这一部分垃圾就称为“浮动垃圾”.也是由于在垃圾收集阶段用户线程还需要运行,即还需要预留足够的内存空间给用户线程使用,因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,需要预留一部分空间提供并发收集时的程序运作使用.在默认设置下,CMS收集器在老年代使用了68%的空间后就会被激活,这是一个偏保守的设置,如果在应用中老年代增长不是太快,可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值来提高触发百分比,以便降低内存回收次数以获取更好的性能.要是CMS运行期间预留的内存无法满足程序需要,就会出现一次“Concurrent Mode Failure”失败,这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了.所以说参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置得太高将会很容易导致大量“Concurrent Mode Failure”失败,性能反而降低.</p>
<p>还有最后一个缺点,在本节在开头说过,CMS是一款基于“标记-清除”算法实现的收集器,如果读者对前面这种算法介绍还有印象的话,就可能想到这意味着收集结束时会产生大量空间碎片.空间碎片过多时,将会给大对象分配带来很大的麻烦,往往会出现老年代还有很大的空间剩余,但是无法找到足够大的连续空间来分配当前对象,不得不提前触发一次Full GC.为了解决这个问题,CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数,用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程,内存整理的过程是无法并发的.空间碎片问题没有了,但停顿时间不得不变长了.虚拟机设计者们还提供了另外一个参数<code>-XX: CMSFullGCsBeforeCompaction</code>,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的.</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage First）收集器是当前收集器技术发展的最前沿成果,在JDK 1.6_Update14中提供了EarlyAccess版本的G1收集器以供试用.在将来JDK 1.7正式发布的时候,G1收集器很可能会有一个成熟的商用版本随之发布.这里只对G1收集器进行简单介绍.</p>
<p>G1收集器是垃圾收集器理论进一步发展的产物,它与前面的CMS收集器相比有两个显著的改进：一是G1收集器是基于“标记-整理”算法实现的收集器,也就是说它不会产生空间碎片,这对于长时间运行的应用系统来说非常重要.二是它可以非常精确地控制停顿,<br>既能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒,这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了.</p>
<p>G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收,这是由于它能够极力地避免全区域的垃圾收集,之前的收集器进行收集的范围都是整个新生代或老年代,而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region）,并且跟踪这些区域里面的垃圾堆积程度,在后台维护一个优先列表,每次根据允许的收集时间,优先回收垃圾最多的区域（这就是Garbage First名称的来由）.区域划分及有优先级的区域回收,保证了G1收集器在有限的时间内可以获得最高的收集效率.</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://www.ming15.wang/2014/10/08/jvm/垃圾收集/" data-title="内存分配与垃圾收集 | ming15" data-tsina="3253370782" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/10/08/jvm/类加载/" title="类加载机制">
  <strong>上一篇：</strong><br/>
  <span>
  类加载机制</span>
</a>
</div>


<div class="next">
<a href="/2014/10/08/jvm/运行时数据区/"  title="运行时数据区">
 <strong>下一篇：</strong><br/> 
 <span>运行时数据区
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2014/10/08/jvm/垃圾收集/" data-title="内存分配与垃圾收集" data-url="http://www.ming15.wang/2014/10/08/jvm/垃圾收集/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引用计数算法"><span class="toc-number">1.</span> <span class="toc-text">引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#根搜索算法"><span class="toc-number">1.1.</span> <span class="toc-text">根搜索算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈引用"><span class="toc-number">1.2.</span> <span class="toc-text">再谈引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配"><span class="toc-number">2.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新生代"><span class="toc-number">2.1.</span> <span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#老年代"><span class="toc-number">2.2.</span> <span class="toc-text">老年代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态年龄判断"><span class="toc-number">2.2.1.</span> <span class="toc-text">动态年龄判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间分配担保"><span class="toc-number">2.3.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收算法"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清除算法"><span class="toc-number">3.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法"><span class="toc-number">3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-整理算法"><span class="toc-number">3.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">3.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾收集器"><span class="toc-number">4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial收集器"><span class="toc-number">4.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew收集器"><span class="toc-number">4.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavege收集器"><span class="toc-number">4.3.</span> <span class="toc-text">Parallel Scavege收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old收集器"><span class="toc-number">4.4.</span> <span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-old收集器"><span class="toc-number">4.5.</span> <span class="toc-text">Parallel old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS收集器"><span class="toc-number">4.6.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1收集器"><span class="toc-number">4.7.</span> <span class="toc-text">G1收集器</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="ming15" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Groovy/" title="Groovy">Groovy<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Haskell/" title="Haskell">Haskell<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JMH/" title="JMH">JMH<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java工具/" title="Java工具">Java工具<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Netty/" title="Netty">Netty<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Php/" title="Php">Php<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reids/" title="Reids">Reids<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCP-IP/" title="TCP IP">TCP IP<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ZooKeeper/" title="ZooKeeper">ZooKeeper<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/asm/" title="asm">asm<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/guice/" title="guice">guice<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/http客户端/" title="http客户端">http客户端<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/http服务器/" title="http服务器">http服务器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/memcached/" title="memcached">memcached<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/mgits/" title="mgits">mgits<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/mycat/" title="mycat">mycat<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/python2/" title="python2">python2<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发编程/" title="并发编程">并发编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/序列化工具/" title="序列化工具">序列化工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志工具/" title="日志工具">日志工具<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/构建工具/" title="构建工具">构建工具<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www1.vertx3.cn" target="_blank" title="vertx3">vertx3</a>
            
          </li>
        
    </ul>
</div>

  

<div class="doubanshow">
<p class="asidetitle">Douban Show</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/xxxyy/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3253370782&verifier=e9ca895b&dpc=1"></iframe>
</div>


  

<div class="lofter">
<p class="asidetitle">Lofter</p>

 <iframe width="100%" height="39" class="share_self"  frameborder="0" scrolling="no" src="http://ming15.lofter.com/"></iframe>
</div>




</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 博客,我选择重构 <br/>
			重构使事情变得更美,更加正确</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3253370782" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/ming15" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xxxyy" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/ming15" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="ming15">ming15</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"wanggnim"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e8fca440159a2125668804e46682db4' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
