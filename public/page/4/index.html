
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ming15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming15">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ming15">
<meta property="og:url" content="http://www.ming15.wang/page/4/index.html">
<meta property="og:site_name" content="ming15">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ming15">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="ming15" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ming15" title="ming15"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ming15">ming15</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 17728547076946147000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 写文件/" title="JAVA 写文件" itemprop="url">JAVA 写文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h2><p>我们使用<code>FileOutputStream</code>, <code>BufferedOutputStream</code>来读取文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedOutputStream bf = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));) &#123;</span><br><span class="line">	bf.write(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BufferedOutputStream 缓冲输出流。它继承于FilterOutputStream。作用是为另一个输出流提供“缓冲功能”。输出byte[]字节数组<br>BufferedOutputStream只提供了输出byte数据的方式,因此这种方式只能读取二进制流</p>
<blockquote>
<p>FileOutputStream 一个字节一个字节的向文件里输出数据</p>
</blockquote>
<h2 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><ol>
<li>支持字符串输出</li>
<li>支持换行输出</li>
<li>支持文件追加输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter writer = Files.newBufferedWriter(Paths.get(<span class="string">"new.txt"</span>), StandardCharsets.UTF_8);</span><br><span class="line">writer.write(<span class="string">"123456\n"</span>); <span class="comment">// 换行输出</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>另外还有一点需要提到的是FileWriter, 它一个字符一个字符地输出</p>
</blockquote>
<h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>OutputStreamWriter 将字节流转换为字符流。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码，如：GBK。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入UTF-8格式编码的文件</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">try</span> (Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">		<span class="keyword">new</span> FileOutputStream(file), <span class="string">"UTF8"</span>))) &#123;</span><br><span class="line"></span><br><span class="line">	out.append(<span class="string">"Website UTF-8"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line">	out.append(<span class="string">"中文 UTF-8"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">	out.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>标准IO重定向</p>
<p>打印输出流,用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。PrintStream永远不会抛出IOException；PrintStream提供了自动flush和字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</p>
<p>System类提供了一些简单的静态方法调用,以允许我们对标准输入,输出和错误IO进行重定向IO重定向是对字节流的操纵而不是字符流,因此在该例中使用的是InputStream和OutputStream而不是Reader和Writer</p>
<p>示例 如果在显示器上创建大量输出,而这些输出滚动地太快而无法阅读时,IO重定向就显得很有用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PrintStream console = System.out;</span><br><span class="line">BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Redirecting.java"</span>));</span><br><span class="line"></span><br><span class="line">PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"MapDB.test.out"</span>)));</span><br><span class="line"></span><br><span class="line">System.setIn(in);</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">	System.out.println(s);</span><br><span class="line"></span><br><span class="line">out.close(); <span class="comment">// Remember this!</span></span><br><span class="line">System.setOut(console);</span><br></pre></td></tr></table></figure></p>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>用于向文本输出流打印对象的格式化表示形式。它实现在 PrintStream 中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p>
<p>FileWriter可以向文件输出数据. 首先创建一个与指定文件连接的FileWriter.然后使用BufferedWriter对其进行包装进行性能提升 最后使用PrintWriter提供格式化功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));) &#123;</span><br><span class="line">	out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>System.out 是一个PrintStream,而PrintStream是一个OutputStream而PrintWriter有一个参数是接受OutputStream,因此我们可以将System.out转换成PrintWriter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out);) &#123;</span><br><span class="line">out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 写文件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 写文件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 序列化/" title="JAVA 序列化" itemprop="url">JAVA 序列化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成. 如上所示的代码，由于writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段. </p>
<h2 id="Flushable"><a href="#Flushable" class="headerlink" title="Flushable"></a>Flushable</h2><p>实现了Flushable接口的类的对象，可以强制将缓存的输出写入到与对象关联的流中. 写入流的所有I/O类都实现了Flushable接口. </p>
<h2 id="ObjectInputValidation"><a href="#ObjectInputValidation" class="headerlink" title="ObjectInputValidation"></a>ObjectInputValidation</h2><p>序列化流验证机制.一般情况下，我们认为序列化流中的数据总是与最初写到流中的数据一致，这并没有问题. 但当黑客获取流信息并篡改一些敏感信息重新序列化到流中后，用户通过反序列化得到的将是被篡改的信息. Java序列化提供一套验证机制. 序列化类通过实现 java.io.ObjectInputValidation接口，就可以做到验证了</p>
<h2 id="ObjectStreamConstants"><a href="#ObjectStreamConstants" class="headerlink" title="ObjectStreamConstants"></a>ObjectStreamConstants</h2><p>Java序列化序列化对象的信息包括：类元数据描述、类的属性、父类信息以及属性域的值. Java将这些信息分成3部分：序列化头信息、类的描述部分以及属性域的值部分. 现在对a.txt文件加以分析，其中包含一些序列化机制中提供的特殊字段，这些字段被定义在java.io.ObjectStreamConstants接口中.  </p>
<h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><p>用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”</p>
<p>从DataInputStream一次一个字节地读取字符,那么任何值都是合法的,因此返回值不能用来检测输入是否结束.但是可以使用available()函数来查看还有多少字符可供读取</p>
<p>available()函数的工作方式会随之所读取的媒介类不同而不同, 该函数从字面上的意思来讲就是”在没有阻塞的情况下所能读取的字节数”.对于文件这指的是整个文件,而对于其他流可能就不是这样的</p>
<p>格式化的内存输入 当读取格式化数据时可以使用DataInputStream，它是一个面向字节的IO类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(TestDataInputStream.class.getCanonicalName())));) &#123;</span><br><span class="line">	<span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">		System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataInput 接口用于从二进制流中读取字节，并重构所有 Java 基本类型数据. 同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具. 对于此接口中的所有数据读取例程来说，如果在读取到所需字节数的数据之前已经到达文件末尾 (end of file)，则都将抛出 EOFException（IOException 的一种）. 如果因为文件末尾以外的其他原因无法读取字节，则抛出 IOException而不是 EOFException. 尤其在输入流已关闭的情况下，将抛出 IOException. </p>
</blockquote>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p>用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”. </p>
<p>我们可以使用DataOutputStream指定格式存储数据, 然后使用DataInputStream轻松的再次指定读取格式来恢复这些数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line"><span class="comment">// Only readUTF() will recover the Java-UTF String properly:</span></span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataOutput 接口用于将任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流. 同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具. 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException.</p>
</blockquote>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。</p>
<h2 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 序列化/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 序列化/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 文件操作/" title="JAVA 文件操作" itemprop="url">JAVA 文件操作</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="FileFilter"><a href="#FileFilter" class="headerlink" title="FileFilter"></a>FileFilter</h2><p>检测文件是否存在.FileFilter 和他的前身FilenameFilter 唯一的不同是FileFilter 提供文件对象的访问方法,而FilenameFilter 是按照目录和文件名的方式来工作的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileFilter fileFilter = pathname -&gt; &#123;</span><br><span class="line">	System.out.println(pathname.getPath());</span><br><span class="line">	<span class="keyword">return</span> pathname.isFile();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fileFilter.accept(<span class="keyword">new</span> File(<span class="string">"D:\\hazelcast-documentation-3.5.3.pdf"</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="FilenameFilter"><a href="#FilenameFilter" class="headerlink" title="FilenameFilter"></a>FilenameFilter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FilenameFilter filenameFilter = (dir, name) -&gt; &#123;</span><br><span class="line">	System.out.println(dir);</span><br><span class="line">	System.out.println(name);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">filenameFilter.accept(<span class="keyword">new</span> File(<span class="string">"D"</span>), <span class="string">"hazelcast-documentation-3.5.3.pdf"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File对象给我们提供了以下的功能</p>
<ul>
<li>删除文件</li>
<li>文件重命名</li>
<li>创建新的文件</li>
<li>创建新的文件</li>
<li>获取文件的最后修改时间</li>
<li>设置文件只读</li>
<li>设置文件可写</li>
<li>获取文件长度(总字节数)</li>
<li>获取文件路径</li>
<li>获取绝对文件路径</li>
<li>文件是否隐藏</li>
<li>获得剩余磁盘空间？</li>
<li>拷贝文件夹</li>
<li>遍历文件夹</li>
<li>检查文件夹是否为空？</li>
</ul>
<h2 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h2><p>用来表示开放文件、开放套接字等.当FileDescriptor表示某文件时,我们可以通俗的将FileDescriptor看成是该文件.但是,我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作,则需要新创建FileDescriptor对应的FileOutputStream,再对文件进行操作.</p>
<p>类实例作为一个不透明的句柄底层机器特有的结构表示一个打开的文件,打开的套接字或其他来源或字节的接收器.以下是关于FileDescriptor要点：</p>
<ol>
<li>主要实际使用的文件描述符是创建一个FileInputStream或FileOutputStream来遏制它.</li>
<li>应用程序不应创建自己的文件描述符.</li>
</ol>
<h2 id="FileLock"><a href="#FileLock" class="headerlink" title="FileLock"></a>FileLock</h2><p>锁定文件</p>
<p>ByteBuffer.allocate()语句改为ByteBuffer.allocateDirect().用来证实性能之间的差异,但是请注意程序的启动时间是否发生了明显的改变.</p>
<p>修改{@link JGrep}让其使java的nio内存映射文件.</p>
<p>JDK1.4引入了文件加锁机制,它允许我们同步访问某个作为共享资源的文件.不过,竞争同一文件的两个线程可能在不同的Java虚拟机上;或者一个是Java线程,另一个是操作系统中其他的某个本地线程.</p>
<p>文件锁对其他的操作系统进程是可见的,因为Java的文件加锁直接映射到了本地操作系统的加锁工具.通过对FileChannel调用tryLock()或lock(),就可以获得整个文件的FileLock.</p>
<p>(SocketChannel、DatagramChannel和 ServerSocketChannel不需要加锁,因为他们是从单进程实体继承而来;我们通常不在两个进程之间共享网络socket.)</p>
<p>tryLock()是非阻塞式的,它设法获取锁,但是如果不能获得(当其他一些进程已经持有相同的锁,并且不共享时),它将直接从方法调用返回.lock()则是阻塞式的,它要阻塞进程直至锁可以获得,或调用lock()的线程中断,或调用lock()的通道关闭.</p>
<p>使用FileLock.release()可以释放锁.</p>
<p>也可以使用此方法对文件上锁tryLock()或者lock()其中,加锁的区域由size-position决定.第三个参数指定是否是共享锁.</p>
<p>尽管无参数的加锁方法将根据文件尺寸的变化而变化,但是具有固定尺寸的锁不随文件尺寸的变化而变化.如果你获得了某一区域(从position到position+size)上的锁,当文件增大超出position+size时,那么在position+size之外的部分不会被锁定.无参数的加锁方法会对 整个文件进行加锁,甚至文件变大后也是如此.</p>
<p>对独占锁或者共享锁的支持必须由底层的操作系统提供.如果操作系统不支持共享锁并为每一个请求都创建一个锁,那么它就会使用独占锁.</p>
<p>锁的 类型(共享或独占)可以通过FileLock.isShared()进行查询.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">FileLock fl = fos.getChannel().tryLock();</span><br><span class="line"><span class="keyword">if</span> (fl != <span class="keyword">null</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">"Locked File"</span>);</span><br><span class="line">	TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">	fl.release();</span><br><span class="line">	System.out.println(<span class="string">"Released Lock"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fos.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="DirectoryStream"><a href="#DirectoryStream" class="headerlink" title="DirectoryStream"></a>DirectoryStream</h2><p>遍历某个文件夹内的所有文件,但是不会遍历子目录. 也就是这会遍历当前路径中的所有文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DirectoryStream&lt;Path&gt; paths = Files.newDirectoryStream(Paths.get(<span class="string">"E:"</span>));</span><br><span class="line">paths.forEach(path -&gt; &#123;</span><br><span class="line">	System.out.println(path.getFileName());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>SecureDirectoryStream</p>
</blockquote>
<h2 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h2><p>遍历某个文件夹内的所有文件接口.</p>
<p><code>SimpleFileVisitor</code>实现了这个接口. 与<code>DirectoryStream</code> 不同的是,这个类会遍历目录下包括子目录的所有文件并且提供了多种处理接口方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SimpleFileVisitor visitor = <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(file.getFileName());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Files.walkFileTree(Paths.get(<span class="string">"E:"</span>), visitor);</span><br></pre></td></tr></table></figure></p>
<h2 id="监控文件变化"><a href="#监控文件变化" class="headerlink" title="监控文件变化"></a>监控文件变化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WatchService service = FileSystems.getDefault().newWatchService();</span><br><span class="line">		Paths.get(<span class="string">"D:/"</span>).register(service,</span><br><span class="line">		ENTRY_CREATE,</span><br><span class="line">		ENTRY_DELETE,</span><br><span class="line">		ENTRY_MODIFY);</span><br><span class="line"></span><br><span class="line">WatchKey watchKey = service.take();</span><br><span class="line"></span><br><span class="line">watchKey.pollEvents().stream().forEach(watchEvent -&gt; &#123;</span><br><span class="line">	System.out.println(watchEvent.context() + <span class="string">"  "</span> + watchEvent.kind());</span><br><span class="line">&#125;);</span><br><span class="line">watchKey.reset();</span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><ol>
<li>copy</li>
<li>createDirectories</li>
<li>createDirectory</li>
<li>createFile</li>
<li>createLink</li>
<li>createSymbolicLink</li>
<li>createTempDirectory</li>
<li>createTempFile</li>
<li>delete</li>
<li>deleteIfExists</li>
<li>exists</li>
<li>getAttribute</li>
<li>getFileAttributeView</li>
<li>getFileStore</li>
<li>getLastModifiedTime</li>
<li>getOwner</li>
<li>getPosixFilePermissions</li>
<li>isDirectory</li>
<li>isExecutable</li>
<li>isHidden</li>
<li>isReadable</li>
<li>isRegularFile</li>
<li>isSameFile</li>
<li>isSymbolicLink</li>
<li>isWritable</li>
<li>move</li>
<li>newBufferedReader</li>
<li>newBufferedWriter</li>
<li>newByteChannel</li>
<li>newDirectoryStream</li>
<li>newInputStream</li>
<li>newOutputStream</li>
<li>notExists</li>
<li>probeContentType</li>
<li>readAllBytes</li>
<li>readAllLines</li>
<li>readAttributes</li>
<li>readSymbolicLink</li>
<li>setAttribute</li>
<li>setLastModifiedTime</li>
<li>setOwner</li>
<li>setPosixFilePermissions</li>
<li>walkFileTree</li>
<li>write</li>
</ol>
<h2 id="FileStore"><a href="#FileStore" class="headerlink" title="FileStore"></a>FileStore</h2><p>代表了真正的存储设备,提供了设备的详尽信息</p>
<h2 id="FileSystems"><a href="#FileSystems" class="headerlink" title="FileSystems"></a>FileSystems</h2><ul>
<li>FileSystems.getDefault() ：返回 JVM 默认的 FileSystem – 一般说来,也就是操作系统的默认文件系统</li>
<li>FileSystems.getFileSystem(uri) ： 可以获取远程主机的FileSystem<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileSystem system = FileSystems.getDefault();</span><br><span class="line"><span class="comment">// 得到文件系统支持的属性视图列表</span></span><br><span class="line">Set&lt;String&gt; views = system.supportedFileAttributeViews();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>FileSystem</p>
</blockquote>
<h2 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h2><blockquote>
<p>Path 类可以在任何文件系统（FileSystem）和任何存储空间 Path 类引用默认文件系统（计算机的文件系统）的文件,但是 NIO.2是完全模块化的—— FileSystem 的具体实现是在内存中的一组数据,因此在网络环境或在虚拟文件系统中,NIO.2 也完全适用.NIO.2提供给我们在文件系统中操作文件、文件夹或链接的所有方法</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 文件操作/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 文件操作/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 读文件/" title="JAVA 读文件" itemprop="url">JAVA 读文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><p>我们使用<code>FileInputStream</code>, <code>BufferedInputStream</code>来读取文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取二进制文件</span></span><br><span class="line"><span class="keyword">try</span> (BufferedInputStream bf = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">		<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.available()];</span><br><span class="line">	bf.read(data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BufferedInputStream</code>是一个带有缓冲区域的<code>InputStream</code>, 支持<code>mark()</code>标记和<code>reset()</code>重置方法.输入到byte[]数组里.</p>
<p><code>BufferedInputStream</code>只将数据读取进byte字节数组里, 因此这种方式只能读取二进制字节流</p>
<blockquote>
<p>FileInputStream 一个字节一个字节的从文件里读取数据</p>
</blockquote>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>BufferedReader 从字符输入流中读取文本,缓冲各个字符.提供字符、数组和行的高效读取.<br>我们有俩种方式创建BufferedReader.</p>
<ul>
<li>使用带缓冲区的写入器 <code>Files.newBufferedReader(Paths.get(&quot;new.txt&quot;), StandardCharsets.UTF_8);</code>;</li>
<li>读取UTF-8格式编码的文件 <code>new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))</code></li>
</ul>
<blockquote>
<p>InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符.将“字节输入流”转换成“字符输入流”.它继承于Reader.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = Files.newBufferedReader(Paths.get(<span class="string">"new.txt"</span>), StandardCharsets.UTF_8);</span><br><span class="line">reader.lines().forEach(line -&gt; System.out.println(line));</span><br></pre></td></tr></table></figure>
<p>我们可以使用JAVA8中的Stream来快捷的遍历每一行</p>
<blockquote>
<p>从标准IO中输入. 按照标准的IO模型,Java提供了<code>System.out, System.out, System.err System.out,System.err</code> 已经被包装成了<code>PrintStream</code>对象,但是<code>System.in</code>作为原生<code>InputStream</code>却没有进行过任何包装. 所以在使用<code>System.in</code>时必须对其进行包装,下例中展示了,我们使用<code>InputStreamReader</code>将<code>System.in</code>包装<code>Reader</code>,然后再包装一层<code>BufferedReader</code></p>
<p>另外还有一点需要提到的是FileReader, 它一个字符一个字符地读取.</p>
</blockquote>
<h2 id="LineNumberInputStream"><a href="#LineNumberInputStream" class="headerlink" title="LineNumberInputStream"></a>LineNumberInputStream</h2><p>此类是一个输入流过滤器,它提供跟踪当前行号的附加功能.行是以回车符 (<code>\r</code>)、换行符 (<code>\n</code>)或回车符后面紧跟换行符结尾的字节序列.在所有这三种情况下,都以单个换行符形式返回行终止字符.行号以 0 开头,并在 read 返回换行符时递增 1.</p>
<h2 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h2><p>跟踪行号的缓冲字符输入流.此类定义了方法 <code>setLineNumber(int)</code> 和 <code>getLineNumber()</code>,它们可分别用于设置和获取当前行号.默认情况下,行编号从 0 开始.该行号随数据读取在每个行结束符处递增,并且可以通过调用 <code>setLineNumber(int)</code> 更改行号.但要注意的是,<code>setLineNumber(int)</code> 不会实际更改流中的当前位置；它只更改将由<code>getLineNumber()</code>返回的值.可认为行在遇到以下符号之一时结束：换行符（<code>\n</code>）、回车符（<code>\r</code>）、回车后紧跟换行符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> (FileReader reader = <span class="keyword">new</span> FileReader(IOUtils.newFile(<span class="string">""</span>));</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(reader);) &#123;</span><br><span class="line">	<span class="keyword">while</span> (lnr.readLine() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		lineCount++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>读写随机访问文件 <code>RandomAccessFile</code>除了实现了<code>DataInput</code>和<code>DataOutput</code>接口之外,有效地与IO继承层次结构的其他部分实现了分离.</p>
<p>因为它不支持装饰模式,所以不能将其与<code>InputStream</code>和<code>OutputStream</code>子类的任何部分组合起来而且必须假定<code>RandomAccessFile</code>已经被正确的缓冲</p>
<p>用来访问那些保存数据记录的文件的,你就可以用<code>seek()</code>方法来访问记录,并进行读写了.这些记录的大小不必相同；但是其大小和位置必须是可知的.但是该类仅限于操作文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取所有的行</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile r = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length(); i++) &#123;</span><br><span class="line">		r.read();	<span class="comment">// r.readLine();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据,第二个参数必须为 "r", "rw", "rws", or "rwd"</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile w = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>; i++)</span><br><span class="line">		w.writeByte(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileChannel fc = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>)</span><br><span class="line">		.getChannel();) &#123;</span><br><span class="line"></span><br><span class="line">	IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fc.size())</span><br><span class="line">			.asIntBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">		ib.put(ib.get(i - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>);</span><br><span class="line">raf.writeInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">	raf.seek(raf.length() - <span class="number">4</span>);</span><br><span class="line">	raf.writeInt(raf.readInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></p>
<h2 id="getResourceAsStream"><a href="#getResourceAsStream" class="headerlink" title="getResourceAsStream"></a>getResourceAsStream</h2><p>我们还可以使用类加载器的<code>getResourceAsStream()</code>从指定路径或者jar包中加载文件资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = ReloadClass.class.getClassLoader().getResourceAsStream(path);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[input.available()];</span><br><span class="line">	input.read(bytes);</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 读文件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 读文件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/20/netty/ByteBuf/" title="Netty ByteBuf" itemprop="url">Netty ByteBuf</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-19T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先我们来看一下netty buffer包的继承结构<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/netty/bytebuf.jpg" alt=""><br>接下来我会对几个类进行代码测试.</p>
<p>首先我们来看一下如何使用Netty提供的工具类构建一个ByteBuf<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1024</span>, buf.capacity());</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>ByteBufAllocator</code>这个工具类构建了一个<code>1024</code>大小的<code>ByteBuf</code>出来.</p>
<p>ByteBuf提供了 <code>readerIndex</code> 和 <code>writerIndex</code> 进行缓冲区的顺序读写操作.</p>
<ul>
<li><code>readerIndex</code>标志读取索引</li>
<li><code>writerIndex</code>标志写入索引</li>
<li>[0, readerIndex] 已经读取多的缓冲区区间</li>
<li>[readerIndex, writerIndex] 可读的缓冲区区间</li>
<li>[writerIndex, capacity]  可写的缓冲区区间</li>
</ul>
<blockquote>
<p>每个索引移动的单位是<code>bytes</code>, 在下例中我们向ByteBuf写入一个int数值, <code>writerIdex</code>会移动4个<code>bytes</code></p>
</blockquote>
<h2 id="ByteBuf-API"><a href="#ByteBuf-API" class="headerlink" title="ByteBuf API"></a>ByteBuf API</h2><p>我们首先看一下ByteBuf提供的API</p>
<h3 id="ByteBuf-write"><a href="#ByteBuf-write" class="headerlink" title="ByteBuf write"></a>ByteBuf write</h3><p>接下来我们看一下向ByteBuf缓冲区写入数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 写入一个Int数值, writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'a'</span>);</span><br><span class="line">	<span class="comment">// 写入一个Char字符, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes);</span><br><span class="line">	<span class="comment">// 写入一个byte数组, 由于byte数组只有一个元素, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 我们将三个元素的byte数组写入ByteBuf中,但是在写入的时候我们指定了开始索引和结束索引,</span></span><br><span class="line">	<span class="comment">// 由于我们的开始索引和结束索引相等, 因此ByteBuf中只写入了1这个元素</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf1.writeInt(<span class="number">1</span>);</span><br><span class="line">	buf.writeBytes(buf1);</span><br><span class="line">	<span class="comment">// 我们向ByteBuf中写入另一个ByteBuf, 它的索引仍然是增长4. ByteBuf不仅仅可以写入BuyeBuf,还可以写入InputStream和ByteBuffer</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">0.1f</span>);</span><br><span class="line">	<span class="comment">// 写入一个float, 由于float也是占用4个字节, 因此writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">	buf.writeByte(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个byte, writerIndex向后移动1个字节,至于写进去的数字大于128,会发生什么,我们在read的时候看一下结果</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个short, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">1000.0</span>d);</span><br><span class="line">	<span class="comment">// 写入一个double, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">// 写入一个boolean, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">100l</span>);</span><br><span class="line">	<span class="comment">// 写入一个long, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteOverLoadMaxCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456"</span>.getBytes());</span><br><span class="line">	<span class="comment">// 虽然在分配的时候我们只分配了5个字节大小的缓冲区,但是我们写入6个字节它也并不报错,</span></span><br><span class="line">	<span class="comment">// 而且我们观察到writerIndex确实增长到了6,说明ByteBuf会进行自动拓容.</span></span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ByteBuf-read"><a href="#ByteBuf-read" class="headerlink" title="ByteBuf read"></a>ByteBuf read</h3><p>刚才我们看了向ByteBuf缓冲区写入数据的API,接下来我们看一下从ByteBuf缓冲区读取数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 读取Int, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'1'</span>);</span><br><span class="line">	<span class="keyword">char</span> read = buf.readChar();</span><br><span class="line">	<span class="comment">// 读取Char, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="string">'1'</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read);</span><br><span class="line">	<span class="comment">// 读取byte数组, 这里需要注意的是, read字节数组的长度不能大于ByteBuf的readerIndex的值,否则会产生数组越界</span></span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, read[<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 从第三个索引开始读取到第4个索引的位置, 读取2个字节, readerIndex移动到第4个索引位置上</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, read[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead3Bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 读取3个字节, readerIndex向后移动3字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">10.0f</span>);</span><br><span class="line">	<span class="keyword">float</span> read = buf.readFloat();</span><br><span class="line">	<span class="comment">// 读取Float, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>.f, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">10l</span>);</span><br><span class="line">	buf.readLong();</span><br><span class="line">	<span class="comment">// 读取long, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 读取byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">10</span>);</span><br><span class="line">	buf.readShort();</span><br><span class="line">	<span class="comment">// 读取short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">	buf.readBoolean();</span><br><span class="line">	<span class="comment">// 读取boolean, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">10.0</span>d);</span><br><span class="line">	buf.readDouble();</span><br><span class="line">	<span class="comment">// 读取double, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(-<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">short</span> read = buf.readUnsignedByte();</span><br><span class="line">	<span class="comment">// 读取无符号byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">246</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(-<span class="number">1024</span>);</span><br><span class="line">	<span class="comment">// 我们首先读取出-1024,这个负数,然后转化成无符号数字64512</span></span><br><span class="line">	<span class="keyword">int</span> read = buf.readUnsignedShort();</span><br><span class="line">	<span class="comment">// 读取无符号Short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">64512</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readableBytes());</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 我们读取一个byte之后, 可读取字节变成了9个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">long</span> read = buf.readUnsignedInt();</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadSlice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	ByteBuf read = buf.readSlice(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">// slice出来的ByteBuf与原ByteBuf共享缓冲区</span></span><br><span class="line">	Assert.assertEquals(<span class="number">5</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read.readByte());</span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.readByte());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 从一个byte数组中读取一个int, 会读取出1, 2, 3, 4这四个byte转换成int为16909060</span></span><br><span class="line">	Assert.assertEquals(<span class="number">16909060</span>, read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="discard-bytes"><a href="#discard-bytes" class="headerlink" title="discard bytes"></a>discard bytes</h3><p>在前面的测试中我们看到了,当向ByteBuf写入数据时,当超出分配内存大小时,ByteBuf会进行自动拓容(重新生成一个数组缓冲区,然后将原先的缓冲区内容拷贝到新的缓冲区中),这样一来ByteBuf占用的内从会越来越大. 我们可以是<code>discardReadBytes()</code>这个方法重用以前的缓冲区, 它会将[0, readerIndex]区间的内存舍弃掉(内部也是数组复制), 这么着就节间的重用了以前的缓冲区,但是这种方式有一点就是如果频繁的调用这个方法会带来性能问题.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃已读字节, readerIndex重置为0</span></span><br><span class="line">buf.discardReadBytes();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 6 = 44</span></span><br></pre></td></tr></table></figure></p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>这个操作并不会情况缓冲区的内容只是用来将readerIndex和writerIndex重置为0. 但是缓冲区的内容我们是仍然可以读到的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置readerIndex和writerIndex</span></span><br><span class="line">buf.clear();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 0</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 readerIndex = 0</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 capacity - writerIndex = 50</span></span><br><span class="line"><span class="comment">// 设置writerIndex</span></span><br><span class="line">buf.writerIndex(<span class="number">6</span>);</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 writerIndex - readerIndex = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 44</span></span><br><span class="line">System.out.println(buf.readByte());</span><br></pre></td></tr></table></figure></p>
<h3 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark reset"></a>mark reset</h3><p>mark reset相关的四个方法也是对指针位置的操作</p>
<ul>
<li><code>markReaderIndex()</code> 记录readerIndex</li>
<li><code>markWriterIndex()</code> 记录writerIndex</li>
<li><code>resetReaderIndex()</code>  将记录的readerIndex重置到当前的readerIndex值</li>
<li><code>resetWriterIndex()</code>  将记录的writerIndex重置到当前的writerIndex值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	buf.markReaderIndex();</span><br><span class="line">	buf.readBytes(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	buf.resetReaderIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriterIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.markWriterIndex();</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.writerIndex());</span><br><span class="line">	buf.resetWriterIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>ByteBuf提供丰富的API让我查找某个Byte<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的范围内查找某个byte</span></span><br><span class="line"><span class="keyword">int</span> idx = buf.indexOf(<span class="number">0</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">idx = buf.indexOf(<span class="number">3</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间查找值</span></span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">buf.readBytes(<span class="number">3</span>);</span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间遍历查找值</span></span><br><span class="line">idx = buf.forEachByte(b -&gt; b == (<span class="keyword">byte</span>) <span class="number">6</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="derived-buffers"><a href="#derived-buffers" class="headerlink" title="derived buffers"></a>derived buffers</h3><p>ByteBuf提供多种API用于创建某个ByteBuf的视图或者复制版本</p>
<ul>
<li><code>duplicate()</code> 复制ByteBuf对象, 俩个对象共享同一个缓冲区,但是各自维护自己的索引(readerIndex, writerIndex)</li>
<li><code>copy()</code> 复制ByteBuf对象, 俩个对象共享有自己的缓冲区, 缓冲区和索引都不共享</li>
<li><code>slice()</code>  复制Bytebuf对象,但是只复制[readerIndex, writerIndex]区间的缓冲区, 俩个对象的缓冲区是共享的,但是维护各自的索引</li>
</ul>
<h3 id="get-set"><a href="#get-set" class="headerlink" title="get set"></a>get set</h3><p>ByteBuf不仅仅支持read, write的顺序读写还支持get,set的随机读取。 但是get/set不会进行自动拓容.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = buf.getByte(<span class="number">2</span>);</span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 9</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// 0</span></span><br><span class="line">System.out.println(b);		<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>Netty的内存池由<code>PoolArea</code>. <code>PoolArea</code>由多个<code>PoolChunk</code>组成. </p>
<h2 id="ButeBuf-类型"><a href="#ButeBuf-类型" class="headerlink" title="ButeBuf 类型"></a>ButeBuf 类型</h2><p>看完ByteBuf的API操作我们来看一下ByteBuf的分类,在内存使用种类上ByteBuf分为以下俩类</p>
<ul>
<li>DirectByteBuf : 使用JVM堆外内存分配. 虽然分配和回收速度慢一些,但是从SocketChannel中写入或者读取数据由于少了一次内存复制,因此速度较快.(SocketIO通信时适合使用)</li>
<li>HeapByteBuf: 使用JVM堆内内存分配. 内存分配和回收速度较快,但是读写Socket IO的时候由于会额外进行一次内存复制,堆内存对应的缓冲区复制到内核Channel中,性能会有下降.(后端业务在编解码时适合使用)</li>
</ul>
<p>在内存使用种类上由分为以下俩类</p>
<ul>
<li>PooledByteBuf: 基于内存对象池的ByteBuf, </li>
<li>UnpooledByteBuf: </li>
</ul>
<blockquote>
<p>UnpooledDirectByteBuf, UnpooledHeapByteBuf, UnpooledUnsafeDirectByteBuf ,PooledDirectByteBuf, PooledHeapByteBuf</p>
</blockquote>
<h2 id="AbstractByteBuf"><a href="#AbstractByteBuf" class="headerlink" title="AbstractByteBuf"></a>AbstractByteBuf</h2><p><code>AbstractByteBuf</code>继承自<code>ByteBuf</code>, 它内部并没有定义ByteBuf的缓冲区实现,只是通过定义<code>readerIndex</code>, <code>writerIndex</code>, <code>capacity</code>等实现ByteBuf接口中的各种API, 具体的缓冲区实现则由子类实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;ByteBuf&gt; leakDetector = <span class="keyword">new</span> ResourceLeakDetector&lt;ByteBuf&gt;(ByteBuf.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> readerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> writerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SwappedByteBuf swappedBuf;</span><br></pre></td></tr></table></figure></p>
<p>除了操作具体缓冲区API没有实现之外 <code>AbstractByteBuf</code>为我们实现了大量的API,首先我们看一下读数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 检查当前缓冲区中的可读数据是否满足length长度</span></span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    <span class="comment">// 将当前缓冲区的数据从readerIndex开始读取length个长度到目标dst缓冲区中. </span></span><br><span class="line">    <span class="comment">// 这个方法也就是拷贝一部分数据到新的缓冲区中,但是并不会改变当前缓冲区的readerIndex和writerIndex</span></span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length);</span><br><span class="line">    readerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看一下写数据的API实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的<code>setBytes();</code>是由子类具体实现, 我们着重看一下<code>ensureWritable()</code>方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果要写入数据的字节小于0的话, 则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minWritableBytes: %d (expected: &gt;= 0)"</span>, minWritableBytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// minWritableBytes &lt;= capacity() - writerIndex, 要写入的字节数小于可写的字节数则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceLeakDetector"><a href="#ResourceLeakDetector" class="headerlink" title="ResourceLeakDetector"></a>ResourceLeakDetector</h3><p><code>ResourceLeakDetector</code>用于检测内存泄漏. 它被所有ByteBuf实例共享.</p>
<h3 id="SwappedByteBuf"><a href="#SwappedByteBuf" class="headerlink" title="SwappedByteBuf"></a>SwappedByteBuf</h3><h2 id="AbstractReferenceCountedByteBuf"><a href="#AbstractReferenceCountedByteBuf" class="headerlink" title="AbstractReferenceCountedByteBuf"></a>AbstractReferenceCountedByteBuf</h2><h2 id="UnPooledHeapByteBuf"><a href="#UnPooledHeapByteBuf" class="headerlink" title="UnPooledHeapByteBuf"></a>UnPooledHeapByteBuf</h2><p>不使用对象池的基于堆内存分配的字节缓冲区. 每次IO读写的时候都会创建一个新的UnPooledHeapByteBuf.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Netty/">Netty</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/20/netty/ByteBuf/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/20/netty/ByteBuf/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/19/JavaSE/java小常识/" title="JAVA 小常识" itemprop="url">JAVA 小常识</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="控制台乱码"><a href="#控制台乱码" class="headerlink" title="控制台乱码"></a>控制台乱码</h2><p>在windows系统里,我的cmd控制台的代码页是<code>65001(UTF)</code>,但是当我在指向java命令时却会发生乱码现象,只需要指向<code>chcp 936</code>这个命令,改变一下代码页就好了</p>
<h2 id="java命令"><a href="#java命令" class="headerlink" title="java命令"></a>java命令</h2><p><code>java  -jar ./tools-1.0-SNAPSHOT.jar</code> 从某个jar运行, mainfest文件必须指定MainClass属性,如果不指定的话,在运行<code>java</code>命令的时候就会产生 xxx.jar中没有主清单属性</p>
<p><code>java  -jar ./ App</code> 从指定的classpath下所有的jar中,寻找App主类运行</p>
<h2 id="获取周数"><a href="#获取周数" class="headerlink" title="获取周数"></a>获取周数</h2><p>通过<code>Calendar</code>我们可以知道某个日期处于一年中第几周<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(calendar.get(Calendar.WEEK_OF_YEAR));</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/19/JavaSE/java小常识/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/19/JavaSE/java小常识/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/19/redis/Redis事务/" title="Redis事务" itemprop="url">Redis事务</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="普通事务"><a href="#普通事务" class="headerlink" title="普通事务"></a>普通事务</h2><p>首先介绍普通事务<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>:</p>
<ul>
<li><code>MULTI</code>告诉 redis 服务器开启一个事务</li>
<li><code>EXEC</code>告诉 redis 开始执行事务</li>
<li><code>DISCARD</code>告诉 redis 取消事务</li>
</ul>
<p><code>MULTI</code>命令执行后, redis进入事务状态,redis会持续缓存某个客户端的命令(其他客户端处于饥饿状态).<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis-multi.png" alt=""><br>当redis接受到客户端的<code>EXEC</code>命令后会开始执行刚才缓存在事务队列里的任务. <code>DISCARD</code> 会将事务队列清空.<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis-tranactions.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET a &quot;&quot;redis 127.0.0.1:7006&gt; SET a &quot;&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; SET a &quot;a&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt;  EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET b &quot;b&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; EXEC</span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET n &quot;n&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET c &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; GET a</span><br><span class="line">&quot;a&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; GET b</span><br><span class="line">&quot;b&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; Get c</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br><span class="line">redis 127.0.0.1:7006&gt; GET n</span><br><span class="line">&quot;n&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用<code>MULTI</code>命令开启事务</li>
<li>输入一个错误的命令,点击回车,redis并没有报错,说明这个命令确实是被缓存起来了没有执行</li>
<li>使用<code>SET</code>命令将a设置为”a”</li>
<li>然后执行事务,我们看到俩条事务都执行完了,但是第一条命令并没有报错</li>
<li>然后再次使用<code>SET</code>命令将b设置为”b”</li>
<li>再次执行事务, 并不成功,提示我们要开启事务,说明事务一旦执行完就自动退出了</li>
<li>再次开启事务,然后使用<code>SET</code>命令将n设置为”n”</li>
<li>退出事务</li>
<li>接下来我们依次使用<code>GET</code>命令获取值,但是n取不到,说明退出事务确实没有执行事务队列里的命令<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis_transaction.png" alt=""></li>
</ol>
<h2 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h2><p>下来我们来看一下redis的watch机制<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch1.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch2.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch3.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch4.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis_watched_keys.png" alt=""></p>
<h2 id="pipline机制"><a href="#pipline机制" class="headerlink" title="pipline机制"></a>pipline机制</h2><p>参考文章</p>
<ul>
<li><a href="http://redisbook.readthedocs.org/en/latest/feature/transaction.html" target="_blank" rel="external"></a></li>
<li><a href="http://ju.outofmemory.cn/entry/81786" target="_blank" rel="external"></a></li>
<li><a href="http://redisdoc.com/topic/transaction.html#id2" target="_blank" rel="external"></a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Reids/">Reids</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/19/redis/Redis事务/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/19/redis/Redis事务/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/构建工具/gradle/" title="Gradle 初探" itemprop="url">Gradle 初探</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。</p>
<p>我使用idea创建一个gradle项目<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">group <span class="string">'wang.ming15.gradle'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.11'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="自定义任务"><a href="#自定义任务" class="headerlink" title="自定义任务"></a>自定义任务</h3><p>我们可以在task内部自由的使用groovy脚本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task t1 &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'task1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者这种方式<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> t2 &lt;&lt; &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">'t2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>defaultTasks</code>我们可以使用这个命令定义一些默认的task : <code>defaultTasks &#39;t1&#39;, &#39;t2&#39;</code></p>
</blockquote>
<h3 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h3><p>我们使用<code>dependsOn</code>语法可以让一个任务依赖于另外一个任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task t2 &lt;&lt; &#123;</span><br><span class="line">        println <span class="string">'t2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">t3</span><span class="params">(dependsOn: t2)</span> </span>&#123;</span><br><span class="line">    println <span class="string">'t3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下, t2任务会优先于t3任务执行</p>
<blockquote>
<p>需要注意的是, 如果t1依赖于t2, 那么当t2执行的时候会先执行t1</p>
</blockquote>
<h3 id="延迟依赖"><a href="#延迟依赖" class="headerlink" title="延迟依赖"></a>延迟依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">t3</span><span class="params">(dependsOn: <span class="string">'t4'</span>)</span> </span>&#123;</span><br><span class="line">    println <span class="string">'task3'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task t4 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在定义一个任务之后,再定义其所依赖的任务, 执行顺序仍然是t3 优先于t4</p>
<h3 id="任务操纵"><a href="#任务操纵" class="headerlink" title="任务操纵"></a>任务操纵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task t4 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task4'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task t5 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t5.dependsOn t4</span><br></pre></td></tr></table></figure>
<p>task还有其他一些api,参考<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html" target="_blank" rel="external"></a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如前例所示我们已经使用过Gradle提供的插件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们的项目使用某个插件的时候, 这个项目里就包含了那个插件的任务依赖等等</p>
<h3 id="java插件任务"><a href="#java插件任务" class="headerlink" title="java插件任务"></a>java插件任务</h3><p>我们使用了java插件, 然后我们打开idea右侧的Gradle标签(我们会看到一些java插件自带的一些task.)：<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/gradle/gradle_ui.jpg" alt=""></p>
<p>命令含义参考<a href="http://wiki.jikexueyuan.com/project/gradle/java-package.html" target="_blank" rel="external"></a></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在Gradle编译脚本文件中我们还可以自如的使用文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File configFile = file(<span class="string">'src/config.xml'</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>file()</code>方法我们就可以打开一个文件.</p>
<h3 id="文件集合"><a href="#文件集合" class="headerlink" title="文件集合"></a>文件集合</h3><p>我们还可以使用<code>files()</code>方法创建文件集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileCollection fils = files(<span class="string">"t.txt"</span>, <span class="keyword">new</span> File(<span class="string">"d.txt"</span>), [<span class="string">"a.txt"</span>, <span class="string">'b.txt'</span>])</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用<code>+</code>, <code>-</code>符号增加或者删减文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileCollection filc = files(<span class="string">"t.txt"</span>, <span class="keyword">new</span> File(<span class="string">"d.txt"</span>), [<span class="string">"a.txt"</span>, <span class="string">'b.txt'</span>])</span><br><span class="line">FileCollection newFiles1 = filc + files(<span class="string">"c.txt"</span>)</span><br><span class="line">FileCollection newFiles2 = filc - files(<span class="string">"c.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用<code>as</code>将其转换为<code>Set</code>或者<code>List</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set set1 = filc.files</span><br><span class="line">Set set2 = filc as Set</span><br><span class="line">List list = filc as List</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/构建工具/">构建工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/构建工具/gradle/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/构建工具/gradle/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/日志工具/Elasticsearch 基本操作/" title="Elasticsearch 基本操作" itemprop="url">Elasticsearch 基本操作</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>使用Elasticsearch自带的客户端,添加maven依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意,依赖里的版本号要和Elasticsearch服务器的版本号一致</p>
</blockquote>
<h2 id="节点客户端"><a href="#节点客户端" class="headerlink" title="节点客户端"></a>节点客户端</h2><p>节点客户端以一个 无数据节点 的身份加入了一个集群。换句话说，它自身是没有任何数据的，但是他知道什么数据在集群中的哪一个节点上，然后就可以请求转发到正确的节点上并进行连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Settings.Builder settings = Settings.settingsBuilder()</span><br><span class="line">		.put(<span class="string">"http.enabled"</span>, <span class="keyword">false</span>)</span><br><span class="line">		.put(<span class="string">"path.home"</span>, <span class="string">"D:\\log\\elasticsearch-1.7.1"</span>)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">Node node = nodeBuilder()</span><br><span class="line">		.local(<span class="keyword">true</span>)</span><br><span class="line">		.settings(settings)</span><br><span class="line">		.node();</span><br><span class="line"></span><br><span class="line">Client client = node.client();</span><br></pre></td></tr></table></figure></p>
<h2 id="传输客户端"><a href="#传输客户端" class="headerlink" title="传输客户端"></a>传输客户端</h2><p>更加轻量的传输客户端可以被用来向远程集群发送请求。他并不加入集群本身，而是把请求转发到集群中的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = Settings.settingsBuilder().build();</span><br><span class="line"></span><br><span class="line">Client client = TransportClient.builder().settings(settings).build()</span><br><span class="line">		.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="索引数据"><a href="#索引数据" class="headerlink" title="索引数据"></a>索引数据</h2><p>我们可以使用客户端提供的<code>prepareIndex()</code>方法索引数据,也就是向Elasticsearch添加数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse indexResponse = client.prepareIndex(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>).setSource(jsonObject.toJSONString()).execute().actionGet();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getVersion());</span><br></pre></td></tr></table></figure></p>
<p>结果输出为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse : <span class="number">01</span></span><br><span class="line">IndexResponse : idx01</span><br><span class="line">IndexResponse : type01</span><br><span class="line">IndexResponse : <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>idx01为索引值, type01为类型值, 01为id. 当我们重复的使用这三个值向 Elasticsearch 索引数据时是合法的,但是我们会得不到不同的版本号，也就是最好的输出的那个值</p>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>我们可以使用客户端提供的<code>prepareGet()</code>方法检索数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GetResponse getResponse = client.prepareGet(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">				.setOperationThreaded(<span class="keyword">false</span>)</span><br><span class="line">				.get();</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getVersion());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getSourceAsString());</span><br></pre></td></tr></table></figure></p>
<p>结果输出为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetResponse : <span class="number">01</span></span><br><span class="line">GetResponse : idx01</span><br><span class="line">GetResponse : type01</span><br><span class="line">GetResponse : <span class="number">4</span></span><br><span class="line">GetResponse : &#123;<span class="string">"age"</span>:<span class="string">"19"</span>,<span class="string">"name"</span>:<span class="string">"Tom"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>setOperationThreaded()</code>这个方法是用来设置, 操作是否在其他的线程中执行, 设置为true就是在其他的线程中执行. 注意该操作仍然是异步执行的.</p>
</blockquote>
<h4 id="检索多个数据"><a href="#检索多个数据" class="headerlink" title="检索多个数据"></a>检索多个数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.prepareMultiGet()</span><br><span class="line">	  .add(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">	  .add(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"02"</span>)</span><br><span class="line">	  .get()</span><br><span class="line">	  .forEach(response -&gt; System.out.println(JSON.toJSONString(response, <span class="keyword">true</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DeleteResponse deleteResponse = client.prepareDelete(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>).get();</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getVersion());</span><br></pre></td></tr></table></figure>
<p>结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DeleteResponse : <span class="number">01</span></span><br><span class="line">DeleteResponse : idx01</span><br><span class="line">DeleteResponse : type01</span><br><span class="line">DeleteResponse : <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们再检索一边数据的话,会得到结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetResponse : <span class="number">01</span></span><br><span class="line">GetResponse : idx01</span><br><span class="line">GetResponse : type01</span><br><span class="line">GetResponse : -<span class="number">1</span></span><br><span class="line">GetResponse : <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<p>说明那个文档已经被删除了</p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>我们可以使用<code>UpdateRequest</code>或者<code>prepareUpdate()</code>方法来对数据进行更新<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest();</span><br><span class="line">updateRequest.index(<span class="string">"idx01"</span>);</span><br><span class="line">updateRequest.type(<span class="string">"type01"</span>);</span><br><span class="line">updateRequest.id(<span class="string">"01"</span>);</span><br><span class="line">updateRequest.doc(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">client.update(updateRequest).get();</span><br></pre></td></tr></table></figure></p>
<p>当我们在通过<code>get</code>获取数据的时候,会发现数据已经发生了变化</p>
<p>更新还有一个有用的功能,就是在更新的时候能实现如果有就更新,没有就插入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx01"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest()</span><br><span class="line">		.index(<span class="string">"idx01"</span>)</span><br><span class="line">		.type(<span class="string">"type02"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.doc(jsonObject.toJSONString())</span><br><span class="line">		.upsert(indexRequest);</span><br><span class="line"></span><br><span class="line">client.update(updateRequest).get();</span><br></pre></td></tr></table></figure></p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>elasticsearch内置的客户端中还有批处理功能,但是批处理只支持增删改, 不支持查询的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BulkRequestBuilder bulkRequest = client.prepareBulk();</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line">bulkRequest.add(indexRequest);</span><br><span class="line"></span><br><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.doc(jsonObject.toJSONString());</span><br><span class="line">bulkRequest.add(updateRequest);</span><br><span class="line"></span><br><span class="line">DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>);</span><br><span class="line">bulkRequest.add(deleteRequest);</span><br><span class="line">BulkResponse bulkResponse = bulkRequest.get();</span><br><span class="line">bulkResponse.forEach(response -&gt; System.out.println(response.getId()));</span><br><span class="line"></span><br><span class="line">GetResponse getResponse = client.prepareGet(<span class="string">"idx02"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">		.setOperationThreaded(<span class="keyword">false</span>)</span><br><span class="line">		.get();</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getVersion());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getSourceAsString());</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日志工具/">日志工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/日志工具/Elasticsearch 基本操作/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/日志工具/Elasticsearch 基本操作/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/memcached/Memcache/" title="memcached" itemprop="url">memcached</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>memcached是一个高性能内存对象缓存系统. 它基于libevent,可方便地拓展为任意大小, 而且对防止内存swap和使用非阻塞IO做了大量优化工作.</p>
<p>memcached内存分配：<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/memcached/20120314163538_438.png" alt=""><br>memcached默认情况下采用了名为Slab Allocator的机制分配、管理内存.</p>
<p>如果我们在启动memcached时没有指定<code>-m</code>参数的话, 那么memcached能使用的最大内存为默认的64M,但是memcached启动的时候并不会一次性就都分配出来,而是当发现memcached已被分配的内存不够用的时候才会进行申请. memcached申请内存时一次会申请一个Slab(默认为1M). 然后会将这一个Slab分成不同的Class, 每个Class内部都有N个大小相等的Chunk.每个chunk中都保存了一个item结构体、一对key value键值对.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Memcached依赖libevent,所以我们首先需要安装libevent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://jaist.dl.sourceforge.net/project/levent/libevent/libevent-2.0/libevent-2.0.22-stable.tar.gz</span><br><span class="line">tar -zxvf libevent-2.0.22-stable.tar.gz</span><br><span class="line">cd libevent-2.0.22-stable</span><br><span class="line">./configure --prefix=/usr &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>接下来安装Memcached<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://memcached.org/latest</span><br><span class="line">tar -zxvf memcached-1.x.x.tar.gz</span><br><span class="line">cd memcached-1.x.x</span><br><span class="line">./configure --with-libevent=/usr &amp;&amp; make &amp;&amp; make test &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<h2 id="memcached命令选项"><a href="#memcached命令选项" class="headerlink" title="memcached命令选项"></a><code>memcached</code>命令选项</h2><p>网络相关</p>
<ul>
<li><code>-s &lt;file&gt;</code> : Unix socket path to listen on (disables network support).</li>
<li><code>-a &lt;perms&gt;</code> : 当通过s选项创建socket的时候,我们可以通过-a选项指定创建socket使用的权限(权限为八进制).</li>
<li><code>-l &lt;ip_addr&gt;</code> : 监听的主机地址. 默认是本机任何可用的地址.</li>
<li><code>-d</code> : 以后台进程方式运行memcached</li>
<li><code>-u &lt;username&gt;</code> : memcached不能以root用户运行，如果当前用户为root, 我们需要通过该参数指定用户为root</li>
<li><code>-c &lt;num&gt;</code> : 设置最大同时连接数.(默认是1024).</li>
<li><code>-C</code> : 关闭CAS. (每个对象都会减少8bytes大小).</li>
<li><code>-p &lt;num&gt;</code> : 设置监听TCP端口号, 默认是11211.</li>
<li><code>-P</code> : 设置pid存储文件.</li>
<li><code>-U &lt;num&gt;</code> : 设置监听UDP端口号, 默认是11211, 0 表示关闭UDP监听.</li>
<li><code>-r</code> : 将最大的核心文件大小限制提升到允许的最大值.</li>
<li><code>-v</code> : 设置为verbose 同时会输出发生的errors 和warnings.</li>
<li><code>-i</code> : 打印memcached 和libevent 授权.</li>
<li><code>-R &lt;num&gt;</code> : 这个选项是设置服务器可以处理一个独立客户端连接顺序请求的数量,以防止产生其他客户端饥饿的情况. 一旦设置了这个值当服务器处理一个连接超过20个(默认值)请求之后,就会尝试处理其他的连接请求.</li>
</ul>
<p>内存相关</p>
<ul>
<li><code>-m &lt;num&gt;</code> : 设置对象存储能使用的最大内存(单位是MB,默认是64M)</li>
<li><code>-M</code> : 关闭对象存储所需内存超过最大内存时,自动删除缓存对象的功能. 如果memcached的配置内存达到最大值就不可再存储新的对象.</li>
<li><code>-f &lt;factor&gt;</code> : Class的成长因子(默认是1.25). 也就是说如果Class1是100B,那么Class2就是125B.</li>
<li><code>-n &lt;size&gt;</code> : key, value, and flags分配到的最小字节数(默认是48字节). 如果你的键值对的值都很小,你可以调低这个值来达到更高的性能. 如果你的成长因子比较大,那么你可以调高这个值,提升命中率.</li>
<li><code>-t &lt;threads&gt;</code> : 处理请求的线程数(默认是4). 这个选项只有memcached被编译的时候指定了线程开启才有用.</li>
<li><code>-k</code> : 锁定所有的分页内存. 在巨大的缓存系统中,使用这个选项是非常危险的,使用的使用要参考README文件和memcached homepage进行配置.</li>
<li><code>-L</code> : 尝试使用尽可能使用到的内存叶. 增加内存叶大小可以减少TLB未命中和提供性能. 为了可以从OS获得更大的内存页,memcached会在一个巨大的chunk上分配所有的item</li>
<li><code>-I &lt;size&gt;</code> : 指定slab page大小(默认是1mb,最小是1k, 最大是128m). 改变这个值会增加每个item大小的值.  使用-vv来查看更改后的值</li>
<li><code>-F</code> : 关闭<code>flush_all</code>命令.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached  -d -p 10021 -l 10.234.10.12 -u root -c 1024  -P ./memcached1.pid</span><br></pre></td></tr></table></figure>
<h2 id="java使用"><a href="#java使用" class="headerlink" title="java使用"></a>java使用</h2><p>我们使用spymemcached作为java客户端连接memcached. 在Maven项目中添加以下依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spymemcached<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后连接memcached<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemcachedClient client = <span class="keyword">new</span> MemcachedClient(<span class="keyword">new</span> InetSocketAddress(<span class="string">"10.234.10.12"</span>, <span class="number">10021</span>));</span><br></pre></td></tr></table></figure></p>
<p>通过这一行我们就成功的连接上了memcached.然后我们就可以使用spymemcached提供的大量api来操作memcached</p>
<h2 id="memcached信息统计"><a href="#memcached信息统计" class="headerlink" title="memcached信息统计"></a>memcached信息统计</h2><p>我们可以使用telnet命令直接连接memcached<code>telnet 127.0.0.1 10021</code>,然后输入下列命令查看相关信息</p>
<h3 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h3><p>统计memcached的各种信息</p>
<ul>
<li><code>STAT pid 20401</code> memcache服务器的进程ID</li>
<li><code>STAT uptime 47</code>  服务器已经运行的秒数</li>
<li><code>STAT time 1447835371</code> 服务器当前的unix时间戳</li>
<li><code>STAT version 1.4.24</code>  memcache版本</li>
<li><code>STAT libevent 2.0.22-stable</code> libevent版本</li>
<li><code>STAT pointer_size 64</code> 当前操作系统的指针大小（32位系统一般是32bit）</li>
<li><code>STAT rusage_user 0.002999</code> 进程的累计用户时间</li>
<li><code>STAT rusage_system 0.001999</code> 进程的累计系统时间</li>
<li><code>STAT curr_connections 10</code> 当前打开着的连接数</li>
<li><code>STAT total_connections 11</code> 从服务器启动以后曾经打开过的连接数</li>
<li><code>STAT connection_structures 11</code> 服务器分配的连接构造数</li>
<li><code>STAT reserved_fds 20</code></li>
<li><code>STAT cmd_get 0</code>  get命令（获取）总请求次数</li>
<li><code>STAT cmd_set 0</code>  set命令（保存）总请求次数</li>
<li><code>STAT cmd_flush 0</code></li>
<li><code>STAT cmd_touch 0</code></li>
<li><code>STAT get_hits 0</code>  总命中次数</li>
<li><code>STAT get_misses 0</code> 总未命中次数</li>
<li><code>STAT delete_misses 0</code> delete命令未命中次数</li>
<li><code>STAT delete_hits 0</code>  delete命令命中次数</li>
<li><code>STAT incr_misses 0</code>  incr命令未命中次数</li>
<li><code>STAT incr_hits 0</code>  incr命令命中次数</li>
<li><code>STAT decr_misses 0</code>  decr命令未命中次数</li>
<li><code>STAT decr_hits 0</code>  decr命令命中次数</li>
<li><code>STAT cas_misses 0</code>  cas命令未命中次数</li>
<li><code>STAT cas_hits 0</code>  cas命令命中次数</li>
<li><code>STAT cas_badval 0</code></li>
<li><code>STAT touch_hits 0</code>  touch命令命中次数</li>
<li><code>STAT touch_misses 0</code>  touch命令未命中次数</li>
<li><code>STAT auth_cmds 0</code></li>
<li><code>STAT auth_errors 0</code></li>
<li><code>STAT bytes_read 7</code> 总读取字节数（请求字节数）</li>
<li><code>STAT bytes_written 0</code> 总发送字节数（结果字节数）</li>
<li><code>STAT limit_maxbytes 67108864</code>   分配给memcache的内存大小（字节）</li>
<li><code>STAT accepting_conns 1</code></li>
<li><code>STAT listen_disabled_num 0</code></li>
<li><code>STAT threads 4</code>     当前线程数</li>
<li><code>STAT conn_yields 0</code></li>
<li><code>STAT hash_power_level 16</code>  hash等级</li>
<li><code>STAT hash_bytes 524288</code>  hash字节数</li>
<li><code>STAT hash_is_expanding 0</code>    </li>
<li><code>STAT malloc_fails 0</code>  分配失败次数</li>
<li><code>STAT bytes 0</code>   当前服务器存储items占用的字节数</li>
<li><code>STAT curr_items 0</code> 服务器当前存储的items数量</li>
<li><code>STAT total_items 0</code> 从服务器启动以后存储的items总数量</li>
<li><code>STAT expired_unfetched 0</code></li>
<li><code>STAT evicted_unfetched 0</code></li>
<li><code>STAT evictions 0</code> 为获取空闲内存而删除的items数（分配给memcache的空间用满后需</li>
<li><code>STAT reclaimed 0</code></li>
<li><code>STAT crawler_reclaimed 0</code></li>
<li><code>STAT crawler_items_checked 0</code></li>
<li><code>STAT lrutail_reflocked 0</code></li>
</ul>
<p>我们也可以使用java获取这些信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MemcachedClient client = <span class="keyword">new</span> MemcachedClient(<span class="keyword">new</span> InetSocketAddress(<span class="string">"10.234.10.12"</span>, <span class="number">10021</span>));</span><br><span class="line">client.getStats().entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">"Node : "</span> + entry.getKey());</span><br><span class="line">	entry.getValue().entrySet().stream().forEach(value -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"    "</span> + value.getKey() + <span class="string">" : "</span> + value.getValue());</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="stats-reset"><a href="#stats-reset" class="headerlink" title="stats reset"></a>stats reset</h3><p>重新统计数据</p>
<h3 id="stats-slabs"><a href="#stats-slabs" class="headerlink" title="stats slabs"></a>stats slabs</h3><p>显示slabs信息，可以详细看到数据的分段存储情况</p>
<ul>
<li><code>STAT active_slabs 0</code></li>
<li><code>STAT total_malloced 0</code></li>
</ul>
<h3 id="stats-items"><a href="#stats-items" class="headerlink" title="stats items"></a>stats items</h3><p>显示slab中的item数目</p>
<h3 id="stats-cachedump-1-0"><a href="#stats-cachedump-1-0" class="headerlink" title="stats cachedump 1 0"></a>stats cachedump 1 0</h3><p>列出slabs第一段里存的KEY值</p>
<h3 id="STAT-evictions-0"><a href="#STAT-evictions-0" class="headerlink" title="STAT evictions 0"></a>STAT evictions 0</h3><p>表示要腾出新空间给新的item而移动的合法item数目</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/memcached/">memcached</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/memcached/Memcache/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/memcached/Memcache/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/日志工具/Elasticsearch 搜索/" title="Elasticsearch 搜索" itemprop="url">Elasticsearch 搜索</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先我们向库里准备一下数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JSONObject son = <span class="keyword">new</span> JSONObject();</span><br><span class="line">son.put(<span class="string">"name"</span>, <span class="string">"Jerry"</span>);</span><br><span class="line">son.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">son.put(<span class="string">"address"</span>, <span class="string">"baoding"</span>);</span><br><span class="line">son.put(<span class="string">"country"</span>, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"48"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"address"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"country"</span>, <span class="string">"china"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"son"</span>, son);</span><br><span class="line"></span><br><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx04"</span>)</span><br><span class="line">		.type(<span class="string">"type02"</span>)</span><br><span class="line">		.id(<span class="string">"02"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">client.index(indexRequest).get();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Leaf query clauses : 在指定的字段中搜索指定的值,例如使用<code>match</code>, <code>term</code> 或者 <code>range</code> 搜索时</li>
<li>Compound query clauses :</li>
</ul>
<p>首先我们来看一个简单的搜索案例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"idx01"</span>, <span class="string">"idx02"</span>)</span><br><span class="line">				.setTypes(<span class="string">"type01"</span>, <span class="string">"type02"</span>)</span><br><span class="line">				.setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</span><br><span class="line">				.setQuery(QueryBuilders.termQuery(<span class="string">"multi"</span>, <span class="string">"test"</span>))                 <span class="comment">// Query</span></span><br><span class="line">				.setPostFilter(QueryBuilders.rangeQuery(<span class="string">"age"</span>).from(<span class="number">12</span>).to(<span class="number">18</span>))     <span class="comment">// Filter</span></span><br><span class="line">				.setFrom(<span class="number">0</span>).setSize(<span class="number">60</span>).setExplain(<span class="keyword">true</span>)</span><br><span class="line">				.execute()</span><br><span class="line">				.actionGet();</span><br></pre></td></tr></table></figure></p>
<h3 id="Match-All-Query"><a href="#Match-All-Query" class="headerlink" title="Match All Query"></a>Match All Query</h3><p>最简单的搜索, 这个搜索将库中所有的文档都搜索出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = matchAllQuery();</span><br></pre></td></tr></table></figure></p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="Match-Query"><a href="#Match-Query" class="headerlink" title="Match Query"></a>Match Query</h4><p>标准搜索, 包含模糊搜索, 短语搜索, 相近搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = matchQuery(</span><br><span class="line">				<span class="string">"age"</span>,	<span class="comment">// 搜索的字段</span></span><br><span class="line">				<span class="string">"18"</span>	<span class="comment">// 搜索的字段值</span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		SearchResponse searchResponse = client.prepareSearch(<span class="string">"idx04"</span>).setQuery(qb).execute().get();</span><br><span class="line">		searchResponse.getHits().forEach(hit -&gt; &#123;</span><br><span class="line">			System.out.println(hit.getSourceAsString());</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></p>
<p>结果为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"address"</span>:<span class="string">"beijing"</span>,<span class="attr">"age"</span>:<span class="string">"18"</span>,<span class="attr">"country"</span>:<span class="string">"china"</span>,<span class="attr">"name"</span>:<span class="string">"Tom"</span>,<span class="attr">"son"</span>:&#123;<span class="attr">"address"</span>:<span class="string">"baoding"</span>,<span class="attr">"age"</span>:<span class="string">"18"</span>,<span class="attr">"country"</span>:<span class="string">"china"</span>,<span class="attr">"name"</span>:<span class="string">"Jerry"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Multi-Match-Query"><a href="#Multi-Match-Query" class="headerlink" title="Multi Match Query"></a>Multi Match Query</h4><p><code>match</code>搜索的多键版本, 会在多个指定字段中进行值匹配查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = multiMatchQuery(</span><br><span class="line">		<span class="string">"baoding"</span>,	<span class="comment">// 搜索值</span></span><br><span class="line">		<span class="string">"city"</span>, <span class="string">"country"</span>	<span class="comment">// 搜索的字段</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SearchResponse searchResponse = client.prepareSearch(<span class="string">"idx04"</span>).setQuery(qb).execute().get();</span><br><span class="line">searchResponse.getHits().forEach(hit -&gt; &#123;</span><br><span class="line">	System.out.println(hit.getSourceAsString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Common-Terms-Query"><a href="#Common-Terms-Query" class="headerlink" title="Common Terms Query"></a>Common Terms Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = commonTermsQuery(<span class="string">"name"</span>, <span class="string">"kimchy"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Query-String-Query"><a href="#Query-String-Query" class="headerlink" title="Query String Query"></a>Query String Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = queryStringQuery(<span class="string">"+kimchy -elasticsearch"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Simple-Query-String-Query"><a href="#Simple-Query-String-Query" class="headerlink" title="Simple Query String Query"></a>Simple Query String Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = simpleQueryStringQuery(<span class="string">"+kimchy -elasticsearch"</span>);</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日志工具/">日志工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/日志工具/Elasticsearch 搜索/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/日志工具/Elasticsearch 搜索/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/16/redis/Redis_SortedSet/" title="Redis SortedSet" itemprop="url">Redis SortedSet</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-15T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>在命令行中使用Redis客户端连接Redis服务器： <code>redis-cli -h 127.0.0.1 -p 7000</code></p>
</blockquote>
<h2 id="增加成员"><a href="#增加成员" class="headerlink" title="增加成员"></a>增加成员</h2><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><p>语法：<code>ZADD key score member [[score member] [score member] ...]</code>.   </p>
<ul>
<li><code>ZADD</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>score</code>  值 (可以是整数值或双精度浮点数)</li>
<li><code>member</code> 键</li>
</ul>
<p>这个命令也就是将键值对(member score)插入到有序集合key中. 如果集合不存在就创建一个集合,如果键已经存在就代替原来的值.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZADD test1 10 a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h2 id="修改成员"><a href="#修改成员" class="headerlink" title="修改成员"></a>修改成员</h2><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><p>语法<code>ZINCRBY key increment member</code></p>
<ul>
<li><code>ZINCRBY</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>increment</code>  score值的增量</li>
<li><code>member</code>  针对哪个成员进行改变</li>
</ul>
<p>这个命令就是对某个成员进行增加或者减少(通过负数实现). (member 成员的新 score 值,以字符串形式表示)</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd test1 23 t</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:7006&gt; ZINCRBY test1 10 t</span><br><span class="line">&quot;33&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; zincrby test1 -20 t</span><br><span class="line">&quot;13&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h2><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><p>语法<code>ZREM key member [member ...]</code></p>
<ul>
<li><code>ZREM</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code> 成员名</li>
</ul>
<p>移除有序集 key 中的一个或多个成员,不存在的成员将被忽略.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zcard test1</span><br><span class="line">(integer) 7</span><br><span class="line">redis 127.0.0.1:7006&gt; zrem test1 a</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:7006&gt; zcard test1</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h3><p>语法<code>ZREMRANGEBYRANK key start stop</code></p>
<ul>
<li><code>ZREMRANGEBYRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>移除有序集 key 中,指定排名(rank)区间内的所有成员.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREMRANGEBYRANK test1 1 2 # 将第二名和第三名移除</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h3><p>语法<code>ZREMRANGEBYSCORE key min max</code></p>
<ul>
<li><code>ZREMRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>将集合key里的score值区间为[min,max]的成员删除</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREMRANGEBYSCORE test1 10 20</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h3><p>语法<code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p>
<ul>
<li><code>ZUNIONSTORE</code> redis命令</li>
<li><code>destination</code> 有序集合名</li>
<li><code>numkeys</code>  需要合并的集合数量</li>
<li><code>key</code>  需要合并的集合</li>
<li><code>WEIGHTS</code>  指定该值,则在合并的时候,对每个score值都乘以该元素</li>
<li><code>AGGREGATE</code> 指定并集的结果集的聚合方式</li>
</ul>
<p>对多个集合采取并集</p>
<blockquote>
<p>AGGREGATE有三种值：A. SUM,将相同的成员的score相加. MIN,取相同成员的最小score值. MAX,取相同成员的最大score值</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd a 10 a1 20 a2 30 a3 40 a4 50 a5</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:7006&gt; zadd b 11 b1 12 b2 13 b3 14 b4 15 b5</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:7006&gt; ZUNIONSTORE c 2 a b</span><br><span class="line">(integer) 10</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGE c 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;a1&quot;</span><br><span class="line"> 2) &quot;10&quot;</span><br><span class="line"> 3) &quot;b1&quot;</span><br><span class="line"> 4) &quot;11&quot;</span><br><span class="line"> 5) &quot;b2&quot;</span><br><span class="line"> 6) &quot;12&quot;</span><br><span class="line"> 7) &quot;b3&quot;</span><br><span class="line"> 8) &quot;13&quot;</span><br><span class="line"> 9) &quot;b4&quot;</span><br><span class="line">10) &quot;14&quot;</span><br><span class="line">11) &quot;b5&quot;</span><br><span class="line">12) &quot;15&quot;</span><br><span class="line">13) &quot;a2&quot;</span><br><span class="line">14) &quot;20&quot;</span><br><span class="line">15) &quot;a3&quot;</span><br><span class="line">16) &quot;30&quot;</span><br><span class="line">17) &quot;a4&quot;</span><br><span class="line">18) &quot;40&quot;</span><br><span class="line">19) &quot;a5&quot;</span><br><span class="line">20) &quot;50&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZUNIONSTORE e 2 c a</span><br><span class="line">(integer) 10</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGE e  0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;b1&quot;</span><br><span class="line"> 2) &quot;11&quot;</span><br><span class="line"> 3) &quot;b2&quot;</span><br><span class="line"> 4) &quot;12&quot;</span><br><span class="line"> 5) &quot;b3&quot;</span><br><span class="line"> 6) &quot;13&quot;</span><br><span class="line"> 7) &quot;b4&quot;</span><br><span class="line"> 8) &quot;14&quot;</span><br><span class="line"> 9) &quot;b5&quot;</span><br><span class="line">10) &quot;15&quot;</span><br><span class="line">11) &quot;a1&quot;</span><br><span class="line">12) &quot;20&quot;</span><br><span class="line">13) &quot;a2&quot;</span><br><span class="line">14) &quot;40&quot;</span><br><span class="line">15) &quot;a3&quot;</span><br><span class="line">16) &quot;60&quot;</span><br><span class="line">17) &quot;a4&quot;</span><br><span class="line">18) &quot;80&quot;</span><br><span class="line">19) &quot;a5&quot;</span><br><span class="line">20) &quot;100&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h3><p>语法<code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p>
<ul>
<li><code>ZINTERSTORE</code> redis命令</li>
<li><code>destination</code> 有序集合名</li>
<li><code>numkeys</code>  需要合并的集合数量</li>
<li><code>key</code>  需要合并的集合</li>
<li><code>WEIGHTS</code>  指定该值,则在合并的时候,对每个score值都乘以该元素</li>
<li><code>AGGREGATE</code> 指定并集的结果集的聚合方式</li>
</ul>
<p>对多个集合采取交集</p>
<blockquote>
<p>AGGREGATE有三种值：A. SUM,将相同的成员的score相加. MIN,取相同成员的最小score值. MAX,取相同成员的最大score值</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd h 1 a1 2 a2</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:7006&gt; ZINTERSTORE j 2 e h</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:7006&gt; zrange j 0 -1 WITHSCORES</span><br><span class="line">1) &quot;a1&quot;</span><br><span class="line">2) &quot;21&quot;</span><br><span class="line">3) &quot;a2&quot;</span><br><span class="line">4) &quot;42&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取集合数量"><a href="#获取集合数量" class="headerlink" title="获取集合数量"></a>获取集合数量</h2><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><p>语法<code>ZCARD key</code></p>
<ul>
<li><code>ZCARD</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
</ul>
<p>获得集合大小</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZCARD test1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><p>语法<code>ZCOUNT key min max</code></p>
<ul>
<li><code>ZCOUNT</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)<br>这个命令就是统计score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
</li>
</ul>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZCOUNT test 10 50</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p>
<h2 id="获取集合列表"><a href="#获取集合列表" class="headerlink" title="获取集合列表"></a>获取集合列表</h2><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><p>语法<code>ZRANGE key start stop [WITHSCORES]</code></p>
<ul>
<li><code>ZRANGE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code>  同时也返回成员对应的值</li>
</ul>
<p>返回有序集key中指定区间内的成员,得到的成员是递增(从小到大)排序的.</p>
<blockquote>
<p>索引从0开始, 如果索引为负数则代表从倒序,即-1代表最后一个,-2代表倒数第二个. ( <code>ZRANGE test1 0 -1 WITHSCORES</code>显示整个有序集成员)</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zrange test1 0 3</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;t&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; zrange test1 0 3 WITHSCORES</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;t&quot;</span><br><span class="line">6) &quot;13&quot;</span><br><span class="line">7) &quot;b&quot;</span><br><span class="line">8) &quot;20&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h3><p>语法<code>ZREVRANGE key start stop [WITHSCORES]</code></p>
<ul>
<li><code>ZREVRANGE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
</ul>
<p>和<code>ZRANGE</code>命令不同的是它是从按 score 值递减(从大到小)来排列,其他和ZRANGE命令一样</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANGE test1 1 100</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;f&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><p>语法<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>
<ul>
<li><code>ZRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
<li><code>LIMIT offset count</code></li>
</ul>
<p>返回有序集key中,score值介于 [min, max]之间(闭区间)的成员,按 score 值递增(从小到大)次序排列</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 10 56 WITHSCORES	# 闭区间</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;10&quot;</span><br><span class="line"> 3) &quot;c&quot;</span><br><span class="line"> 4) &quot;12&quot;</span><br><span class="line"> 5) &quot;t&quot;</span><br><span class="line"> 6) &quot;13&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;20&quot;</span><br><span class="line"> 9) &quot;f&quot;</span><br><span class="line">10) &quot;42&quot;</span><br><span class="line">11) &quot;d&quot;</span><br><span class="line">12) &quot;56&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 (10 (56 WITHSCORES # 开区间</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;12&quot;</span><br><span class="line">3) &quot;t&quot;</span><br><span class="line">4) &quot;13&quot;</span><br><span class="line">5) &quot;b&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;f&quot;</span><br><span class="line">8) &quot;42&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 10 56 WITHSCORES LIMIT 0 3 # 从第一个成员开始选择三个成员</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;t&quot;</span><br><span class="line">6) &quot;13&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><p>语法<code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p>
<ul>
<li><code>ZREVRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
<li><code>LIMIT offset count</code>  </li>
</ul>
<p>除了成员按 score 值递减的次序排列这一点外, ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样.</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANGE test1 1 100 WITHSCORES</span><br><span class="line"> 1) &quot;f&quot;</span><br><span class="line"> 2) &quot;42&quot;</span><br><span class="line"> 3) &quot;d&quot;</span><br><span class="line"> 4) &quot;40&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;20&quot;</span><br><span class="line"> 9) &quot;a&quot;</span><br><span class="line">10) &quot;10&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h3><p>语法<code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>
<ul>
<li><code>ZRANGEBYLEX</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>根据成员进行排序而不是根据score值排序,然后返回[min, max]区间内的成员</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYLEX test1 10 30</span><br></pre></td></tr></table></figure></p>
<h2 id="查询某个成员"><a href="#查询某个成员" class="headerlink" title="查询某个成员"></a>查询某个成员</h2><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><p>语法<code>ZRANK key member</code></p>
<ul>
<li><code>ZRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code>  成员值</li>
</ul>
<p>返回有序集 key 中成员 member 的排名.其中有序集成员按 score 值递增(从小到大)顺序排列.（排名从0开始）</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANK test1 d</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h3><p>语法<code>ZREVRANK key member</code></p>
<ul>
<li><code>ZREVRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code>  成员值<br>除了成员按 score 值递减的次序排列这一点外, ZREVRANK 命令的其他方面和 ZRANK 命令一样.</li>
</ul>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANK test1 c</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><p>语法<code>ZSCORE key member</code></p>
<ul>
<li><code>ZSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code> 成员</li>
</ul>
<p>返回有序集 key 中,成员 member 的 score 值.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZSCORE test1 a</span><br><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Reids/">Reids</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/16/redis/Redis_SortedSet/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/16/redis/Redis_SortedSet/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/08/网络/会话层/" title="会话层" itemprop="url">会话层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这一层负责连接如何建立,如何断开,以及保持多长时间.但是该层并不具有实际的传输数据的功能.</p>
<p>它会在表示层前边添加会话层首部.</p>
<p>例如,主机A向主机B发送5条消息,那么会话层就决定着是每个消息都进行一次连接建立断开,还是五条消息在同一个连接中建立断开.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCP-IP/">TCP IP</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/08/网络/会话层/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/08/网络/会话层/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/08/网络/网络层/" title="网络层" itemprop="url">网络层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>网络层通过地址将数据从众多链路中传送到最终地址上.它实现的是终端节点之间的通信. 相比于数据链路层的只能在同一种数据链路中进行数据传输,网络层可以跨数据链路进行数据传输(这一点是通过下面介绍的路由器实现的).说的更加通俗一点是:数据链路层只是负责俩个设备之间的通信,但是如果想要跨多个设备通信的话,就只能借助网络层了.</p>
<blockquote>
<p>至于为什么需要网络层呢?是这样的,数据链路只能在同一种介质中进行通信,如果无线想要和以太网进行数据传输的话,单靠数据链路层是没办法完成这个需求的,此时就需要借助网络层的路由器了.</p>
</blockquote>
<p>网络层相关协议:</p>
<ul>
<li>ARP</li>
<li>IP</li>
<li>ICMP</li>
</ul>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP的作用分作三部分:</p>
<ul>
<li>IP寻址</li>
<li>路由</li>
<li>IP分包,组包<br>我们知道MAC地址是用来在同一链路中识别不同计算机的,那么IP地址就是在连接到网络中的所有主机相互识别用的. 因此在连接到网络的所有的主机和路由器必须都设置上自己的IP地址.我们必须时刻记住IP地址只在网络层有效,网络层只是将主机的IP地址放到了数据包的IP首部位置,IP包在网桥或者中继器或者数据链路层是不会被使用到的,在硬件部分只是将IP包转化成一个个的0,1的数据流,在链路层只是对数据连绝真的数据部分进行转发.</li>
</ul>
<p>由于不同的数据链路的MTU值(Maximum Transmission Unit,最大传输单位)是不一样的,比如以太网的MTU为1500bytes,而FDDI则是4352Bytes,ATM则为9180bytes.IP包的长度有可能大于或者小于这些长度,于是就出现了IP包的分片处理. 网络层会将IP包分成一个个相等的较小的包,由链路层发送出去,到了终端网络层再组装起来.</p>
<p>当IP包生成之后,会根据接收端IP从路由表里边查找接受该数据包的路由或者主机. 然后IP包会被发送给连接路由器或者NIC的驱动程序,实现真正的数据传输.</p>
<p>网络层接受到传输层发送过来的数据(如:TCP首部+应用层数据),如果由UP模块处理,IP模块就会在数据首部再添加IP首部:</p>
<ul>
<li>接收端IP</li>
<li>发送端IP</li>
<li>判断传输层数据是TCP还是UDP数据的信息</li>
</ul>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IPV4地址由32位正整数(0/1)表示,每8位一组,分成4组,每一组用<code>.</code>分隔.每一组的最大值是2的8次方也就是255,最小值是0. </p>
<p>理论上2的32次方,大概是43亿,那么每个NIC都配置一个IP的话(NIC最少可以配置一个IP)那么就会有43亿的计算机可以连接到网络上(但实际上,能连接到网络上的计算机远远达不到这个数量).</p>
<p>实际上IP地址是由网络和主机俩部分标志组成的.</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器在网络层上连接网络,并对分组报文进行转发. 路由器使用IP地址进行进行处理. 路由器可以连接不同的数据链路,例如连接以太网和一个FDDI.</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>当我们在写网络程序的时候,无论是HTTP协议还是TCP协议,我们只需要知道对方的IP地址就可以向其发送消息,但是在数据链路层在实际通信时,必须知道对方的MAC地址.</p>
<p>我们就是通过ARP协议来通过IP地址找到对方的MAC地址的. 当主机A要向主机B发送一个消息时,主机A会尝试从自己的ARP表中查找目标IP的MAC地址. 如果找到了目标MAC地址,就直接向该MAC地址发送消息. 如果找不到MAC地址,主机A就向链路中发送ARP请求,链路中的所有主机和路由器都会对其进行解析. 当主机B与主机A在同一链路中,此时主机B会发送主机A发出的ARP请求与自己的IP地址一致,主机B就会回应一个ARP响应,响应中包含着主机B的MAC地址. 主机A接收到主机B的ARP响应后,会将主机B的MAC地址和IP地址的对应关系,缓存到自己的ARP表中.</p>
<blockquote>
<p>ARP是为了提高性能而设计的. 如果每次IP通信都需要进行一次ARP请求,会造成非常大的网络流量</p>
</blockquote>
<p>上面我们只是阐述了,在同一链路中找到了目标主机,但是如果找不到呢?</p>
<blockquote>
<p>其实还有一种RARP协议,这个协议是将MAC地址定位IP地址的协议,与ARP协议恰恰相反. 平常我们在电脑里设置IP地址时,可以通过设置为自动获取IP地址(通过DHCP实现),但是使用嵌入式设备,我们可能就没有办法通过DHCP来获取IP地址了,那么,我们就需要架设一台RARP服务器,从而在这个设备上注册设备的MAC地址及其IP地址.</p>
</blockquote>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>网络地址转换(NAT,Network Address Translation)是用于在本地网络中使用私有地址,在连接互联网时转而使用全局IP地址的技术.NAT技术的踢出是为了解决IPV4地址日益枯竭的问题,即可以使用网关来完成NAT也可以使用NAT路由器来完成.</p>
<p>首先我们来说说NAT路由器,NAT路由器内部有一张自动生成的用来转换地址的表. 例如在TCP情况下,建立TCP连接首次握手时的SYN包一旦发出,就会在路由器内部生成这个表. 随后收到关闭连接发出FIN包的确认应答时又从表中将其删除.</p>
<blockquote>
<p>说到这里,我们要谈一下,IPV4和IPV6之间通信的问题. IPV6的主机是没办法直接与IPV4的主机进行通信的,我們首先要使用NAT-PT技術將IPV6首部替換為IPV4首部,這樣他們二者才能進行通信. NAT-PT技術有很多實現方式,例如結合DNS和IP首部替換的DNS-ALG技術.</p>
</blockquote>
<p>NAT有俩种实现方式：</p>
<ul>
<li>NAT: 将内网的IP地址替换为网关的IP地址，但是将内网的端口与网关端口进行绑定,也就是公网见到的端口是内网的端口,但是见到的IP是网关的地址.</li>
<li>NAPT：    使用网关的IP，但端口会选择一个和临时会话对应的临时端口. 这种公网见到的IP地址和端口都是网关设定的.</li>
</ul>
<p>由于内网可能会跟公网建立俩个连接都采用不同的端口,因此NAPT针对这种情况又分为了俩种类型(需要说明的是不管是那种类型只要建立一个连接就会在网关中建立一个session)</p>
<ul>
<li>Symmetric NAT型 (对称型): 来自同一个内网的ip俩个seesion会在网关上分配到俩个不同的端口.</li>
<li>Cone NAT型（圆锥型）:来自同一个内网的ip俩个seesion会在网关上分配同一个端口</li>
</ul>
<p>Cone NAT又分了3种类型：</p>
<ul>
<li>Full Cone NAT（完全圆锥型）：这种NAT，网关会根据session信息将公网发送过来的数据报都都发送到某个内网主机上.</li>
<li>Address Restricted Cone NAT （地址限制圆锥型）：这种NAT上的内网不会主动接受陌生公网主机的数据报,只有内网向公网主机发送过请求,才会接受那个公网的数据报.</li>
<li>Port Restricted Cone NAT（端口限制圆锥型）：和第二种NAT类似同样是不会主动接受陌生公网主机的数据报,但是这种NAT更加严苛的是还有端口限制,也就是说它只会接受向某个公网端口发送给请求的数据报.</li>
</ul>
<p>Linux的NAT是对称NAT，而不是锥形NAT. 且完全依赖ip_conntrack.</p>
<p>NAT還有很多潛在的問題:</p>
<ol>
<li>無法從NAT的外部向NAT內部直接建立連接.</li>
<li>轉換表的生成和轉換操作都有一定的开销.</li>
<li>通信过程中一旦NAT遇到异常需要重新启动时,所有的TCP连接都将被重置</li>
<li>即使准备俩台NAT做容灾备份,TCP连接还是会被断开.</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>我们知道网络其实就是由一个个路由组成的. IP包就是在这一个个的路由间传输,每当路过一个路由的时候我们就说IP数据包经过了一跳. 每当IP包完成一跳时,当前路由器就会指定下一个路由器或者主机.</p>
<blockquote>
<p>一跳(Hop)的范围就是从一个主机或者一个路由器的网卡到另一个主机或者路由器网卡之间的区间.</p>
</blockquote>
<p>每个主机中都有一个路由控制表,这个表记录着IP数据包在下一步发给哪个路由器.IP包根据这个路由器在各个链路上进行传输.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCP-IP/">TCP IP</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/08/网络/网络层/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/08/网络/网络层/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/08/网络/数据链路层/" title="数据链路层" itemprop="url">数据链路层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>物理层负责将实际设备过程中的电压的高低,光的闪灭,电波的强弱新号等与二进制0,1进行转换. 而数据链路层则负责将0,1数据集合成帧块后进行传输.</p>
<ul>
<li>数据链路段： 数据链路段是指一个被分割的网络.</li>
</ul>
<p>网络拓扑： 网络的连接与构成的形态被称为网络拓扑，有以下分类</p>
<ul>
<li><a href="">总线型</a></li>
<li><a href="">环形</a></li>
<li><a href="">星形</a></li>
<li><a href="">混合型</a></li>
</ul>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址用于识别数据链路中的互联的节点. 不论哪种数据链路的网络(以太网,FDDI,ATM,无线LAN),他们彼此的MAC地址都是唯一的.MAC地址总长46位,一般用16进制表示.</p>
<ul>
<li>第一位:单播地址(0)/多播地址(1)</li>
<li>第2位: 全局地址(0)/本地地址(1)</li>
<li>第3-24位:由IEEE管理并保证各厂家不重复</li>
<li>第25-48位:由厂商管理并保证产品之间不重复</li>
</ul>
<h3 id="通信介质"><a href="#通信介质" class="headerlink" title="通信介质"></a>通信介质</h3><p>从通信介质的使用方法来看,网络可以分为共享型介质和非共享型介质:</p>
<p>共享介质型网络：是指多个设备共享一个通信介质的网络.在这种方式下多个设备使用同一个载波信道进行发送和接受,基本上采用半双工通信.</p>
<ul>
<li>半双工: 在数据链路上同时只发送或者只接受的通信方式</li>
<li>全双工: 在数据链路上同时即可以发送也可以接受数据的通信方式</li>
</ul>
<p>共享介质型网络有俩种访问控制方式:</p>
<ul>
<li>争用方式:</li>
<li>令牌传递方式:</li>
</ul>
<p>非共享介质:</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>目前网络通信方式大致分为俩种：</p>
<ul>
<li>电路交换：这种交换技术主要应用于过去的电话网. 在这种交换中,交换机主要负责数据的中转处理. 计算机之间的连接是通过交换机连接上的,当俩个计算机通信之后,他们俩者就一直占用着这条线路</li>
<li>分组交换：由于电路交换, 俩台计算机会一直占用某条线路,当有新的计算机连接到这条线路上想要通信时,就只能等当前通信的计算机断开连接,于是噩梦就这样产生了.</li>
</ul>
<p>在这种情况下,人们提出了分组交换. 即将数据进行分组成多个数据包,每个分组首部已经写入了发送端和接收端地址,然后当分组交换机(路由器)接收到分组数据之后,会将其缓存到自己的缓冲区中,然后再按照先进先出的规则将数据转发出去. 这样在同一条线路上也可以为多个计算机服务.</p>
<p><img src="https://raw.githubusercontent.com/ming15/blog-website/images/net/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.jpg" alt="分组交换"></p>
<h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>网桥交换机在数据链路层上连接俩个网络设备. 它使用物理地址(MAC地址)进行处理.</p>
<p>网桥能够识别数据链路中的数据帧,并将其缓存起来重新生成新的数据帧发送给另一个网段. 得益于网桥的缓存功能,使得网桥能够连接传输速率完全不同的数据链路,并且不限制连接网段的个数.</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>由电缆传过来的电信号或者光信号经由中继器的波形调整和放大再传给另一个电缆</p>
<p>一般中继器俩段连接的是相同的媒介,但有的中继器也可以连接不同的媒介. 例如同轴电缆与光缆之间的信号调整,但是即使在这种情况下,TA也只是单纯的负责信号在0和1比特流之间的替换,并不判断数据是否有错误. 同时它只负责将电信号转换为光信号,因此不能在不同的媒介之间进行转发.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCP-IP/">TCP IP</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/08/网络/数据链路层/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/08/网络/数据链路层/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/08/网络/传输层/" title="传输层" itemprop="url">传输层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在俩个主机之间创建逻辑上的通信连接.同时还要确保所传输的数据是可达的,如果不可达在负责重发.</p>
<p>包含的协议:</p>
<ul>
<li>TCP</li>
<li>UDP</li>
<li>SCTP</li>
<li>DCCP<br>TCP模块负责建立,发送数据以及断开连接. 当传输层接收到应用层传递过来的数据,由TCP模块处理时,TCP模块会在应用层数据前部添加一个TCP首部,其包含:</li>
<li>源端口号</li>
<li>目标端口号</li>
<li>序号(识别包中哪些是应用层数据)</li>
<li>校验和(判断数据是否被破坏)</li>
</ul>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p><img src="https://raw.githubusercontent.com/wanggnim/blog-website/images/net/TCP_STATE2.jpg" alt=""></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul>
<li>第一次握手：建立连接时，客户端首先向服务端发送一个 SYN 包和一个随机序列号 A，客户端进入SYN_SENT状态，等待服务器确认；</li>
<li>第二次握手：服务端收到后会回复客户端一个 SYN-ACK 包以及一个确认号（用于确认收到 SYN）A+1，同时再发送一个随机序列号 B，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到后会发送一个 ACK 包以及确认号（用于确认收到 SYN-ACK）B+1 和序列号 A+1 给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li>客户端执行<code>CLOSE</code>主动关闭,向服务器发送<code>FIN</code>数据报. 客户端进入<code>FIN WAIT1</code>状态</li>
<li>服务器收到客户端发送过来的<code>FIN</code>数据包执行被动关闭,同时向客户端响应<code>ACK</code>数据包,服务器进入<code>CLOSE WAIT</code>状态. 客户端收到服务端发送过来的<code>ACK</code>包后, 客户端进入<code>FIN WAIT2</code>状态.</li>
<li>紧接着服务器再发送一个<code>ACK</code>包,服务器进入<code>LAST ACK</code>状态. 服务器端就关闭了.</li>
<li>客户端收到<code>ACK</code>包后进入<code>TIME_WAIT</code>状态. 当客户端超时后也就执行关闭了.</li>
</ol>
<p>TCP端口状态：</p>
<ol>
<li>LISTENING状态: FTP服务启动后首先处于侦听（LISTENING）状态。</li>
<li>ESTABLISHED状态: ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li>
<li>CLOSE_WAIT: 对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li>
<li>TIME_WAIT: 我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li>
<li>SYN_SENT状态:SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多SYN_SENT的原因。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCP-IP/">TCP IP</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/08/网络/传输层/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/08/网络/传输层/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/网络/OSI参考模型/" title="OSI参考模型" itemprop="url">OSI参考模型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-01T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>OSI参考模型:</p>
<ul>
<li>应用层: 为应用程序提供服务,并规定应用程序中通信相关的细节.</li>
<li>表示层: 将应用处理的信息转换为适合网络传输的格式或者将下一层的数据转换为上层能够处理的格式</li>
<li>会话层: 负责建立和断开通信连接,以及数据的分割等数据传输相关的管理</li>
<li>传输层: 管理俩个节点的数据传输</li>
<li>网络层: 负责寻址和路由选择.</li>
<li>数据链路层: 负责物理层面上互联的,节点之间的通信传输.</li>
<li>物理层: 负责0,1比特流与电压的高低,光的闪灭之间的互换</li>
</ul>
<blockquote>
<p>表示层: 表示层担当着”统一的网络数据格式”与应用特定数据格式转换的功能. 实际上也就是将应用层的数据按照指定的格式进行编码,然后在数据首部添加首部信息.</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCP-IP/">TCP IP</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/02/网络/OSI参考模型/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/02/网络/OSI参考模型/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/26/操作系统/NUMA/" title="NUMA和RDMA" itemprop="url">NUMA和RDMA</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-10-25T16:00:00.000Z" itemprop="datePublished"> Published 2015-10-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="支持NUMA的CPU"><a href="#支持NUMA的CPU" class="headerlink" title="支持NUMA的CPU"></a>支持NUMA的CPU</h2><p>英特尔系列的</p>
<ul>
<li>Nehalem和Tukwila系列之后的处理器</li>
<li>Xeon</li>
<li>至强处理器 E5-2690</li>
<li>i3、i5、i7</li>
</ul>
<p>HP系列的</p>
<ul>
<li>Superdome</li>
<li>SGI的Altix 3000</li>
</ul>
<p>IBM的</p>
<ul>
<li>p690</li>
<li>x440</li>
</ul>
<p>NEC</p>
<ul>
<li>TX7</li>
</ul>
<p>AMD</p>
<ul>
<li>Opteron</li>
</ul>
<h2 id="Linux中关于NUMA的命令"><a href="#Linux中关于NUMA的命令" class="headerlink" title="Linux中关于NUMA的命令"></a>Linux中关于NUMA的命令</h2><ul>
<li>NUMACTL ：设定进程NUMA策略的命令行工具。</li>
<li>NUMASTAT ：获取NUMA内存访问统计信息的命令行工具</li>
</ul>
<p>开启NUMA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --cpunodebind=<span class="number">0</span> --membind=<span class="number">0</span> myapp</span><br></pre></td></tr></table></figure></p>
<h1 id="JAVA中的NUMA"><a href="#JAVA中的NUMA" class="headerlink" title="JAVA中的NUMA"></a>JAVA中的NUMA</h1><p><code>-XX:+UseNUMA</code>启用Numa, 默认情况下,JVM所占内存会随机的分配到不同的NUMA节点上,当cpu运算时可能会到不同的NUMA节点的告诉缓存上进行数据查找,降低系统速度,可使用numactl工具将JVM进程绑定到特定的NUMA节点上,只让其访问自己所在节点的内存.</p>
<h1 id="NUMA用于MySQL"><a href="#NUMA用于MySQL" class="headerlink" title="NUMA用于MySQL"></a>NUMA用于MySQL</h1><p>调优的时候，有哪些关键配置项，需要注意什么</p>
<ul>
<li><code>numactl --interleave=all</code></li>
<li>在MySQL进程启动前，使用<code>sysctl -q -w vm.drop_caches=3</code>清空文件缓存所占用的空间</li>
<li>Innodb在启动时，就完成整个<code>Innodb_buffer_pool_size</code>的内存分配</li>
</ul>
<h1 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h1><p>RDMA 技术需要怎样的硬件，寻找一篇RDMA用于数据库或者Java的文章，对其性能和用法做简单的阐述。</p>
<p>RDMA是一种网卡技术,采用该技术可以使一台计算机直接将信息放入另一台计算机的内存中。RDMA通过在网卡上将可靠传输协议固化于硬件,以及支持绕过内核的零拷贝网络这两种途径来达到这一目标。绕过内核使应用程序不必执行内核调用就可以向网卡发出命令。当一个应用程序执行RDMA读/写请求时,系统并不执行数据拷贝动作。这就减少了处理 网络通信时在内核空间和用户空间上下文切换的次数。RDMA请求的完成,或者完全在用户空间中进行,或者在应用程序希望进入睡眠直到完成信号出现的情况下 通过内核进行。</p>
<p>RDMA实现：</p>
<ul>
<li>利用传统的网络硬件,以TCP/IP及以太网络标准来建立因特网</li>
<li>InfiniBand网络和实现虚拟接口架构的网络支持RDMA.</li>
</ul>
<p>采用RDMA来获取高性能的协议包括</p>
<ul>
<li>Sockets Direct Protocol</li>
<li>SCSI RDMA Protocol（SRP）</li>
<li>Direct Access File System（DAFS）</li>
</ul>
<h2 id="Java-7-SDP"><a href="#Java-7-SDP" class="headerlink" title="Java 7 SDP"></a>Java 7 SDP</h2><p>在Solaris系统上只要有物理InfiniBand网卡，Java 7 SDP就可以立即工作。</p>
<p>Linux则通过Open Fabrics Enterprise Distribution（OFED）包支持SDP。</p>
<blockquote>
<p>确认Linux版本有没有配置OFED设备驱动器，<code>egrep &quot;^[ \t]+ib&quot; /proc/net/dev</code>可以使用该命令测试.</p>
</blockquote>
<p>Java只通过<code>java.net.Socket、java.net.ServerSocket、java.net.Datagram</code>对传输层进行抽象,通过<code>Java.net.InetAddress</code>对网络层进行抽象.只需要将JVM和InfiniBand操作系统设备和库进行设定,java就可以通过传输层抽象直接与物理层进行访问,从而绕过了网络层和数据链路层.</p>
<p>SDP也能让Java具备非常强大的“零拷贝”,这个零拷贝并不是指的是<code>java.nio.channels.FileChannel</code>的<code>transferTo()</code>实现的零拷贝.而是直接使用原生的InfiniBand零拷贝协议实现。现在CPU不用将一个内存区域的数据拷贝到另一个内存区域。CPU可以继续处理其他任务，数据拷贝则由机器的另一部分并行处理，这样就提升了性能。此外，零拷贝操作减少了在用户空间和内核空间之间切换所消耗的时间。</p>
<p><img src="https://raw.githubusercontent.com/ming15/blog-website/images/net/javasdp.jpg" alt=""></p>
<h3 id="配置JVM7支持SDP"><a href="#配置JVM7支持SDP" class="headerlink" title="配置JVM7支持SDP"></a>配置JVM7支持SDP</h3><p>SDP配置文件是个文本文件，JVM启动时会从本地文件系统读取该文件。我们有俩种规则来定义：</p>
<ol>
<li>bind规则：只要TCP套接字绑定到与规则匹配的地址和端口，就会使用SDP协议进行传输。</li>
<li>connect规则：没有绑定的TCP套接字尝试连接匹配规则的地址和端口时，就会使用SDP协议进行传输。<br>第一个关键字用来表明规则是bind还是connect。第二部分指定主机名或IP地址。当指定为IP地址时，你也可以指定表示IP地址范围的前缀。第三部分即最后一个部分是端口号或端口号范围。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 绑定到192.168.1.196主机所有端口使用SDP</span><br><span class="line">bind 192.168.1.196 *</span><br><span class="line"></span><br><span class="line"># 连接到192.168.2.*上的所有应用服务时都使用SDP</span><br><span class="line">connect 192.168.2.0/24 1024-*</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用SDP的JVM7"><a href="#使用SDP的JVM7" class="headerlink" title="使用SDP的JVM7"></a>使用SDP的JVM7</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java \</span><br><span class="line">-Dcom.sun.sdp.conf=sdp.conf \</span><br><span class="line">-Djava.net.preferIPv4Stack=<span class="keyword">true</span> \</span><br><span class="line">Application.class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意要指定网络格式为<code>IPv4Stack</code>。尽管Java 7和InfiniBand都支持IPv6网络格式，但Solaris和Linux都不支持两者之间的映射。所以启动支持SDP的Java 7 VM时，还是要使用基础、可靠的IPv4网络格式。</p>
</blockquote>
<h2 id="IO性能度量"><a href="#IO性能度量" class="headerlink" title="IO性能度量"></a>IO性能度量</h2><h3 id="全SSD硬盘的IO阀值"><a href="#全SSD硬盘的IO阀值" class="headerlink" title="全SSD硬盘的IO阀值"></a>全SSD硬盘的IO阀值</h3><p>SSD 硬盘传输速率取 500M/S<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>ms + <span class="number">0</span> + <span class="number">4</span>K/<span class="number">500</span>MB = <span class="number">0.1</span> + <span class="number">0</span> + <span class="number">0.008</span> = <span class="number">0.108</span></span><br><span class="line"></span><br><span class="line">IOPS = <span class="number">1</span>/<span class="number">0.108</span> ms = <span class="number">9259</span> IOPS</span><br></pre></td></tr></table></figure></p>
<p>吞吐率 = <code>9259 * 4K = 37M / 500M = 7.4%</code></p>
<h3 id="1万转机械磁盘的IO阀值"><a href="#1万转机械磁盘的IO阀值" class="headerlink" title="1万转机械磁盘的IO阀值"></a>1万转机械磁盘的IO阀值</h3><p>1 万转机械磁盘传输速率取 200M/S<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>ms + (<span class="number">60</span>sec/<span class="number">10000</span>RPM/<span class="number">2</span>) + <span class="number">4</span>K/<span class="number">200</span>MB = <span class="number">5</span> + <span class="number">3</span> + <span class="number">0.02</span> = <span class="number">8.02</span> IOPS = <span class="number">1</span>/<span class="number">8.02</span>s ms = <span class="number">125</span> IOPS</span><br></pre></td></tr></table></figure></p>
<p>吞吐率 = <code>125 * 4K = 500K / 200M = 0.25%</code></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/26/操作系统/NUMA/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/26/操作系统/NUMA/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/15/mgits/技术CheckList/" title="技术CheckList" itemprop="url">技术CheckList</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-10-14T16:00:00.000Z" itemprop="datePublished"> Published 2015-10-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h2><h3 id="序列化bug"><a href="#序列化bug" class="headerlink" title="序列化bug"></a>序列化bug</h3><p>在项目中运营团队给出了下面这样的一个公告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">================================================</span><br><span class="line">官方QQ群： <span class="number">467027422</span></span><br><span class="line">官方微信号：gm-xyxmp</span><br><span class="line">微信订阅号：xyxmpsy</span><br><span class="line"></span><br><span class="line">亲爱的小伙伴：</span><br><span class="line"></span><br><span class="line">大家好，老猪给各位请安了！</span><br><span class="line"></span><br><span class="line">首款能交易的<span class="number">3</span>D卡牌游戏，星爷独家正版授权《西游降魔篇<span class="number">3</span>D》</span><br><span class="line">自<span class="number">2015</span>年<span class="number">7</span>月<span class="number">21</span>日正式登陆iOS平台后，大量玩家热情涌入游戏</span><br><span class="line">，老猪我面对此景喜极而泣，为了让更多小伙伴加入到咱们的</span><br><span class="line">大团队中，老猪我决定[FFFF00]<span class="number">10</span>月<span class="number">16</span>日<span class="number">11</span>：<span class="number">00</span>开启新服N23-物华天宝 [-]，</span><br><span class="line">诚邀各位新老玩家的加入！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新服开启，精彩纷呈的活动期待各位的参与，丰厚的大礼拿到手</span><br><span class="line">抽筋，在《西游降魔篇<span class="number">3</span>D》西行的途中，让我们一同感受友情，</span><br><span class="line">感受激情，感受无限快乐！</span><br><span class="line"></span><br><span class="line">服务器名称：[FFFF00]N23-物华天宝 [-]</span><br><span class="line">开服时间：[FFFF00]<span class="number">2015</span>年<span class="number">10</span>月<span class="number">16</span>日<span class="number">11</span>：<span class="number">00</span>（周五）[-]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">伴随开服的同时，多个活动前来助阵！</span><br><span class="line">[FFFF00]活动一：连续登陆送豪礼[-]</span><br><span class="line">[FFFF00]活动二：冲级领元宝[-]</span><br><span class="line">[FFFF00]活动三：战力大比拼[-]</span><br><span class="line">[FFFF00]活动四：五星神将双倍抽[-]</span><br><span class="line">[FFFF00]活动五：天天有礼送段小姐[-]</span><br><span class="line">[FFFF00]活动六：累积充值送玉帝[-]</span><br><span class="line">[FFFF00]活动七：每日礼包大回馈[-]</span><br><span class="line">[FFFF00]活动八：首充翻倍送豪礼[-]</span><br><span class="line">[FFFF00]活动九：签到送好礼[-]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">活动详情请查看游戏内公告！</span><br><span class="line">================================================</span><br><span class="line">                                                            《西游降魔篇<span class="number">3</span>D》运营团队</span><br></pre></td></tr></table></figure></p>
<p>当我将其赋值到一个对象<code>obj#value</code>时,然后使用<code>JSON.toJSONString(obj)</code>的时候遇到了下面的异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">160</span></span><br><span class="line">	at com.alibaba.fastjson.serializer.SerializeWriter.writeStringWithDoubleQuote(SerializeWriter.java:<span class="number">868</span>)</span><br><span class="line">	at com.alibaba.fastjson.serializer.SerializeWriter.writeStringWithDoubleQuote(SerializeWriter.java:<span class="number">602</span>)</span><br><span class="line">	at com.alibaba.fastjson.serializer.SerializeWriter.writeString(SerializeWriter.java:<span class="number">1366</span>)</span><br><span class="line">	at com.alibaba.fastjson.serializer.StringCodec.write(StringCodec.java:<span class="number">49</span>)</span><br><span class="line">	at com.alibaba.fastjson.serializer.StringCodec.write(StringCodec.java:<span class="number">34</span>)</span><br><span class="line">	at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:<span class="number">369</span>)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONString(JSON.java:<span class="number">430</span>)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONString(JSON.java:<span class="number">418</span>)</span><br><span class="line">	at Print1.main(Print1.java:<span class="number">52</span>)</span><br></pre></td></tr></table></figure></p>
<p>出现的原因是:<code>服务器名称：[FFFF00]N23-物华天宝 [-]</code>物华天宝后面跟的空格，不是我们常用的ascii码为32的空格，而是一个ascii码为160特殊的空格符,导致JSON序列化时失败.</p>
<h2 id="用户名字符集"><a href="#用户名字符集" class="headerlink" title="用户名字符集"></a>用户名字符集</h2><p>用户可能输入emoji表情符号,这种符号普遍存在iOS与android系统中,这种表情不处理直接存储到MySQL5.5以下的版本会报错</p>
<blockquote>
<p>这种符号采用Unicode 6标准4个bytes作为存储单元,MySQL存储这种字符需要修改数据库字符集为utf8mb4,但数据回传给网页或者移动客户端时则需要做兼容处理</p>
</blockquote>
<h2 id="日志问题"><a href="#日志问题" class="headerlink" title="日志问题"></a>日志问题</h2><p>在项目的开发过程中不允许使用debug模式, 一定要使用日志分析问题, 因为在线上时候, 没办法使用debug的方式, 因此在记录的日志的时候, 一定要记录的全(每个数据变化都要记录下来), 简(剩下来的就是钱)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/mgits/">mgits</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/15/mgits/技术CheckList/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/15/mgits/技术CheckList/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/15/linux/Linux常用命令/" title="Linux常用命令" itemprop="url">Linux常用命令</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-10-14T16:00:00.000Z" itemprop="datePublished"> Published 2015-10-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>将文件或者文件夹压缩成后缀为<code>.gz</code>的文件</p>
<ul>
<li><code>-a</code> 　使用ASCII文字模式.</li>
<li><code>-c</code> 　把压缩后的文件输出到标准输出设备,不去更动原始文件.</li>
<li><code>-d</code> 　解开压缩文件.</li>
<li><code>-f</code> 　强行压缩文件.不理会文件名称或硬连接是否存在以及该文件是否为符号连接.</li>
<li><code>-l</code> 　列出压缩文件的相关信息.</li>
<li><code>-L</code> 　显示版本与版权信息.</li>
<li><code>-n</code> 　压缩文件时,不保存原来的文件名称及时间戳记.</li>
<li><code>-N</code> 　压缩文件时,保存原来的文件名称及时间戳记.</li>
<li><code>-q</code> 　不显示警告信息.</li>
<li><code>-r</code> 　递归处理,将指定目录下的所有文件及子目录一并处理.</li>
<li><code>-S</code> 　更改压缩字尾字符串.</li>
<li><code>-t</code> 　测试压缩文件是否正确无误.</li>
<li><code>-v</code> 　显示指令执行过程.</li>
<li><code>-num</code> 用指定的数字num调整压缩的速度,-1或–fast表示最快压缩方法（低压缩比）,-9或–best表示最慢压缩方法（高压缩比）.系统缺省值为6.</li>
</ul>
<p>常用命令</p>
<ul>
<li><code>gzip *</code>  把test6目录下的每个文件压缩成.gz文件</li>
<li><code>gzip -dv *</code> 把例1中每个压缩的文件解压,并列出详细的信息</li>
<li><code>gzip -l *</code> 详细显示例1中每个压缩的文件的信息,并不解压</li>
<li><code>gzip -r log.tar</code> 压缩一个tar备份文件,此时压缩文件的扩展名为.tar.gz</li>
<li><code>gzip -rv test6</code> 递归的压缩目录</li>
<li><code>gzip -dr test6</code> 递归地解压目录</li>
</ul>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>一种强大的文本搜索工具,它能使用正则表达式搜索文本,并把匹 配的行打印出来</p>
<p>主要参数：</p>
<ul>
<li><code>－c</code>：只输出匹配行的计数.</li>
<li><code>－I</code>：不区分大小写(只适用于单字符).</li>
<li><code>－h</code>：查询多文件时不显示文件名.</li>
<li><code>－l</code>：查询多文件时只输出包含匹配字符的文件名.</li>
<li><code>－n</code>：显示匹配行及行号.</li>
<li><code>－s</code>：不显示不存在或无匹配文本的错误信息.</li>
<li><code>－v</code>：显示不包含匹配文本的所有行.</li>
</ul>
<p>pattern正则表达式主要参数：</p>
<ul>
<li><code>\</code>： 忽略正则表达式中特殊字符的原有含义.</li>
<li><code>^</code>：匹配正则表达式的开始行.</li>
<li><code>$</code>: 匹配正则表达式的结束行.</li>
<li><code>\&lt;</code>：从匹配正则表达 式的行开始.</li>
<li><code>\&gt;</code>：到匹配正则表达式的行结束.</li>
<li><code>[ ]</code>：单个字符,如[A]即A符合要求 .</li>
<li><code>[ - ]</code>：范围,如[A-Z],即A、B、C一直到Z都符合要求 .</li>
<li><code>.</code>：所有的单个字符.</li>
<li><code>*</code> ：有字符,长度可以为0.</li>
</ul>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar可用于建立、还原、查看、管理文件,也可方 便的追加新文件到备份文件中,或仅更新部分的备份文件,以及解压、删除指定的文件</p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort将文件的每一行作为一个单位,相互比较,比较原则是从首字符向后,依次按ASCII码值进行比较,最后将他们按升序输出.</p>
<p>命令参数</p>
<ul>
<li><code>-u</code> 在输出行中去除重复行.</li>
<li><code>-r</code> sort默认的排序方式是升序,加-r改成降序</li>
<li><code>-o</code> 将排序结果输出到原文件,而使用重定向是不可以的.</li>
<li><code>-n</code> sort命令默认是按照字符排序的,如果遇到数字的字符, 可能会出现1大于10的情况, 所以我们可以设定<code>-n</code>选项, 将其按照数字排序</li>
<li><code>-t</code> 设定间隔符. 设置间隔符,就会将每一行分割成一个数组,我们可以使用-k参数指定按照某列排序</li>
<li><code>-k</code> -t指定了间隔符之后,可以用-k指定基于某列排序.</li>
<li><code>-f</code> 会将小写字母都转换为大写字母来进行比较,亦即忽略大小写</li>
<li><code>-c</code> 会检查文件是否已排好序,如果乱序,则输出第一个乱序的行的相关信息,最后返回1</li>
<li><code>-C</code> 会检查文件是否已排好序,如果乱序,不输出内容,仅返回1</li>
<li><code>-M</code> 会以月份来排序,比如JAN小于FEB等等</li>
<li><code>-b</code> 会忽略每一行前面的所有空白部分,从第一个可见字符开始比较.</li>
</ul>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>统计指定文件中的字节数、字数、行数,并将统计结果显示输出.该命令统计指定文件中的字节数、字数、行数.如果没有给出文件名,则从标准输入读取.wc同时也给出所指定文件的总统计数.</p>
<ul>
<li><code>-c</code> 统计字节数.</li>
<li><code>-l</code> 统计行数.</li>
<li><code>-m</code> 统计字符数.这个标志不能与 -c 标志一起使用.</li>
<li><code>-w</code> 统计字数.一个字被定义为由空白、跳格或换行字符分隔的字符串.</li>
<li><code>-L</code> 打印最长行的长度.</li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><code>find pathname -options [-print -exec -ok ...]</code></p>
<p>命令参数；<br><code>pathname</code>: 要查找的路径.<br><code>-print</code>： find命令将匹配的文件输出到标准输出.<br><code>-exec</code>： 匹配到合适文件后执行的shell命令.相应命令的形式为<code>&#39;command&#39; { } ;</code>(注意{ }和；之间的空格).<br><code>-ok</code>： 和-exec的作用相同,但是在执行命令之前,都会给出提示确认是否真的执行.</p>
<p>options选项</p>
<ul>
<li><code>-name</code> 要查找的文件名(可以使用正则).</li>
<li><code>-perm</code> 按照文件权限查找文件.</li>
<li><code>-prune</code> 使用这一选项可以使find命令不在当前指定的目录中查找,如果同时使用-depth选项,那么-prune将被find命令忽略.</li>
<li><code>-user</code> 按照文件属主来查找文件.</li>
<li><code>-group</code> 按照文件所属的组来查找文件.</li>
<li><code>-mtime -n +n</code> 按照文件的更改时间来查找文件, - n表示文件更改时间距现在n天以内,+ n表示文件更改时间距现在n天以前.</li>
<li><code>-nogroup</code> 查找无有效所属组的文件,即该文件所属的组在/etc/groups中不存在.</li>
<li><code>-nouser</code> 查找无有效属主的文件,即该文件的属主在/etc/passwd中不存在.</li>
<li><code>-newer file1 ! file2</code> 查找更改时间比文件file1新但比文件file2旧的文件.</li>
<li><code>-type</code> 查找某一类型的文件(例如: <code>-b</code>块设备文件. <code>-d</code>目录. <code>-c</code>字符设备文件. <code>-p</code>管道文件. <code>-l</code>符号链接文件. <code>-f</code>普通文件.)</li>
<li><code>-size n [c]</code>：查找文件长度为n块的文件,带有c时表示文件长度以字节计.</li>
<li><code>-depth</code>：在查找文件时,首先查找当前目录中的文件,然后再在其子目录中查找.</li>
<li><code>-mount</code>：在查找文件时不跨越文件系统mount点.</li>
<li><code>-follow</code>：如果find命令遇到符号链接文件,就跟踪至链接所指向的文件.</li>
</ul>
<p>另外,下面三个的区别:</p>
<ul>
<li><code>-amin n</code>  查找系统中最后N分钟访问的文件</li>
<li><code>-atime n</code> 查找系统中最后n*24小时访问的文件</li>
<li><code>-cmin n</code>  查找系统中最后N分钟被改变文件状态的文件</li>
<li><code>-ctime n</code> 查找系统中最后n*24小时被改变文件状态的文件</li>
<li><code>-mmin n</code>  查找系统中最后N分钟被改变文件数据的文件</li>
<li><code>-mtime n</code> 查找系统中最后n*24小时被改变文件数据的文件</li>
</ul>
<h2 id="grep-1"><a href="#grep-1" class="headerlink" title="grep"></a>grep</h2><p>用法: <code>grep [选项]... PATTERN [FILE]...</code>. 在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i &apos;hello world&apos; menu.h main.c</span><br></pre></td></tr></table></figure></p>
<p>正则表达式选择与解释:</p>
<ul>
<li>-E, –extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)</li>
<li>-F, –fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。</li>
<li>-G, –basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)</li>
<li>-P, –perl-regexp         PATTERN 是一个 Perl 正则表达式</li>
<li>-e, –regexp=PATTERN      用 PATTERN 来进行匹配操作</li>
<li>-f, –file=FILE           从 FILE 中取得 PATTERN</li>
<li>-i, –ignore-case         忽略大小写</li>
<li>-w, –word-regexp         强制 PATTERN 仅完全匹配字词</li>
<li>-x, –line-regexp         强制 PATTERN 仅完全匹配一行</li>
<li>-z, –null-data           一个 0 字节的数据行，但不是空行</li>
</ul>
<p>Output control:</p>
<ul>
<li>-m, –max-count=NUM       只获得前m个匹配结果</li>
<li>-b, –byte-offset         在输出的内容中打印byte offset</li>
<li>-n, –line-number         输出行号</li>
<li>–line-buffered       每一行都输出, 不再行上进行缓存</li>
<li>-H, –with-filename       输出文件名</li>
<li>-h, –no-filename         不输出文件名</li>
<li>-o, –only-matching       仅仅输出一行中符合 PATTERN模式 匹配要求的部分</li>
<li>-a, –text                等同于 –binary-files=text</li>
<li>-I                        等同于 –binary-files=without-match</li>
<li>-d, –directories=ACTION  处理目录方式; <code>read&#39;,</code>recurse’, or `skip’</li>
<li>-D, –devices=ACTION      处理 devices, FIFOs and sockets的方式: <code>read&#39; or</code>skip’</li>
<li>-R, -r, –recursive       equivalent to –directories=recurse</li>
<li>–include=FILE_PATTERN  仅对符合FILE_PATTERN模式的文件进行搜索</li>
<li>–exclude=FILE_PATTERN  跳过符合FILE_PATTERN的文件和目录</li>
<li>–exclude-from=FILE   跳过符合FILE中file pattern所有的文件</li>
<li>–exclude-dir=PATTERN  符合PATTERN模式的目录将被跳过.</li>
<li>-L, –files-without-match  只输出匹配失败的文件名</li>
<li>-l, –files-with-matches  只输出匹配成功的文件名</li>
<li>-c, –count               只输出每个文件匹配成功的行数</li>
<li>-Z, –null                在文件名后输出0 byte</li>
</ul>
<p>Context control:</p>
<ul>
<li>-B, –before-context=NUM  显示匹配字符串前n行的数据</li>
<li>-A, –after-context=NUM   显示匹配字符串后n行的数据</li>
<li>-C, –context=NUM         print NUM lines of output context</li>
<li>-NUM                      和 –context=NUM 一样</li>
</ul>
<p>当前目录下有多个文件我们想要同时对所有文件进行搜索的话, 我们可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;刷新&quot; *</span><br></pre></td></tr></table></figure></p>
<p>如果我们只想对今天的文件进行搜索的话, 可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;刷新&quot; *2016-02-02*</span><br></pre></td></tr></table></figure></p>
<p>如果我们的目录下有多个目录, 要搜索的文件都在当前的子目录里的话, 可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --directories=recurse &quot;刷新&quot; *</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/15/linux/Linux常用命令/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/15/linux/Linux常用命令/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="ming15" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Groovy/" title="Groovy">Groovy<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Haskell/" title="Haskell">Haskell<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JMH/" title="JMH">JMH<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java工具/" title="Java工具">Java工具<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Netty/" title="Netty">Netty<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Php/" title="Php">Php<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reids/" title="Reids">Reids<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCP-IP/" title="TCP IP">TCP IP<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ZooKeeper/" title="ZooKeeper">ZooKeeper<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/asm/" title="asm">asm<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/guice/" title="guice">guice<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/http客户端/" title="http客户端">http客户端<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/http服务器/" title="http服务器">http服务器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/memcached/" title="memcached">memcached<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/mgits/" title="mgits">mgits<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/mycat/" title="mycat">mycat<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/python2/" title="python2">python2<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发编程/" title="并发编程">并发编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/序列化工具/" title="序列化工具">序列化工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志工具/" title="日志工具">日志工具<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/构建工具/" title="构建工具">构建工具<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www1.vertx3.cn" target="_blank" title="vertx3">vertx3</a>
            
          </li>
        
    </ul>
</div>

  

<div class="doubanshow">
<p class="asidetitle">Douban Show</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/xxxyy/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3253370782&verifier=e9ca895b&dpc=1"></iframe>
</div>


  

<div class="lofter">
<p class="asidetitle">Lofter</p>

 <iframe width="100%" height="39" class="share_self"  frameborder="0" scrolling="no" src="http://ming15.lofter.com/"></iframe>
</div>




</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 博客,我选择重构 <br/>
			重构使事情变得更美,更加正确</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3253370782" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/ming15" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xxxyy" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/ming15" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="ming15">ming15</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"wanggnim"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e8fca440159a2125668804e46682db4' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
