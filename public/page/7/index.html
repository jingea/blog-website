
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ming15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming15">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ming15">
<meta property="og:url" content="http://www.ming15.wang/page/7/index.html">
<meta property="og:site_name" content="ming15">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ming15">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="ming15" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ming15" title="ming15"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ming15">ming15</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 17728547076946147000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 序列化/" title="JAVA 序列化" itemprop="url">JAVA 序列化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h2><p>Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成. 如上所示的代码，由于writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段. </p>
<h2 id="Flushable"><a href="#Flushable" class="headerlink" title="Flushable"></a>Flushable</h2><p>实现了Flushable接口的类的对象，可以强制将缓存的输出写入到与对象关联的流中. 写入流的所有I/O类都实现了Flushable接口. </p>
<h2 id="ObjectInputValidation"><a href="#ObjectInputValidation" class="headerlink" title="ObjectInputValidation"></a>ObjectInputValidation</h2><p>序列化流验证机制.一般情况下，我们认为序列化流中的数据总是与最初写到流中的数据一致，这并没有问题. 但当黑客获取流信息并篡改一些敏感信息重新序列化到流中后，用户通过反序列化得到的将是被篡改的信息. Java序列化提供一套验证机制. 序列化类通过实现 java.io.ObjectInputValidation接口，就可以做到验证了</p>
<h2 id="ObjectStreamConstants"><a href="#ObjectStreamConstants" class="headerlink" title="ObjectStreamConstants"></a>ObjectStreamConstants</h2><p>Java序列化序列化对象的信息包括：类元数据描述、类的属性、父类信息以及属性域的值. Java将这些信息分成3部分：序列化头信息、类的描述部分以及属性域的值部分. 现在对a.txt文件加以分析，其中包含一些序列化机制中提供的特殊字段，这些字段被定义在java.io.ObjectStreamConstants接口中.  </p>
<h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><p>用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”</p>
<p>从DataInputStream一次一个字节地读取字符,那么任何值都是合法的,因此返回值不能用来检测输入是否结束.但是可以使用available()函数来查看还有多少字符可供读取</p>
<p>available()函数的工作方式会随之所读取的媒介类不同而不同, 该函数从字面上的意思来讲就是”在没有阻塞的情况下所能读取的字节数”.对于文件这指的是整个文件,而对于其他流可能就不是这样的</p>
<p>格式化的内存输入 当读取格式化数据时可以使用DataInputStream，它是一个面向字节的IO类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(TestDataInputStream.class.getCanonicalName())));) &#123;</span><br><span class="line">	<span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">		System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataInput 接口用于从二进制流中读取字节，并重构所有 Java 基本类型数据. 同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具. 对于此接口中的所有数据读取例程来说，如果在读取到所需字节数的数据之前已经到达文件末尾 (end of file)，则都将抛出 EOFException（IOException 的一种）. 如果因为文件末尾以外的其他原因无法读取字节，则抛出 IOException而不是 EOFException. 尤其在输入流已关闭的情况下，将抛出 IOException. </p>
</blockquote>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p>用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”. </p>
<p>我们可以使用DataOutputStream指定格式存储数据, 然后使用DataInputStream轻松的再次指定读取格式来恢复这些数据.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">out.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line"><span class="comment">// Only readUTF() will recover the Java-UTF String properly:</span></span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line">System.out.println(in.readDouble());</span><br><span class="line">System.out.println(in.readUTF());</span><br><span class="line"></span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>DataOutput 接口用于将任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流. 同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具. 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException.</p>
</blockquote>
<h2 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。</p>
<h2 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h2><p>用于从底层输入流中读取对象类型的数据和对象类型的数据写入到底层输出流。将对象中所有成员变量的取值保存起来就等于保存了对象，将对象中所有成员变量的取值还原就相等于读取了对象。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 序列化/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 序列化/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/21/JavaSE/JavaIO 读文件/" title="JAVA 读文件" itemprop="url">JAVA 读文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-20T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><p>我们使用<code>FileInputStream</code>, <code>BufferedInputStream</code>来读取文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取二进制文件</span></span><br><span class="line"><span class="keyword">try</span> (BufferedInputStream bf = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">		<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.available()];</span><br><span class="line">	bf.read(data);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BufferedInputStream</code>是一个带有缓冲区域的<code>InputStream</code>, 支持<code>mark()</code>标记和<code>reset()</code>重置方法.输入到byte[]数组里.</p>
<p><code>BufferedInputStream</code>只将数据读取进byte字节数组里, 因此这种方式只能读取二进制字节流</p>
<blockquote>
<p>FileInputStream 一个字节一个字节的从文件里读取数据</p>
</blockquote>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>BufferedReader 从字符输入流中读取文本,缓冲各个字符.提供字符、数组和行的高效读取.<br>我们有俩种方式创建BufferedReader.</p>
<ul>
<li>使用带缓冲区的写入器 <code>Files.newBufferedReader(Paths.get(&quot;new.txt&quot;), StandardCharsets.UTF_8);</code>;</li>
<li>读取UTF-8格式编码的文件 <code>new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))</code></li>
</ul>
<blockquote>
<p>InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符.将“字节输入流”转换成“字符输入流”.它继承于Reader.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = Files.newBufferedReader(Paths.get(<span class="string">"new.txt"</span>), StandardCharsets.UTF_8);</span><br><span class="line">reader.lines().forEach(line -&gt; System.out.println(line));</span><br></pre></td></tr></table></figure>
<p>我们可以使用JAVA8中的Stream来快捷的遍历每一行</p>
<blockquote>
<p>从标准IO中输入. 按照标准的IO模型,Java提供了<code>System.out, System.out, System.err System.out,System.err</code> 已经被包装成了<code>PrintStream</code>对象,但是<code>System.in</code>作为原生<code>InputStream</code>却没有进行过任何包装. 所以在使用<code>System.in</code>时必须对其进行包装,下例中展示了,我们使用<code>InputStreamReader</code>将<code>System.in</code>包装<code>Reader</code>,然后再包装一层<code>BufferedReader</code></p>
<p>另外还有一点需要提到的是FileReader, 它一个字符一个字符地读取.</p>
</blockquote>
<h2 id="LineNumberInputStream"><a href="#LineNumberInputStream" class="headerlink" title="LineNumberInputStream"></a>LineNumberInputStream</h2><p>此类是一个输入流过滤器,它提供跟踪当前行号的附加功能.行是以回车符 (<code>\r</code>)、换行符 (<code>\n</code>)或回车符后面紧跟换行符结尾的字节序列.在所有这三种情况下,都以单个换行符形式返回行终止字符.行号以 0 开头,并在 read 返回换行符时递增 1.</p>
<h2 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h2><p>跟踪行号的缓冲字符输入流.此类定义了方法 <code>setLineNumber(int)</code> 和 <code>getLineNumber()</code>,它们可分别用于设置和获取当前行号.默认情况下,行编号从 0 开始.该行号随数据读取在每个行结束符处递增,并且可以通过调用 <code>setLineNumber(int)</code> 更改行号.但要注意的是,<code>setLineNumber(int)</code> 不会实际更改流中的当前位置；它只更改将由<code>getLineNumber()</code>返回的值.可认为行在遇到以下符号之一时结束：换行符（<code>\n</code>）、回车符（<code>\r</code>）、回车后紧跟换行符.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取行数</span></span><br><span class="line"><span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> (FileReader reader = <span class="keyword">new</span> FileReader(IOUtils.newFile(<span class="string">""</span>));</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(reader);) &#123;</span><br><span class="line">	<span class="keyword">while</span> (lnr.readLine() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		lineCount++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>读写随机访问文件 <code>RandomAccessFile</code>除了实现了<code>DataInput</code>和<code>DataOutput</code>接口之外,有效地与IO继承层次结构的其他部分实现了分离.</p>
<p>因为它不支持装饰模式,所以不能将其与<code>InputStream</code>和<code>OutputStream</code>子类的任何部分组合起来而且必须假定<code>RandomAccessFile</code>已经被正确的缓冲</p>
<p>用来访问那些保存数据记录的文件的,你就可以用<code>seek()</code>方法来访问记录,并进行读写了.这些记录的大小不必相同；但是其大小和位置必须是可知的.但是该类仅限于操作文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取所有的行</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile r = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length(); i++) &#123;</span><br><span class="line">		r.read();	<span class="comment">// r.readLine();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据,第二个参数必须为 "r", "rw", "rws", or "rwd"</span></span><br><span class="line"><span class="keyword">try</span> (RandomAccessFile w = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>; i++)</span><br><span class="line">		w.writeByte(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (FileChannel fc = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>)</span><br><span class="line">		.getChannel();) &#123;</span><br><span class="line"></span><br><span class="line">	IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, fc.size())</span><br><span class="line">			.asIntBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">		ib.put(ib.get(i - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"temp.tmp"</span>), <span class="string">"rw"</span>);</span><br><span class="line">raf.writeInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">	raf.seek(raf.length() - <span class="number">4</span>);</span><br><span class="line">	raf.writeInt(raf.readInt());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></p>
<h2 id="getResourceAsStream"><a href="#getResourceAsStream" class="headerlink" title="getResourceAsStream"></a>getResourceAsStream</h2><p>我们还可以使用类加载器的<code>getResourceAsStream()</code>从指定路径或者jar包中加载文件资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = ReloadClass.class.getClassLoader().getResourceAsStream(path);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[input.available()];</span><br><span class="line">	input.read(bytes);</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/21/JavaSE/JavaIO 读文件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/21/JavaSE/JavaIO 读文件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/20/netty/ByteBuf/" title="Netty ByteBuf" itemprop="url">Netty ByteBuf</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-19T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先我们来看一下netty buffer包的继承结构<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/netty/bytebuf.jpg" alt=""><br>接下来我会对几个类进行代码测试.</p>
<p>首先我们来看一下如何使用Netty提供的工具类构建一个ByteBuf<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">1024</span>, buf.capacity());</span><br></pre></td></tr></table></figure></p>
<p>我们使用<code>ByteBufAllocator</code>这个工具类构建了一个<code>1024</code>大小的<code>ByteBuf</code>出来.</p>
<p>ByteBuf提供了 <code>readerIndex</code> 和 <code>writerIndex</code> 进行缓冲区的顺序读写操作.</p>
<ul>
<li><code>readerIndex</code>标志读取索引</li>
<li><code>writerIndex</code>标志写入索引</li>
<li>[0, readerIndex] 已经读取多的缓冲区区间</li>
<li>[readerIndex, writerIndex] 可读的缓冲区区间</li>
<li>[writerIndex, capacity]  可写的缓冲区区间</li>
</ul>
<blockquote>
<p>每个索引移动的单位是<code>bytes</code>, 在下例中我们向ByteBuf写入一个int数值, <code>writerIdex</code>会移动4个<code>bytes</code></p>
</blockquote>
<h2 id="ByteBuf-API"><a href="#ByteBuf-API" class="headerlink" title="ByteBuf API"></a>ByteBuf API</h2><p>我们首先看一下ByteBuf提供的API</p>
<h3 id="ByteBuf-write"><a href="#ByteBuf-write" class="headerlink" title="ByteBuf write"></a>ByteBuf write</h3><p>接下来我们看一下向ByteBuf缓冲区写入数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 写入一个Int数值, writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'a'</span>);</span><br><span class="line">	<span class="comment">// 写入一个Char字符, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes);</span><br><span class="line">	<span class="comment">// 写入一个byte数组, 由于byte数组只有一个元素, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	buf.writeBytes(bytes, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 我们将三个元素的byte数组写入ByteBuf中,但是在写入的时候我们指定了开始索引和结束索引,</span></span><br><span class="line">	<span class="comment">// 由于我们的开始索引和结束索引相等, 因此ByteBuf中只写入了1这个元素</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytes3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf1.writeInt(<span class="number">1</span>);</span><br><span class="line">	buf.writeBytes(buf1);</span><br><span class="line">	<span class="comment">// 我们向ByteBuf中写入另一个ByteBuf, 它的索引仍然是增长4. ByteBuf不仅仅可以写入BuyeBuf,还可以写入InputStream和ByteBuffer</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">0.1f</span>);</span><br><span class="line">	<span class="comment">// 写入一个float, 由于float也是占用4个字节, 因此writerIndex向后移动4个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">	buf.writeByte(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个byte, writerIndex向后移动1个字节,至于写进去的数字大于128,会发生什么,我们在read的时候看一下结果</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">// 写入一个short, writerIndex向后移动2个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">1000.0</span>d);</span><br><span class="line">	<span class="comment">// 写入一个double, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">// 写入一个boolean, writerIndex向后移动1个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">100l</span>);</span><br><span class="line">	<span class="comment">// 写入一个long, writerIndex向后移动8个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteOverLoadMaxCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456"</span>.getBytes());</span><br><span class="line">	<span class="comment">// 虽然在分配的时候我们只分配了5个字节大小的缓冲区,但是我们写入6个字节它也并不报错,</span></span><br><span class="line">	<span class="comment">// 而且我们观察到writerIndex确实增长到了6,说明ByteBuf会进行自动拓容.</span></span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ByteBuf-read"><a href="#ByteBuf-read" class="headerlink" title="ByteBuf read"></a>ByteBuf read</h3><p>刚才我们看了向ByteBuf缓冲区写入数据的API,接下来我们看一下从ByteBuf缓冲区读取数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 读取Int, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeChar(<span class="string">'1'</span>);</span><br><span class="line">	<span class="keyword">char</span> read = buf.readChar();</span><br><span class="line">	<span class="comment">// 读取Char, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="string">'1'</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read);</span><br><span class="line">	<span class="comment">// 读取byte数组, 这里需要注意的是, read字节数组的长度不能大于ByteBuf的readerIndex的值,否则会产生数组越界</span></span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, read[<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBytesWithStartEndIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">byte</span>[] read = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">	buf.readBytes(read, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 从第三个索引开始读取到第4个索引的位置, 读取2个字节, readerIndex移动到第4个索引位置上</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, read[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead3Bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 读取3个字节, readerIndex向后移动3字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeFloat(<span class="number">10.0f</span>);</span><br><span class="line">	<span class="keyword">float</span> read = buf.readFloat();</span><br><span class="line">	<span class="comment">// 读取Float, readerIndex向后移动4字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>.f, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeLong(<span class="number">10l</span>);</span><br><span class="line">	buf.readLong();</span><br><span class="line">	<span class="comment">// 读取long, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 读取byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(<span class="number">10</span>);</span><br><span class="line">	buf.readShort();</span><br><span class="line">	<span class="comment">// 读取short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">	buf.readBoolean();</span><br><span class="line">	<span class="comment">// 读取boolean, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeDouble(<span class="number">10.0</span>d);</span><br><span class="line">	buf.readDouble();</span><br><span class="line">	<span class="comment">// 读取double, readerIndex向后移动8字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">8</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeByte(-<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">short</span> read = buf.readUnsignedByte();</span><br><span class="line">	<span class="comment">// 读取无符号byte, readerIndex向后移动1字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">246</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeShort(-<span class="number">1024</span>);</span><br><span class="line">	<span class="comment">// 我们首先读取出-1024,这个负数,然后转化成无符号数字64512</span></span><br><span class="line">	<span class="keyword">int</span> read = buf.readUnsignedShort();</span><br><span class="line">	<span class="comment">// 读取无符号Short, readerIndex向后移动2字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">2</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">64512</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">0</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadableBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.readableBytes());</span><br><span class="line">	buf.readByte();</span><br><span class="line">	<span class="comment">// 我们读取一个byte之后, 可读取字节变成了9个字节</span></span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.readableBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadUnsignedInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeInt(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">long</span> read = buf.readUnsignedInt();</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadSlice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	ByteBuf read = buf.readSlice(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">// slice出来的ByteBuf与原ByteBuf共享缓冲区</span></span><br><span class="line">	Assert.assertEquals(<span class="number">5</span>, buf.readerIndex());</span><br><span class="line">	Assert.assertEquals(<span class="number">1</span>, read.readByte());</span><br><span class="line">	Assert.assertEquals(<span class="number">6</span>, buf.readByte());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteBytesReadInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);</span><br><span class="line">	buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">int</span> read = buf.readInt();</span><br><span class="line">	<span class="comment">// 从一个byte数组中读取一个int, 会读取出1, 2, 3, 4这四个byte转换成int为16909060</span></span><br><span class="line">	Assert.assertEquals(<span class="number">16909060</span>, read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="discard-bytes"><a href="#discard-bytes" class="headerlink" title="discard bytes"></a>discard bytes</h3><p>在前面的测试中我们看到了,当向ByteBuf写入数据时,当超出分配内存大小时,ByteBuf会进行自动拓容(重新生成一个数组缓冲区,然后将原先的缓冲区内容拷贝到新的缓冲区中),这样一来ByteBuf占用的内从会越来越大. 我们可以是<code>discardReadBytes()</code>这个方法重用以前的缓冲区, 它会将[0, readerIndex]区间的内存舍弃掉(内部也是数组复制), 这么着就节间的重用了以前的缓冲区,但是这种方式有一点就是如果频繁的调用这个方法会带来性能问题.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 舍弃已读字节, readerIndex重置为0</span></span><br><span class="line">buf.discardReadBytes();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 6 = 44</span></span><br></pre></td></tr></table></figure></p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>这个操作并不会情况缓冲区的内容只是用来将readerIndex和writerIndex重置为0. 但是缓冲区的内容我们是仍然可以读到的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">buf.readBytes(<span class="number">3</span>);	<span class="comment">// 读取三个字节</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 3</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 9</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 9 - 3 = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 50 - 9 = 41</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置readerIndex和writerIndex</span></span><br><span class="line">buf.clear();</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 0</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 readerIndex = 0</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 capacity - writerIndex = 50</span></span><br><span class="line"><span class="comment">// 设置writerIndex</span></span><br><span class="line">buf.writerIndex(<span class="number">6</span>);</span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// readerIndex位置 : 0</span></span><br><span class="line">System.out.println(buf.writerIndex());		<span class="comment">// writerIndex位置: 6</span></span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 可读字节 writerIndex - readerIndex = 6</span></span><br><span class="line">System.out.println(buf.writableBytes());	<span class="comment">// 可写字节 44</span></span><br><span class="line">System.out.println(buf.readByte());</span><br></pre></td></tr></table></figure></p>
<h3 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark reset"></a>mark reset</h3><p>mark reset相关的四个方法也是对指针位置的操作</p>
<ul>
<li><code>markReaderIndex()</code> 记录readerIndex</li>
<li><code>markWriterIndex()</code> 记录writerIndex</li>
<li><code>resetReaderIndex()</code>  将记录的readerIndex重置到当前的readerIndex值</li>
<li><code>resetWriterIndex()</code>  将记录的writerIndex重置到当前的writerIndex值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReaderIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.readBytes(<span class="number">3</span>);</span><br><span class="line">	buf.markReaderIndex();</span><br><span class="line">	buf.readBytes(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">4</span>, buf.readerIndex());</span><br><span class="line">	buf.resetReaderIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">3</span>, buf.readerIndex());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriterIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">	buf.writeBytes(<span class="string">"123456789"</span>.getBytes());</span><br><span class="line">	buf.markWriterIndex();</span><br><span class="line">	buf.writeByte(<span class="number">1</span>);</span><br><span class="line">	Assert.assertEquals(<span class="number">10</span>, buf.writerIndex());</span><br><span class="line">	buf.resetWriterIndex();</span><br><span class="line">	Assert.assertEquals(<span class="number">9</span>, buf.writerIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>ByteBuf提供丰富的API让我查找某个Byte<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定的范围内查找某个byte</span></span><br><span class="line"><span class="keyword">int</span> idx = buf.indexOf(<span class="number">0</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">idx = buf.indexOf(<span class="number">3</span>, buf.writerIndex(), (<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);	<span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间查找值</span></span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">buf.readBytes(<span class="number">3</span>);</span><br><span class="line">idx = buf.bytesBefore((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[readerIndex, writerIndex]之间遍历查找值</span></span><br><span class="line">idx = buf.forEachByte(b -&gt; b == (<span class="keyword">byte</span>) <span class="number">6</span>);</span><br><span class="line">System.out.println(idx); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="derived-buffers"><a href="#derived-buffers" class="headerlink" title="derived buffers"></a>derived buffers</h3><p>ByteBuf提供多种API用于创建某个ByteBuf的视图或者复制版本</p>
<ul>
<li><code>duplicate()</code> 复制ByteBuf对象, 俩个对象共享同一个缓冲区,但是各自维护自己的索引(readerIndex, writerIndex)</li>
<li><code>copy()</code> 复制ByteBuf对象, 俩个对象共享有自己的缓冲区, 缓冲区和索引都不共享</li>
<li><code>slice()</code>  复制Bytebuf对象,但是只复制[readerIndex, writerIndex]区间的缓冲区, 俩个对象的缓冲区是共享的,但是维护各自的索引</li>
</ul>
<h3 id="get-set"><a href="#get-set" class="headerlink" title="get set"></a>get set</h3><p>ByteBuf不仅仅支持read, write的顺序读写还支持get,set的随机读取。 但是get/set不会进行自动拓容.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">50</span>);</span><br><span class="line">buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = buf.getByte(<span class="number">2</span>);</span><br><span class="line">System.out.println(buf.readableBytes());	<span class="comment">// 9</span></span><br><span class="line">System.out.println(buf.readerIndex());		<span class="comment">// 0</span></span><br><span class="line">System.out.println(b);		<span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>Netty的内存池由<code>PoolArea</code>. <code>PoolArea</code>由多个<code>PoolChunk</code>组成. </p>
<h2 id="ButeBuf-类型"><a href="#ButeBuf-类型" class="headerlink" title="ButeBuf 类型"></a>ButeBuf 类型</h2><p>看完ByteBuf的API操作我们来看一下ByteBuf的分类,在内存使用种类上ByteBuf分为以下俩类</p>
<ul>
<li>DirectByteBuf : 使用JVM堆外内存分配. 虽然分配和回收速度慢一些,但是从SocketChannel中写入或者读取数据由于少了一次内存复制,因此速度较快.(SocketIO通信时适合使用)</li>
<li>HeapByteBuf: 使用JVM堆内内存分配. 内存分配和回收速度较快,但是读写Socket IO的时候由于会额外进行一次内存复制,堆内存对应的缓冲区复制到内核Channel中,性能会有下降.(后端业务在编解码时适合使用)</li>
</ul>
<p>在内存使用种类上由分为以下俩类</p>
<ul>
<li>PooledByteBuf: 基于内存对象池的ByteBuf, </li>
<li>UnpooledByteBuf: </li>
</ul>
<blockquote>
<p>UnpooledDirectByteBuf, UnpooledHeapByteBuf, UnpooledUnsafeDirectByteBuf ,PooledDirectByteBuf, PooledHeapByteBuf</p>
</blockquote>
<h2 id="AbstractByteBuf"><a href="#AbstractByteBuf" class="headerlink" title="AbstractByteBuf"></a>AbstractByteBuf</h2><p><code>AbstractByteBuf</code>继承自<code>ByteBuf</code>, 它内部并没有定义ByteBuf的缓冲区实现,只是通过定义<code>readerIndex</code>, <code>writerIndex</code>, <code>capacity</code>等实现ByteBuf接口中的各种API, 具体的缓冲区实现则由子类实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;ByteBuf&gt; leakDetector = <span class="keyword">new</span> ResourceLeakDetector&lt;ByteBuf&gt;(ByteBuf.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> readerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> writerIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SwappedByteBuf swappedBuf;</span><br></pre></td></tr></table></figure></p>
<p>除了操作具体缓冲区API没有实现之外 <code>AbstractByteBuf</code>为我们实现了大量的API,首先我们看一下读数据的API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 检查当前缓冲区中的可读数据是否满足length长度</span></span><br><span class="line">    checkReadableBytes(length);</span><br><span class="line">    <span class="comment">// 将当前缓冲区的数据从readerIndex开始读取length个长度到目标dst缓冲区中. </span></span><br><span class="line">    <span class="comment">// 这个方法也就是拷贝一部分数据到新的缓冲区中,但是并不会改变当前缓冲区的readerIndex和writerIndex</span></span><br><span class="line">    getBytes(readerIndex, dst, dstIndex, length);</span><br><span class="line">    readerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们看一下写数据的API实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ensureWritable(length);</span><br><span class="line">    setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的<code>setBytes();</code>是由子类具体实现, 我们着重看一下<code>ensureWritable()</code>方法实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ensureWritable</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果要写入数据的字节小于0的话, 则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">"minWritableBytes: %d (expected: &gt;= 0)"</span>, minWritableBytes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// minWritableBytes &lt;= capacity() - writerIndex, 要写入的字节数小于可写的字节数则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s"</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceLeakDetector"><a href="#ResourceLeakDetector" class="headerlink" title="ResourceLeakDetector"></a>ResourceLeakDetector</h3><p><code>ResourceLeakDetector</code>用于检测内存泄漏. 它被所有ByteBuf实例共享.</p>
<h3 id="SwappedByteBuf"><a href="#SwappedByteBuf" class="headerlink" title="SwappedByteBuf"></a>SwappedByteBuf</h3><h2 id="AbstractReferenceCountedByteBuf"><a href="#AbstractReferenceCountedByteBuf" class="headerlink" title="AbstractReferenceCountedByteBuf"></a>AbstractReferenceCountedByteBuf</h2><h2 id="UnPooledHeapByteBuf"><a href="#UnPooledHeapByteBuf" class="headerlink" title="UnPooledHeapByteBuf"></a>UnPooledHeapByteBuf</h2><p>不使用对象池的基于堆内存分配的字节缓冲区. 每次IO读写的时候都会创建一个新的UnPooledHeapByteBuf.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Netty/">Netty</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/20/netty/ByteBuf/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/20/netty/ByteBuf/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/19/redis/Redis事务/" title="Redis事务" itemprop="url">Redis事务</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="普通事务"><a href="#普通事务" class="headerlink" title="普通事务"></a>普通事务</h2><p>首先介绍普通事务<code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code>:</p>
<ul>
<li><code>MULTI</code>告诉 redis 服务器开启一个事务</li>
<li><code>EXEC</code>告诉 redis 开始执行事务</li>
<li><code>DISCARD</code>告诉 redis 取消事务</li>
</ul>
<p><code>MULTI</code>命令执行后, redis进入事务状态,redis会持续缓存某个客户端的命令(其他客户端处于饥饿状态).<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis-multi.png" alt=""><br>当redis接受到客户端的<code>EXEC</code>命令后会开始执行刚才缓存在事务队列里的任务. <code>DISCARD</code> 会将事务队列清空.<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis-tranactions.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET a &quot;&quot;redis 127.0.0.1:7006&gt; SET a &quot;&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; SET a &quot;a&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt;  EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET b &quot;b&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; EXEC</span><br><span class="line">(error) ERR EXEC without MULTI</span><br><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET n &quot;n&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">redis 127.0.0.1:7006&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; SET c &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7006&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7006&gt; GET a</span><br><span class="line">&quot;a&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; GET b</span><br><span class="line">&quot;b&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; Get c</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br><span class="line">redis 127.0.0.1:7006&gt; GET n</span><br><span class="line">&quot;n&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用<code>MULTI</code>命令开启事务</li>
<li>输入一个错误的命令,点击回车,redis并没有报错,说明这个命令确实是被缓存起来了没有执行</li>
<li>使用<code>SET</code>命令将a设置为”a”</li>
<li>然后执行事务,我们看到俩条事务都执行完了,但是第一条命令并没有报错</li>
<li>然后再次使用<code>SET</code>命令将b设置为”b”</li>
<li>再次执行事务, 并不成功,提示我们要开启事务,说明事务一旦执行完就自动退出了</li>
<li>再次开启事务,然后使用<code>SET</code>命令将n设置为”n”</li>
<li>退出事务</li>
<li>接下来我们依次使用<code>GET</code>命令获取值,但是n取不到,说明退出事务确实没有执行事务队列里的命令<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis_transaction.png" alt=""></li>
</ol>
<h2 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h2><p>下来我们来看一下redis的watch机制<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch1.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch2.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch3.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/watch4.png" alt=""><br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/redis/redis_watched_keys.png" alt=""></p>
<h2 id="pipline机制"><a href="#pipline机制" class="headerlink" title="pipline机制"></a>pipline机制</h2><p>参考文章</p>
<ul>
<li><a href="http://redisbook.readthedocs.org/en/latest/feature/transaction.html" target="_blank" rel="external"></a></li>
<li><a href="http://ju.outofmemory.cn/entry/81786" target="_blank" rel="external"></a></li>
<li><a href="http://redisdoc.com/topic/transaction.html#id2" target="_blank" rel="external"></a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Reids/">Reids</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/19/redis/Redis事务/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/19/redis/Redis事务/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/19/JavaSE/java小常识/" title="JAVA 小常识" itemprop="url">JAVA 小常识</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="控制台乱码"><a href="#控制台乱码" class="headerlink" title="控制台乱码"></a>控制台乱码</h2><p>在windows系统里,我的cmd控制台的代码页是<code>65001(UTF)</code>,但是当我在指向java命令时却会发生乱码现象,只需要指向<code>chcp 936</code>这个命令,改变一下代码页就好了</p>
<h2 id="java命令"><a href="#java命令" class="headerlink" title="java命令"></a>java命令</h2><p><code>java  -jar ./tools-1.0-SNAPSHOT.jar</code> 从某个jar运行, mainfest文件必须指定MainClass属性,如果不指定的话,在运行<code>java</code>命令的时候就会产生 xxx.jar中没有主清单属性</p>
<p><code>java  -jar ./ App</code> 从指定的classpath下所有的jar中,寻找App主类运行</p>
<h2 id="获取周数"><a href="#获取周数" class="headerlink" title="获取周数"></a>获取周数</h2><p>通过<code>Calendar</code>我们可以知道某个日期处于一年中第几周<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(calendar.get(Calendar.WEEK_OF_YEAR));</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/19/JavaSE/java小常识/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/19/JavaSE/java小常识/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/memcached/Memcache/" title="memcached" itemprop="url">memcached</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>memcached是一个高性能内存对象缓存系统. 它基于libevent,可方便地拓展为任意大小, 而且对防止内存swap和使用非阻塞IO做了大量优化工作.</p>
<p>memcached内存分配：<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/memcached/20120314163538_438.png" alt=""><br>memcached默认情况下采用了名为Slab Allocator的机制分配、管理内存.</p>
<p>如果我们在启动memcached时没有指定<code>-m</code>参数的话, 那么memcached能使用的最大内存为默认的64M,但是memcached启动的时候并不会一次性就都分配出来,而是当发现memcached已被分配的内存不够用的时候才会进行申请. memcached申请内存时一次会申请一个Slab(默认为1M). 然后会将这一个Slab分成不同的Class, 每个Class内部都有N个大小相等的Chunk.每个chunk中都保存了一个item结构体、一对key value键值对.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Memcached依赖libevent,所以我们首先需要安装libevent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://jaist.dl.sourceforge.net/project/levent/libevent/libevent-2.0/libevent-2.0.22-stable.tar.gz</span><br><span class="line">tar -zxvf libevent-2.0.22-stable.tar.gz</span><br><span class="line">cd libevent-2.0.22-stable</span><br><span class="line">./configure --prefix=/usr &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>接下来安装Memcached<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://memcached.org/latest</span><br><span class="line">tar -zxvf memcached-1.x.x.tar.gz</span><br><span class="line">cd memcached-1.x.x</span><br><span class="line">./configure --with-libevent=/usr &amp;&amp; make &amp;&amp; make test &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></p>
<h2 id="memcached命令选项"><a href="#memcached命令选项" class="headerlink" title="memcached命令选项"></a><code>memcached</code>命令选项</h2><p>网络相关</p>
<ul>
<li><code>-s &lt;file&gt;</code> : Unix socket path to listen on (disables network support).</li>
<li><code>-a &lt;perms&gt;</code> : 当通过s选项创建socket的时候,我们可以通过-a选项指定创建socket使用的权限(权限为八进制).</li>
<li><code>-l &lt;ip_addr&gt;</code> : 监听的主机地址. 默认是本机任何可用的地址.</li>
<li><code>-d</code> : 以后台进程方式运行memcached</li>
<li><code>-u &lt;username&gt;</code> : memcached不能以root用户运行，如果当前用户为root, 我们需要通过该参数指定用户为root</li>
<li><code>-c &lt;num&gt;</code> : 设置最大同时连接数.(默认是1024).</li>
<li><code>-C</code> : 关闭CAS. (每个对象都会减少8bytes大小).</li>
<li><code>-p &lt;num&gt;</code> : 设置监听TCP端口号, 默认是11211.</li>
<li><code>-P</code> : 设置pid存储文件.</li>
<li><code>-U &lt;num&gt;</code> : 设置监听UDP端口号, 默认是11211, 0 表示关闭UDP监听.</li>
<li><code>-r</code> : 将最大的核心文件大小限制提升到允许的最大值.</li>
<li><code>-v</code> : 设置为verbose 同时会输出发生的errors 和warnings.</li>
<li><code>-i</code> : 打印memcached 和libevent 授权.</li>
<li><code>-R &lt;num&gt;</code> : 这个选项是设置服务器可以处理一个独立客户端连接顺序请求的数量,以防止产生其他客户端饥饿的情况. 一旦设置了这个值当服务器处理一个连接超过20个(默认值)请求之后,就会尝试处理其他的连接请求.</li>
</ul>
<p>内存相关</p>
<ul>
<li><code>-m &lt;num&gt;</code> : 设置对象存储能使用的最大内存(单位是MB,默认是64M)</li>
<li><code>-M</code> : 关闭对象存储所需内存超过最大内存时,自动删除缓存对象的功能. 如果memcached的配置内存达到最大值就不可再存储新的对象.</li>
<li><code>-f &lt;factor&gt;</code> : Class的成长因子(默认是1.25). 也就是说如果Class1是100B,那么Class2就是125B.</li>
<li><code>-n &lt;size&gt;</code> : key, value, and flags分配到的最小字节数(默认是48字节). 如果你的键值对的值都很小,你可以调低这个值来达到更高的性能. 如果你的成长因子比较大,那么你可以调高这个值,提升命中率.</li>
<li><code>-t &lt;threads&gt;</code> : 处理请求的线程数(默认是4). 这个选项只有memcached被编译的时候指定了线程开启才有用.</li>
<li><code>-k</code> : 锁定所有的分页内存. 在巨大的缓存系统中,使用这个选项是非常危险的,使用的使用要参考README文件和memcached homepage进行配置.</li>
<li><code>-L</code> : 尝试使用尽可能使用到的内存叶. 增加内存叶大小可以减少TLB未命中和提供性能. 为了可以从OS获得更大的内存页,memcached会在一个巨大的chunk上分配所有的item</li>
<li><code>-I &lt;size&gt;</code> : 指定slab page大小(默认是1mb,最小是1k, 最大是128m). 改变这个值会增加每个item大小的值.  使用-vv来查看更改后的值</li>
<li><code>-F</code> : 关闭<code>flush_all</code>命令.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached  -d -p 10021 -l 10.234.10.12 -u root -c 1024  -P ./memcached1.pid</span><br></pre></td></tr></table></figure>
<h2 id="java使用"><a href="#java使用" class="headerlink" title="java使用"></a>java使用</h2><p>我们使用spymemcached作为java客户端连接memcached. 在Maven项目中添加以下依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spymemcached<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后连接memcached<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemcachedClient client = <span class="keyword">new</span> MemcachedClient(<span class="keyword">new</span> InetSocketAddress(<span class="string">"10.234.10.12"</span>, <span class="number">10021</span>));</span><br></pre></td></tr></table></figure></p>
<p>通过这一行我们就成功的连接上了memcached.然后我们就可以使用spymemcached提供的大量api来操作memcached</p>
<h2 id="memcached信息统计"><a href="#memcached信息统计" class="headerlink" title="memcached信息统计"></a>memcached信息统计</h2><p>我们可以使用telnet命令直接连接memcached<code>telnet 127.0.0.1 10021</code>,然后输入下列命令查看相关信息</p>
<h3 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h3><p>统计memcached的各种信息</p>
<ul>
<li><code>STAT pid 20401</code> memcache服务器的进程ID</li>
<li><code>STAT uptime 47</code>  服务器已经运行的秒数</li>
<li><code>STAT time 1447835371</code> 服务器当前的unix时间戳</li>
<li><code>STAT version 1.4.24</code>  memcache版本</li>
<li><code>STAT libevent 2.0.22-stable</code> libevent版本</li>
<li><code>STAT pointer_size 64</code> 当前操作系统的指针大小（32位系统一般是32bit）</li>
<li><code>STAT rusage_user 0.002999</code> 进程的累计用户时间</li>
<li><code>STAT rusage_system 0.001999</code> 进程的累计系统时间</li>
<li><code>STAT curr_connections 10</code> 当前打开着的连接数</li>
<li><code>STAT total_connections 11</code> 从服务器启动以后曾经打开过的连接数</li>
<li><code>STAT connection_structures 11</code> 服务器分配的连接构造数</li>
<li><code>STAT reserved_fds 20</code></li>
<li><code>STAT cmd_get 0</code>  get命令（获取）总请求次数</li>
<li><code>STAT cmd_set 0</code>  set命令（保存）总请求次数</li>
<li><code>STAT cmd_flush 0</code></li>
<li><code>STAT cmd_touch 0</code></li>
<li><code>STAT get_hits 0</code>  总命中次数</li>
<li><code>STAT get_misses 0</code> 总未命中次数</li>
<li><code>STAT delete_misses 0</code> delete命令未命中次数</li>
<li><code>STAT delete_hits 0</code>  delete命令命中次数</li>
<li><code>STAT incr_misses 0</code>  incr命令未命中次数</li>
<li><code>STAT incr_hits 0</code>  incr命令命中次数</li>
<li><code>STAT decr_misses 0</code>  decr命令未命中次数</li>
<li><code>STAT decr_hits 0</code>  decr命令命中次数</li>
<li><code>STAT cas_misses 0</code>  cas命令未命中次数</li>
<li><code>STAT cas_hits 0</code>  cas命令命中次数</li>
<li><code>STAT cas_badval 0</code></li>
<li><code>STAT touch_hits 0</code>  touch命令命中次数</li>
<li><code>STAT touch_misses 0</code>  touch命令未命中次数</li>
<li><code>STAT auth_cmds 0</code></li>
<li><code>STAT auth_errors 0</code></li>
<li><code>STAT bytes_read 7</code> 总读取字节数（请求字节数）</li>
<li><code>STAT bytes_written 0</code> 总发送字节数（结果字节数）</li>
<li><code>STAT limit_maxbytes 67108864</code>   分配给memcache的内存大小（字节）</li>
<li><code>STAT accepting_conns 1</code></li>
<li><code>STAT listen_disabled_num 0</code></li>
<li><code>STAT threads 4</code>     当前线程数</li>
<li><code>STAT conn_yields 0</code></li>
<li><code>STAT hash_power_level 16</code>  hash等级</li>
<li><code>STAT hash_bytes 524288</code>  hash字节数</li>
<li><code>STAT hash_is_expanding 0</code>    </li>
<li><code>STAT malloc_fails 0</code>  分配失败次数</li>
<li><code>STAT bytes 0</code>   当前服务器存储items占用的字节数</li>
<li><code>STAT curr_items 0</code> 服务器当前存储的items数量</li>
<li><code>STAT total_items 0</code> 从服务器启动以后存储的items总数量</li>
<li><code>STAT expired_unfetched 0</code></li>
<li><code>STAT evicted_unfetched 0</code></li>
<li><code>STAT evictions 0</code> 为获取空闲内存而删除的items数（分配给memcache的空间用满后需</li>
<li><code>STAT reclaimed 0</code></li>
<li><code>STAT crawler_reclaimed 0</code></li>
<li><code>STAT crawler_items_checked 0</code></li>
<li><code>STAT lrutail_reflocked 0</code></li>
</ul>
<p>我们也可以使用java获取这些信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MemcachedClient client = <span class="keyword">new</span> MemcachedClient(<span class="keyword">new</span> InetSocketAddress(<span class="string">"10.234.10.12"</span>, <span class="number">10021</span>));</span><br><span class="line">client.getStats().entrySet().stream().forEach(entry -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">"Node : "</span> + entry.getKey());</span><br><span class="line">	entry.getValue().entrySet().stream().forEach(value -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">"    "</span> + value.getKey() + <span class="string">" : "</span> + value.getValue());</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="stats-reset"><a href="#stats-reset" class="headerlink" title="stats reset"></a>stats reset</h3><p>重新统计数据</p>
<h3 id="stats-slabs"><a href="#stats-slabs" class="headerlink" title="stats slabs"></a>stats slabs</h3><p>显示slabs信息，可以详细看到数据的分段存储情况</p>
<ul>
<li><code>STAT active_slabs 0</code></li>
<li><code>STAT total_malloced 0</code></li>
</ul>
<h3 id="stats-items"><a href="#stats-items" class="headerlink" title="stats items"></a>stats items</h3><p>显示slab中的item数目</p>
<h3 id="stats-cachedump-1-0"><a href="#stats-cachedump-1-0" class="headerlink" title="stats cachedump 1 0"></a>stats cachedump 1 0</h3><p>列出slabs第一段里存的KEY值</p>
<h3 id="STAT-evictions-0"><a href="#STAT-evictions-0" class="headerlink" title="STAT evictions 0"></a>STAT evictions 0</h3><p>表示要腾出新空间给新的item而移动的合法item数目</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/memcached/">memcached</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/memcached/Memcache/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/memcached/Memcache/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/日志工具/Elasticsearch 搜索/" title="Elasticsearch 搜索" itemprop="url">Elasticsearch 搜索</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>首先我们向库里准备一下数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JSONObject son = <span class="keyword">new</span> JSONObject();</span><br><span class="line">son.put(<span class="string">"name"</span>, <span class="string">"Jerry"</span>);</span><br><span class="line">son.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">son.put(<span class="string">"address"</span>, <span class="string">"baoding"</span>);</span><br><span class="line">son.put(<span class="string">"country"</span>, <span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"48"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"address"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"country"</span>, <span class="string">"china"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"son"</span>, son);</span><br><span class="line"></span><br><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx04"</span>)</span><br><span class="line">		.type(<span class="string">"type02"</span>)</span><br><span class="line">		.id(<span class="string">"02"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">client.index(indexRequest).get();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Leaf query clauses : 在指定的字段中搜索指定的值,例如使用<code>match</code>, <code>term</code> 或者 <code>range</code> 搜索时</li>
<li>Compound query clauses :</li>
</ul>
<p>首先我们来看一个简单的搜索案例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"idx01"</span>, <span class="string">"idx02"</span>)</span><br><span class="line">				.setTypes(<span class="string">"type01"</span>, <span class="string">"type02"</span>)</span><br><span class="line">				.setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</span><br><span class="line">				.setQuery(QueryBuilders.termQuery(<span class="string">"multi"</span>, <span class="string">"test"</span>))                 <span class="comment">// Query</span></span><br><span class="line">				.setPostFilter(QueryBuilders.rangeQuery(<span class="string">"age"</span>).from(<span class="number">12</span>).to(<span class="number">18</span>))     <span class="comment">// Filter</span></span><br><span class="line">				.setFrom(<span class="number">0</span>).setSize(<span class="number">60</span>).setExplain(<span class="keyword">true</span>)</span><br><span class="line">				.execute()</span><br><span class="line">				.actionGet();</span><br></pre></td></tr></table></figure></p>
<h3 id="Match-All-Query"><a href="#Match-All-Query" class="headerlink" title="Match All Query"></a>Match All Query</h3><p>最简单的搜索, 这个搜索将库中所有的文档都搜索出来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = matchAllQuery();</span><br></pre></td></tr></table></figure></p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="Match-Query"><a href="#Match-Query" class="headerlink" title="Match Query"></a>Match Query</h4><p>标准搜索, 包含模糊搜索, 短语搜索, 相近搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = matchQuery(</span><br><span class="line">				<span class="string">"age"</span>,	<span class="comment">// 搜索的字段</span></span><br><span class="line">				<span class="string">"18"</span>	<span class="comment">// 搜索的字段值</span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		SearchResponse searchResponse = client.prepareSearch(<span class="string">"idx04"</span>).setQuery(qb).execute().get();</span><br><span class="line">		searchResponse.getHits().forEach(hit -&gt; &#123;</span><br><span class="line">			System.out.println(hit.getSourceAsString());</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></p>
<p>结果为<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"address"</span>:<span class="string">"beijing"</span>,<span class="attr">"age"</span>:<span class="string">"18"</span>,<span class="attr">"country"</span>:<span class="string">"china"</span>,<span class="attr">"name"</span>:<span class="string">"Tom"</span>,<span class="attr">"son"</span>:&#123;<span class="attr">"address"</span>:<span class="string">"baoding"</span>,<span class="attr">"age"</span>:<span class="string">"18"</span>,<span class="attr">"country"</span>:<span class="string">"china"</span>,<span class="attr">"name"</span>:<span class="string">"Jerry"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Multi-Match-Query"><a href="#Multi-Match-Query" class="headerlink" title="Multi Match Query"></a>Multi Match Query</h4><p><code>match</code>搜索的多键版本, 会在多个指定字段中进行值匹配查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = multiMatchQuery(</span><br><span class="line">		<span class="string">"baoding"</span>,	<span class="comment">// 搜索值</span></span><br><span class="line">		<span class="string">"city"</span>, <span class="string">"country"</span>	<span class="comment">// 搜索的字段</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SearchResponse searchResponse = client.prepareSearch(<span class="string">"idx04"</span>).setQuery(qb).execute().get();</span><br><span class="line">searchResponse.getHits().forEach(hit -&gt; &#123;</span><br><span class="line">	System.out.println(hit.getSourceAsString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Common-Terms-Query"><a href="#Common-Terms-Query" class="headerlink" title="Common Terms Query"></a>Common Terms Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = commonTermsQuery(<span class="string">"name"</span>, <span class="string">"kimchy"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Query-String-Query"><a href="#Query-String-Query" class="headerlink" title="Query String Query"></a>Query String Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = queryStringQuery(<span class="string">"+kimchy -elasticsearch"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Simple-Query-String-Query"><a href="#Simple-Query-String-Query" class="headerlink" title="Simple Query String Query"></a>Simple Query String Query</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueryBuilder qb = simpleQueryStringQuery(<span class="string">"+kimchy -elasticsearch"</span>);</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日志工具/">日志工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/日志工具/Elasticsearch 搜索/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/日志工具/Elasticsearch 搜索/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/构建工具/gradle/" title="Gradle 初探" itemprop="url">Gradle 初探</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。</p>
<p>我使用idea创建一个gradle项目<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">group <span class="string">'wang.ming15.gradle'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.11'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="自定义任务"><a href="#自定义任务" class="headerlink" title="自定义任务"></a>自定义任务</h3><p>我们可以在task内部自由的使用groovy脚本<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task t1 &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'task1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者这种方式<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> t2 &lt;&lt; &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">'t2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>defaultTasks</code>我们可以使用这个命令定义一些默认的task : <code>defaultTasks &#39;t1&#39;, &#39;t2&#39;</code></p>
</blockquote>
<h3 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h3><p>我们使用<code>dependsOn</code>语法可以让一个任务依赖于另外一个任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task t2 &lt;&lt; &#123;</span><br><span class="line">        println <span class="string">'t2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">t3</span><span class="params">(dependsOn: t2)</span> </span>&#123;</span><br><span class="line">    println <span class="string">'t3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况下, t2任务会优先于t3任务执行</p>
<blockquote>
<p>需要注意的是, 如果t1依赖于t2, 那么当t2执行的时候会先执行t1</p>
</blockquote>
<h3 id="延迟依赖"><a href="#延迟依赖" class="headerlink" title="延迟依赖"></a>延迟依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">t3</span><span class="params">(dependsOn: <span class="string">'t4'</span>)</span> </span>&#123;</span><br><span class="line">    println <span class="string">'task3'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task t4 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在定义一个任务之后,再定义其所依赖的任务, 执行顺序仍然是t3 优先于t4</p>
<h3 id="任务操纵"><a href="#任务操纵" class="headerlink" title="任务操纵"></a>任务操纵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task t4 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task4'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task t5 &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'task5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t5.dependsOn t4</span><br></pre></td></tr></table></figure>
<p>task还有其他一些api,参考<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html" target="_blank" rel="external"></a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如前例所示我们已经使用过Gradle提供的插件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们的项目使用某个插件的时候, 这个项目里就包含了那个插件的任务依赖等等</p>
<h3 id="java插件任务"><a href="#java插件任务" class="headerlink" title="java插件任务"></a>java插件任务</h3><p>我们使用了java插件, 然后我们打开idea右侧的Gradle标签(我们会看到一些java插件自带的一些task.)：<br><img src="https://raw.githubusercontent.com/ming15/blog-website/images/gradle/gradle_ui.jpg" alt=""></p>
<p>命令含义参考<a href="http://wiki.jikexueyuan.com/project/gradle/java-package.html" target="_blank" rel="external"></a></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在Gradle编译脚本文件中我们还可以自如的使用文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File configFile = file(<span class="string">'src/config.xml'</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>file()</code>方法我们就可以打开一个文件.</p>
<h3 id="文件集合"><a href="#文件集合" class="headerlink" title="文件集合"></a>文件集合</h3><p>我们还可以使用<code>files()</code>方法创建文件集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileCollection fils = files(<span class="string">"t.txt"</span>, <span class="keyword">new</span> File(<span class="string">"d.txt"</span>), [<span class="string">"a.txt"</span>, <span class="string">'b.txt'</span>])</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用<code>+</code>, <code>-</code>符号增加或者删减文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileCollection filc = files(<span class="string">"t.txt"</span>, <span class="keyword">new</span> File(<span class="string">"d.txt"</span>), [<span class="string">"a.txt"</span>, <span class="string">'b.txt'</span>])</span><br><span class="line">FileCollection newFiles1 = filc + files(<span class="string">"c.txt"</span>)</span><br><span class="line">FileCollection newFiles2 = filc - files(<span class="string">"c.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用<code>as</code>将其转换为<code>Set</code>或者<code>List</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set set1 = filc.files</span><br><span class="line">Set set2 = filc as Set</span><br><span class="line">List list = filc as List</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/构建工具/">构建工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/构建工具/gradle/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/构建工具/gradle/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/日志工具/Elasticsearch 基本操作/" title="Elasticsearch 基本操作" itemprop="url">Elasticsearch 基本操作</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>使用Elasticsearch自带的客户端,添加maven依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意,依赖里的版本号要和Elasticsearch服务器的版本号一致</p>
</blockquote>
<h2 id="节点客户端"><a href="#节点客户端" class="headerlink" title="节点客户端"></a>节点客户端</h2><p>节点客户端以一个 无数据节点 的身份加入了一个集群。换句话说，它自身是没有任何数据的，但是他知道什么数据在集群中的哪一个节点上，然后就可以请求转发到正确的节点上并进行连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Settings.Builder settings = Settings.settingsBuilder()</span><br><span class="line">		.put(<span class="string">"http.enabled"</span>, <span class="keyword">false</span>)</span><br><span class="line">		.put(<span class="string">"path.home"</span>, <span class="string">"D:\\log\\elasticsearch-1.7.1"</span>)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">Node node = nodeBuilder()</span><br><span class="line">		.local(<span class="keyword">true</span>)</span><br><span class="line">		.settings(settings)</span><br><span class="line">		.node();</span><br><span class="line"></span><br><span class="line">Client client = node.client();</span><br></pre></td></tr></table></figure></p>
<h2 id="传输客户端"><a href="#传输客户端" class="headerlink" title="传输客户端"></a>传输客户端</h2><p>更加轻量的传输客户端可以被用来向远程集群发送请求。他并不加入集群本身，而是把请求转发到集群中的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = Settings.settingsBuilder().build();</span><br><span class="line"></span><br><span class="line">Client client = TransportClient.builder().settings(settings).build()</span><br><span class="line">		.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="索引数据"><a href="#索引数据" class="headerlink" title="索引数据"></a>索引数据</h2><p>我们可以使用客户端提供的<code>prepareIndex()</code>方法索引数据,也就是向Elasticsearch添加数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse indexResponse = client.prepareIndex(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>).setSource(jsonObject.toJSONString()).execute().actionGet();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"IndexResponse : "</span> + indexResponse.getVersion());</span><br></pre></td></tr></table></figure></p>
<p>结果输出为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse : <span class="number">01</span></span><br><span class="line">IndexResponse : idx01</span><br><span class="line">IndexResponse : type01</span><br><span class="line">IndexResponse : <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>idx01为索引值, type01为类型值, 01为id. 当我们重复的使用这三个值向 Elasticsearch 索引数据时是合法的,但是我们会得不到不同的版本号，也就是最好的输出的那个值</p>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>我们可以使用客户端提供的<code>prepareGet()</code>方法检索数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GetResponse getResponse = client.prepareGet(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">				.setOperationThreaded(<span class="keyword">false</span>)</span><br><span class="line">				.get();</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getVersion());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getSourceAsString());</span><br></pre></td></tr></table></figure></p>
<p>结果输出为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetResponse : <span class="number">01</span></span><br><span class="line">GetResponse : idx01</span><br><span class="line">GetResponse : type01</span><br><span class="line">GetResponse : <span class="number">4</span></span><br><span class="line">GetResponse : &#123;<span class="string">"age"</span>:<span class="string">"19"</span>,<span class="string">"name"</span>:<span class="string">"Tom"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>setOperationThreaded()</code>这个方法是用来设置, 操作是否在其他的线程中执行, 设置为true就是在其他的线程中执行. 注意该操作仍然是异步执行的.</p>
</blockquote>
<h4 id="检索多个数据"><a href="#检索多个数据" class="headerlink" title="检索多个数据"></a>检索多个数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.prepareMultiGet()</span><br><span class="line">	  .add(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">	  .add(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"02"</span>)</span><br><span class="line">	  .get()</span><br><span class="line">	  .forEach(response -&gt; System.out.println(JSON.toJSONString(response, <span class="keyword">true</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DeleteResponse deleteResponse = client.prepareDelete(<span class="string">"idx01"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>).get();</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"DeleteResponse : "</span> + deleteResponse.getVersion());</span><br></pre></td></tr></table></figure>
<p>结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DeleteResponse : <span class="number">01</span></span><br><span class="line">DeleteResponse : idx01</span><br><span class="line">DeleteResponse : type01</span><br><span class="line">DeleteResponse : <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们再检索一边数据的话,会得到结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetResponse : <span class="number">01</span></span><br><span class="line">GetResponse : idx01</span><br><span class="line">GetResponse : type01</span><br><span class="line">GetResponse : -<span class="number">1</span></span><br><span class="line">GetResponse : <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<p>说明那个文档已经被删除了</p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>我们可以使用<code>UpdateRequest</code>或者<code>prepareUpdate()</code>方法来对数据进行更新<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest();</span><br><span class="line">updateRequest.index(<span class="string">"idx01"</span>);</span><br><span class="line">updateRequest.type(<span class="string">"type01"</span>);</span><br><span class="line">updateRequest.id(<span class="string">"01"</span>);</span><br><span class="line">updateRequest.doc(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">client.update(updateRequest).get();</span><br></pre></td></tr></table></figure></p>
<p>当我们在通过<code>get</code>获取数据的时候,会发现数据已经发生了变化</p>
<p>更新还有一个有用的功能,就是在更新的时候能实现如果有就更新,没有就插入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx01"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line"></span><br><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest()</span><br><span class="line">		.index(<span class="string">"idx01"</span>)</span><br><span class="line">		.type(<span class="string">"type02"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.doc(jsonObject.toJSONString())</span><br><span class="line">		.upsert(indexRequest);</span><br><span class="line"></span><br><span class="line">client.update(updateRequest).get();</span><br></pre></td></tr></table></figure></p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>elasticsearch内置的客户端中还有批处理功能,但是批处理只支持增删改, 不支持查询的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">BulkRequestBuilder bulkRequest = client.prepareBulk();</span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">jsonObject.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.source(jsonObject.toJSONString());</span><br><span class="line">bulkRequest.add(indexRequest);</span><br><span class="line"></span><br><span class="line">UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>)</span><br><span class="line">		.doc(jsonObject.toJSONString());</span><br><span class="line">bulkRequest.add(updateRequest);</span><br><span class="line"></span><br><span class="line">DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest()</span><br><span class="line">		.index(<span class="string">"idx02"</span>)</span><br><span class="line">		.type(<span class="string">"type01"</span>)</span><br><span class="line">		.id(<span class="string">"01"</span>);</span><br><span class="line">bulkRequest.add(deleteRequest);</span><br><span class="line">BulkResponse bulkResponse = bulkRequest.get();</span><br><span class="line">bulkResponse.forEach(response -&gt; System.out.println(response.getId()));</span><br><span class="line"></span><br><span class="line">GetResponse getResponse = client.prepareGet(<span class="string">"idx02"</span>, <span class="string">"type01"</span>, <span class="string">"01"</span>)</span><br><span class="line">		.setOperationThreaded(<span class="keyword">false</span>)</span><br><span class="line">		.get();</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getId());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getIndex());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getType());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getVersion());</span><br><span class="line">System.out.println(<span class="string">"GetResponse : "</span> + getResponse.getSourceAsString());</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日志工具/">日志工具</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/日志工具/Elasticsearch 基本操作/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/日志工具/Elasticsearch 基本操作/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/16/redis/Redis_SortedSet/" title="Redis SortedSet" itemprop="url">Redis SortedSet</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2015-11-15T16:00:00.000Z" itemprop="datePublished"> Published 2015-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>在命令行中使用Redis客户端连接Redis服务器： <code>redis-cli -h 127.0.0.1 -p 7000</code></p>
</blockquote>
<h2 id="增加成员"><a href="#增加成员" class="headerlink" title="增加成员"></a>增加成员</h2><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><p>语法：<code>ZADD key score member [[score member] [score member] ...]</code>.   </p>
<ul>
<li><code>ZADD</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>score</code>  值 (可以是整数值或双精度浮点数)</li>
<li><code>member</code> 键</li>
</ul>
<p>这个命令也就是将键值对(member score)插入到有序集合key中. 如果集合不存在就创建一个集合,如果键已经存在就代替原来的值.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZADD test1 10 a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h2 id="修改成员"><a href="#修改成员" class="headerlink" title="修改成员"></a>修改成员</h2><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><p>语法<code>ZINCRBY key increment member</code></p>
<ul>
<li><code>ZINCRBY</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>increment</code>  score值的增量</li>
<li><code>member</code>  针对哪个成员进行改变</li>
</ul>
<p>这个命令就是对某个成员进行增加或者减少(通过负数实现). (member 成员的新 score 值,以字符串形式表示)</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd test1 23 t</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:7006&gt; ZINCRBY test1 10 t</span><br><span class="line">&quot;33&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; zincrby test1 -20 t</span><br><span class="line">&quot;13&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h2><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><p>语法<code>ZREM key member [member ...]</code></p>
<ul>
<li><code>ZREM</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code> 成员名</li>
</ul>
<p>移除有序集 key 中的一个或多个成员,不存在的成员将被忽略.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zcard test1</span><br><span class="line">(integer) 7</span><br><span class="line">redis 127.0.0.1:7006&gt; zrem test1 a</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:7006&gt; zcard test1</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h3><p>语法<code>ZREMRANGEBYRANK key start stop</code></p>
<ul>
<li><code>ZREMRANGEBYRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>移除有序集 key 中,指定排名(rank)区间内的所有成员.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREMRANGEBYRANK test1 1 2 # 将第二名和第三名移除</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h3><p>语法<code>ZREMRANGEBYSCORE key min max</code></p>
<ul>
<li><code>ZREMRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>将集合key里的score值区间为[min,max]的成员删除</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREMRANGEBYSCORE test1 10 20</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h3><p>语法<code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p>
<ul>
<li><code>ZUNIONSTORE</code> redis命令</li>
<li><code>destination</code> 有序集合名</li>
<li><code>numkeys</code>  需要合并的集合数量</li>
<li><code>key</code>  需要合并的集合</li>
<li><code>WEIGHTS</code>  指定该值,则在合并的时候,对每个score值都乘以该元素</li>
<li><code>AGGREGATE</code> 指定并集的结果集的聚合方式</li>
</ul>
<p>对多个集合采取并集</p>
<blockquote>
<p>AGGREGATE有三种值：A. SUM,将相同的成员的score相加. MIN,取相同成员的最小score值. MAX,取相同成员的最大score值</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd a 10 a1 20 a2 30 a3 40 a4 50 a5</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:7006&gt; zadd b 11 b1 12 b2 13 b3 14 b4 15 b5</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:7006&gt; ZUNIONSTORE c 2 a b</span><br><span class="line">(integer) 10</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGE c 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;a1&quot;</span><br><span class="line"> 2) &quot;10&quot;</span><br><span class="line"> 3) &quot;b1&quot;</span><br><span class="line"> 4) &quot;11&quot;</span><br><span class="line"> 5) &quot;b2&quot;</span><br><span class="line"> 6) &quot;12&quot;</span><br><span class="line"> 7) &quot;b3&quot;</span><br><span class="line"> 8) &quot;13&quot;</span><br><span class="line"> 9) &quot;b4&quot;</span><br><span class="line">10) &quot;14&quot;</span><br><span class="line">11) &quot;b5&quot;</span><br><span class="line">12) &quot;15&quot;</span><br><span class="line">13) &quot;a2&quot;</span><br><span class="line">14) &quot;20&quot;</span><br><span class="line">15) &quot;a3&quot;</span><br><span class="line">16) &quot;30&quot;</span><br><span class="line">17) &quot;a4&quot;</span><br><span class="line">18) &quot;40&quot;</span><br><span class="line">19) &quot;a5&quot;</span><br><span class="line">20) &quot;50&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZUNIONSTORE e 2 c a</span><br><span class="line">(integer) 10</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGE e  0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;b1&quot;</span><br><span class="line"> 2) &quot;11&quot;</span><br><span class="line"> 3) &quot;b2&quot;</span><br><span class="line"> 4) &quot;12&quot;</span><br><span class="line"> 5) &quot;b3&quot;</span><br><span class="line"> 6) &quot;13&quot;</span><br><span class="line"> 7) &quot;b4&quot;</span><br><span class="line"> 8) &quot;14&quot;</span><br><span class="line"> 9) &quot;b5&quot;</span><br><span class="line">10) &quot;15&quot;</span><br><span class="line">11) &quot;a1&quot;</span><br><span class="line">12) &quot;20&quot;</span><br><span class="line">13) &quot;a2&quot;</span><br><span class="line">14) &quot;40&quot;</span><br><span class="line">15) &quot;a3&quot;</span><br><span class="line">16) &quot;60&quot;</span><br><span class="line">17) &quot;a4&quot;</span><br><span class="line">18) &quot;80&quot;</span><br><span class="line">19) &quot;a5&quot;</span><br><span class="line">20) &quot;100&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h3><p>语法<code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></p>
<ul>
<li><code>ZINTERSTORE</code> redis命令</li>
<li><code>destination</code> 有序集合名</li>
<li><code>numkeys</code>  需要合并的集合数量</li>
<li><code>key</code>  需要合并的集合</li>
<li><code>WEIGHTS</code>  指定该值,则在合并的时候,对每个score值都乘以该元素</li>
<li><code>AGGREGATE</code> 指定并集的结果集的聚合方式</li>
</ul>
<p>对多个集合采取交集</p>
<blockquote>
<p>AGGREGATE有三种值：A. SUM,将相同的成员的score相加. MIN,取相同成员的最小score值. MAX,取相同成员的最大score值</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zadd h 1 a1 2 a2</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:7006&gt; ZINTERSTORE j 2 e h</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:7006&gt; zrange j 0 -1 WITHSCORES</span><br><span class="line">1) &quot;a1&quot;</span><br><span class="line">2) &quot;21&quot;</span><br><span class="line">3) &quot;a2&quot;</span><br><span class="line">4) &quot;42&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取集合数量"><a href="#获取集合数量" class="headerlink" title="获取集合数量"></a>获取集合数量</h2><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><p>语法<code>ZCARD key</code></p>
<ul>
<li><code>ZCARD</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
</ul>
<p>获得集合大小</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZCARD test1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><p>语法<code>ZCOUNT key min max</code></p>
<ul>
<li><code>ZCOUNT</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)<br>这个命令就是统计score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
</li>
</ul>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZCOUNT test 10 50</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></p>
<h2 id="获取集合列表"><a href="#获取集合列表" class="headerlink" title="获取集合列表"></a>获取集合列表</h2><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><p>语法<code>ZRANGE key start stop [WITHSCORES]</code></p>
<ul>
<li><code>ZRANGE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code>  同时也返回成员对应的值</li>
</ul>
<p>返回有序集key中指定区间内的成员,得到的成员是递增(从小到大)排序的.</p>
<blockquote>
<p>索引从0开始, 如果索引为负数则代表从倒序,即-1代表最后一个,-2代表倒数第二个. ( <code>ZRANGE test1 0 -1 WITHSCORES</code>显示整个有序集成员)</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; zrange test1 0 3</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;t&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; zrange test1 0 3 WITHSCORES</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;t&quot;</span><br><span class="line">6) &quot;13&quot;</span><br><span class="line">7) &quot;b&quot;</span><br><span class="line">8) &quot;20&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h3><p>语法<code>ZREVRANGE key start stop [WITHSCORES]</code></p>
<ul>
<li><code>ZREVRANGE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>start</code> 开始索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>stop</code>  结束索引从0开始(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
</ul>
<p>和<code>ZRANGE</code>命令不同的是它是从按 score 值递减(从大到小)来排列,其他和ZRANGE命令一样</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANGE test1 1 100</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;f&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><p>语法<code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></p>
<ul>
<li><code>ZRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
<li><code>LIMIT offset count</code></li>
</ul>
<p>返回有序集key中,score值介于 [min, max]之间(闭区间)的成员,按 score 值递增(从小到大)次序排列</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 10 56 WITHSCORES	# 闭区间</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;10&quot;</span><br><span class="line"> 3) &quot;c&quot;</span><br><span class="line"> 4) &quot;12&quot;</span><br><span class="line"> 5) &quot;t&quot;</span><br><span class="line"> 6) &quot;13&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;20&quot;</span><br><span class="line"> 9) &quot;f&quot;</span><br><span class="line">10) &quot;42&quot;</span><br><span class="line">11) &quot;d&quot;</span><br><span class="line">12) &quot;56&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 (10 (56 WITHSCORES # 开区间</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;12&quot;</span><br><span class="line">3) &quot;t&quot;</span><br><span class="line">4) &quot;13&quot;</span><br><span class="line">5) &quot;b&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;f&quot;</span><br><span class="line">8) &quot;42&quot;</span><br><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYSCORE test1 10 56 WITHSCORES LIMIT 0 3 # 从第一个成员开始选择三个成员</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;12&quot;</span><br><span class="line">5) &quot;t&quot;</span><br><span class="line">6) &quot;13&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><p>语法<code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></p>
<ul>
<li><code>ZREVRANGEBYSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>WITHSCORES</code> 输出score值</li>
<li><code>LIMIT offset count</code>  </li>
</ul>
<p>除了成员按 score 值递减的次序排列这一点外, ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样.</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANGE test1 1 100 WITHSCORES</span><br><span class="line"> 1) &quot;f&quot;</span><br><span class="line"> 2) &quot;42&quot;</span><br><span class="line"> 3) &quot;d&quot;</span><br><span class="line"> 4) &quot;40&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;20&quot;</span><br><span class="line"> 9) &quot;a&quot;</span><br><span class="line">10) &quot;10&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h3><p>语法<code>ZRANGEBYLEX key min max [LIMIT offset count]</code></p>
<ul>
<li><code>ZRANGEBYLEX</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>min</code>最小值(默认闭区间,使用<code>(</code>表示开区间)</li>
<li><code>max</code> 最大值(默认闭区间,使用<code>(</code>表示开区间)</li>
</ul>
<p>根据成员进行排序而不是根据score值排序,然后返回[min, max]区间内的成员</p>
<blockquote>
<p><code>+</code>和<code>-</code>在 min 参数以及 max 参数中表示正无限和负无限.</p>
</blockquote>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANGEBYLEX test1 10 30</span><br></pre></td></tr></table></figure></p>
<h2 id="查询某个成员"><a href="#查询某个成员" class="headerlink" title="查询某个成员"></a>查询某个成员</h2><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><p>语法<code>ZRANK key member</code></p>
<ul>
<li><code>ZRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code>  成员值</li>
</ul>
<p>返回有序集 key 中成员 member 的排名.其中有序集成员按 score 值递增(从小到大)顺序排列.（排名从0开始）</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZRANK test1 d</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure></p>
<h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h3><p>语法<code>ZREVRANK key member</code></p>
<ul>
<li><code>ZREVRANK</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code>  成员值<br>除了成员按 score 值递减的次序排列这一点外, ZREVRANK 命令的其他方面和 ZRANK 命令一样.</li>
</ul>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZREVRANK test1 c</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p>
<h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><p>语法<code>ZSCORE key member</code></p>
<ul>
<li><code>ZSCORE</code> redis命令</li>
<li><code>key</code> 有序集合名</li>
<li><code>member</code> 成员</li>
</ul>
<p>返回有序集 key 中,成员 member 的 score 值.</p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; ZSCORE test1 a</span><br><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Reids/">Reids</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/16/redis/Redis_SortedSet/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/16/redis/Redis_SortedSet/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/6/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="ming15" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Groovy/" title="Groovy">Groovy<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Haskell/" title="Haskell">Haskell<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JMH/" title="JMH">JMH<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java工具/" title="Java工具">Java工具<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Netty/" title="Netty">Netty<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Php/" title="Php">Php<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reids/" title="Reids">Reids<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCP-IP/" title="TCP IP">TCP IP<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ZooKeeper/" title="ZooKeeper">ZooKeeper<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/asm/" title="asm">asm<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/guice/" title="guice">guice<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/http客户端/" title="http客户端">http客户端<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/http服务器/" title="http服务器">http服务器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/memcached/" title="memcached">memcached<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/mgits/" title="mgits">mgits<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/mycat/" title="mycat">mycat<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/python2/" title="python2">python2<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发编程/" title="并发编程">并发编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/序列化工具/" title="序列化工具">序列化工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志工具/" title="日志工具">日志工具<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/构建工具/" title="构建工具">构建工具<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www1.vertx3.cn" target="_blank" title="vertx3">vertx3</a>
            
          </li>
        
    </ul>
</div>

  

<div class="doubanshow">
<p class="asidetitle">Douban Show</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/xxxyy/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3253370782&verifier=e9ca895b&dpc=1"></iframe>
</div>


  

<div class="lofter">
<p class="asidetitle">Lofter</p>

 <iframe width="100%" height="39" class="share_self"  frameborder="0" scrolling="no" src="http://ming15.lofter.com/"></iframe>
</div>




</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 博客,我选择重构 <br/>
			重构使事情变得更美,更加正确</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3253370782" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/ming15" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xxxyy" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/ming15" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="ming15">ming15</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"wanggnim"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e8fca440159a2125668804e46682db4' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
