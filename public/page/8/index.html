
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ming15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming15">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ming15">
<meta property="og:url" content="http://www.ming15.wang/page/8/index.html">
<meta property="og:site_name" content="ming15">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ming15">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="ming15" type="application/atom+xml">
    
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="ming15" title="ming15"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ming15">ming15</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 17728547076946147000 ><input type="text" name="q" size="30" placeholder="Search"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/运行时数据区/" title="运行时数据区" itemprop="url">运行时数据区</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><p>每当我们创建一个线程的时候, 都会JVM都会附带着创建一个本线程私有的PC寄存器和虚拟机栈. PC寄存器用于存放当前线程执行的字节码指令(线程当前方法)地址. 字节码解释器通过修改寄存器里的值使线程完成下一个指令的执行. 分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个寄存器完成. 在一个单CPU的环境中, 一个多线程的程序通过轮流切换线程完成多线程运行. 那么在切换线程的时候, 被切换的线程对应的寄存器里的值被保存了下来, 当线程再切换回来的时候,线程得以继续运行.</p>
<blockquote>
<p>PC寄存器是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.</p>
</blockquote>
<h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p>每当我们创建一个线程对象的的时候</p>
<ul>
<li>与线程同时创建,用于存储栈帧. 它的生命周期与线程相同.</li>
<li>每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表,操作数栈,动态连接,方法出口等信息.</li>
</ul>
<p>在java虚拟机中.对这个区域规定了俩种异常情况:</p>
<ol>
<li>如果请求的栈深度大于虚拟机所允许的深度,抛出StackOverflowError.<br></li>
<li>如果虚拟机可以动态扩展,当拓展时无法申请到足够的内存时会抛出OutOfMemoryError异常</li>
</ol>
<p>位于通用 RAM 中,存放基本类型的数据和对象的引用,但对象本身不存放在栈中,而是存放在堆中 .在堆中产生了一个数组或对象后,还可以在栈中定义一个特殊的变量,让栈中这个变量的取值等于数组或对象在堆内存中的首地址,栈中的这个变量就成了数组或对象的引用变量 .</p>
<h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><ul>
<li>是供各个线程共享的运行时内存</li>
<li>所有类实例和数组对象分配内存的地方</li>
<li>在虚拟机创建的时候该区域就创建了</li>
<li>存储了内存管理系统(GC)</li>
<li>java虚拟机中规定,java堆可以处于物理上不连续的内存空间中,逻辑上是连续的即可.在设计时,既可以设计成固定大小的,也可以设计成可拓展的.</li>
<li>如果在堆内中没有内存完成实例分配,而且堆无法再拓展时,会抛出OutOfMemoryError</li>
<li>需要说明的一点的是,随着JIT编译器的发展和逃逸分析技术的逐渐成熟,栈上分配,标量替换优化技术将会导致一些变化,所有的对象在堆上分配也不是那么绝对了</li>
</ul>
<p>简单介绍一下,java堆内部分配: 由于现在GC收集器基本都是采用的分代收集算法,所以java堆还可以细分为:新生代和老年代.分的再细一点还有Eden空间,From Survivor空间,To Sruvivor空间. 如果从内存分配的角都看,线程共享的java对可能还可能划分出多个线程私有的分配缓冲区.</p>
<p>一种通用性的内存池 (也存在于 RAM 中)， 用于存放所以的 JAVA 对象. Java 的堆是一个运行时数据区 , 对象被存储在堆中 . 这些对象通过 new 等指令建立， 它们不需要程序代码 来显式的释放. 因此， 在堆里分配存储有很大的灵活性 . 堆的缺点是,由于要在运行时动态分配内存,存取速度较慢 .</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>虚拟机启动时创建</li>
<li>供各个线程共享的运行时内存</li>
<li>存储了每个类的结构信息, 运行时常量池, 静态变量,即时编译器编译后的代码, 方法数据, 构造函数, 普通方法的字节码内容</li>
<li>java虚拟机规范对这个区域的限制非常宽松,除了和java堆一样不需要连续的内存外,和可以实现固定大小或者可拓展的之外,还可以选择不实现垃圾收集.(在HotSop虚拟机中一般喜欢称这个区域为永久代)并非数据进入永久代就像其名字一样”永久存在”. 这个区域的回收目标是针对常量池的回收和对类型的卸载.</li>
<li>当方法区无法满足内存分配需求时,将抛出OutOfMemoryError.</li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分.</p>
<p>Class文件中除了有类的版本,字段,方法,接口等信息外,还有一项信息是常量池,用于存储编译器产生的各种字面量和符号引用.这部分内容将在类加载后存放到方法区的运行时常量池中.</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,java语言并不要求常量一定只能在编译器产生,也就是并非预置入Class文件常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入常量池,这种特性被用到比较多的便是<code>String#intern()</code>在加载类和接口到虚拟机后就创建对应的常量池,其是Class文件中每个类或者接口常量池表的运行时表示.</p>
<p>它包含了从编译期克制的数值字面量到必须到运行期解析后才能获得的方法或字段引用</p>
<p>java 中的常量池,是为了方便快捷地创建某些对象而出现的,当需要一个对象时,就可以从池中取一个出来(如果池中没有则创建一个)， 则在需要重复创建相等变量时节省了很多时间 . 常量池其实也就是一个内存空间,不同于使用 <code>new</code> 关键字创建的对象所在的堆空间 . 常量池用来存放在编译期间就可以确定的数据,比如字符串等类型</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>在新生代,常规应用进行一次垃圾收集,一般可以收回70%-95%的空间,而永久代(方法区)远低于此.</p>
<p>永久代的垃圾回收主要是回收俩部分内容:</p>
<ul>
<li>废弃常量: 回收废弃常量与回收java堆中的对象非常类似.以常量池字面量回收为例,如果一个字符串”ABC”已经进入了常量池,但是当前系统中没有任何一个String对象是叫做”ABC”的,换句话说也就是没有任何String对象引用这个字面量,也没有其他地方引用这个字面量,如果这个时候发生内存回收,而且必要的话,这个”ABC”常量会被清除出常量池.常量池中的其他类(皆苦),方法,字段的符号引用也与此类似.</li>
<li>无用的类</li>
</ul>
<p>判断一个类是否是无用的类条件要苛刻的多. 要同时满足下面三个条件:</p>
<ol>
<li>该类的所有实例都已经被回收,也就是java堆中不存在该类的实例.<br.></br.></li>
<li>加载该类的ClassLoader已经被回收.<br.></br.></li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类.</li>
</ol>
<p>虚拟机可以对满足上面三个条件的类进行回收,这里说的仅仅是可以,而不是和对象一样,不使用了就必然回收.是否对类进行回收HotSpot虚拟机提供了-Xnoclassgc参数进行控制,还可以使用<code>-verbose:Class</code>及<br><code>-XX:+TraceClassLoading</code>,<code>-XX:+TraceClassUnLoading</code>查看类的加载和卸载信息.<code>-verbose:Class</code>和<code>-XX:+TraceClassLoading</code>可以在Product版的虚拟机中使用,但是<code>-XX:+TraceClassLoading</code>参数需要fastdebug版的虚拟机支持</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>直接内存并不是虚拟机运行时数据区的一部分,也不是java虚拟机规范中定义的内存区域,但是这部分内存也被频繁使用,而且也会导致OutOfMemoryError异常出现</li>
<li>在JDK1.4引入的NIO类,一种基于通道与缓冲区的I/O方式,它可以利用Native函数库直接分配堆外内存,然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了java堆和Native堆中来回复制数据.</li>
<li>显然本机直接内存的分配不会收到java堆大小的限制,但是既然是内存,则肯定会收到本机总内存(包括RAM及SWAP区或者分页文件)及处理器寻址空间的限制.一般在配置虚拟机参数时,会genuine实际内存设置-Xmx等参数信息,但经常会忽略掉直接内存,使得各个区域的总和大于物理内存限制,从而导致动态拓展时,出现OutOfMemoryError.</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>用来支持native方法</li>
</ul>
<h2 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h2><p>静态存储里存放程序运行时一直存在的数据 . 可用关键字 static 来标识一个对象的特定元素是静态的,被static 修饰的成员变量和成员方法独立于该类的任何对象,它不依赖类特定的实例,被类的所有实例共享 . 但 JAVA 对象本身不会存放在静态存储空间里,而只是把对象中的一些特殊元素放置这里 .</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><ul>
<li>用来存储数据和部分过程结果的数据结构, 同时也用来处理动态连接, 方法返回值和异常分派</li>
<li>随着方法的调用而创建,随着方法的调用结束而销毁. (结束也包含异常情况)</li>
<li>其内存分配在虚拟机栈之中, 每一个栈帧都有自己的本地变量表, 操作数栈, 和指向当前方法所属的类的运行时常量池.</li>
</ul>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><ul>
<li>其长度在编译器决定</li>
<li>一个局部变量可以保存boolean, byte, char, short, int, float, reference,returnAddress类型的数据.俩个局部变量可以保存一个long或者double类型的变量.</li>
<li>java虚拟机使用局部变量表来完成方法调用时的参数传递. 当调用一个方法时, 它的参数将会传递至从0开始的连续的变量表位置上.</li>
<li>当调用一个实例方法时,第0个局部变量一定是用来存储被调用的实例方法所在的对象的引用.后续的其他参数将会传递至从1开始的连续的局部变量表位置上</li>
<li>虚拟机通过索引定位的方式使用局部变量表,索引值的范围是从0开始到局部变量表最大的Slot数量.</li>
</ul>
<p>局部变量表中的Slot是可重用的,方法体定义的变量,其作用域并不一定会覆盖整个方法体,如果当前字节码PC计数器的值已经超出了某个变量的作用域,那么这个变量对应的Slot就可以交给其他变量使用. 这样的设计不仅仅是为了节省栈空间,在某些情况下Slot的复用会直接影响到系统的垃圾收集行为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectSlot1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectSlot2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectSlot3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectSlot4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行时,加上 -verbose:gc 参数,来查看垃圾收集过程.</span><br></pre></td></tr></table></figure></p>
<p>运行结果,CollectSlot1和CollectSlot2并没有执行垃圾回收. 而CollectSlot3却执行了垃圾收集</p>
<blockquote>
<p>运行分析<br>placeholder能否被回收的根本原因就是:局部变量表中的Slot是否还存有关于placeholder数组对象的引用.在CollectSlot2中,代码虽然已经离开了placeholder的作用域,但在此之后,没有任何局部变量表的读写操作,placeholder原本所占用的Slot还没有被其他变量所复用,所以作为GC Roots一部分的局部变量表仍然保持着对它的关联.</p>
</blockquote>
<p>这种关联没有被及时打断,在绝大部分情况下影响都很轻微.但如果遇到一个方法,其后面的代码有一些耗时很长的操作,而前面又定义了占用了大量内存,实际上已经不会再被使用的变量,手动将其设置为null值就不是一个毫无意义的操作.</p>
<p>这种操作可以作为一种在极特殊情景(对象内存占用大,此方法的栈帧长时间不能被回收,方法调用次数达不到JIT的编译条件)下的奇技来使用. 但不应当对赋null值操作有过多的依赖.</p>
<p>应该以恰当的作用域来控制变量回收时间才是最优雅的解决方法.(如CollectSlot3)</p>
<p>另外赋null值的操作在经过虚拟机JIT编译器优化之后会被消除掉,这时候将变量设置为null实际上是没有意义的.字节码被编译为本地代码后,对GC Roots的枚举也与解释执行时期有所差别,CollectSlot2在经过JIT编译后,System.gc() 执行时就可以正确回收掉内存,而无需写成CollectSlot3</p>
<p>关于局部变量表,还有一点可能会对实际开发产生影响,就是局部变量表不像前面介绍的类变量那样存在”准备阶段”.类变量有俩次赋初始值的过程,一次在准备阶段,赋予系统初始值.另外一次在初始化阶段,赋予程序员定义的初始化. 因此即使在初始化阶段程序员没有为类变量赋值也没关系,类变量仍然具有一个确定的初始值. 但是局部变量就不一样了,如果一个局部变量定义了但没有赋初始值是不能使用的. 所以 CollectSlot4 并不能运行,编译器能在编译器期间检查并提示这一点.</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ul>
<li>每个栈帧内部都包含一个称为操作数栈先进后出栈.</li>
<li>其栈帧长度在编译器决定.</li>
<li>栈帧在刚创建的时候, 操作数栈是空的, java虚拟机提供了一系列指令从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中.</li>
<li>也提供了一些列指令从操作数栈取走, 操作数据, 以及把结果重新入栈</li>
<li>在调用方法时, 操作数栈也用来准备调用方法的参数以及接受方法返回结果.</li>
<li>每个操作数栈的位置可以保存一个java虚拟机定义的任意数据类型的值,包括long和double类型</li>
<li>在任意时刻,操作数都会有一个确定的栈深度, 一个long或者double类型的数据会占用俩个单位的栈深度, 其他类型占用一个单位的栈深度</li>
</ul>
<p>操作数栈也称为操作栈,它是一个先入后出栈.同局部变量表一样,操作数栈的最大深度也是在编译的时候被写入到Code属性的max_stacks数据项之中的.操作数栈的每一个元素都可以是任意的java数据类型,包括long和double. 32位的数据类型所占的栈容量为1,64位数据类型所占的栈容量为2.在方法执行的时候,操作数栈的深度都不会超过在max_stacks数据项中设定的最大值.</p>
<p>当一个方法开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令向操作数栈写入和提取内容,也就是入栈和出栈操作.例如:在做算术运算的时候是通过操作数栈来进行的,又或者在调用其他方法的时候是通过操作数栈来进行参数传递的.</p>
<p>举个例子,整数加法的字节码指令iadd在运行的时候要求操作数栈中最接近栈顶的俩个元素已经存入了俩个int型的数值,当执行这个指令时,会将这俩个int值出栈并相加,然后将相加的结果入栈.</p>
<p>操作数栈元素的数据类型必须与字节码指令的序列严格匹配,在编译程序代码的时候,编译器要严格保证这一点,在类校验阶段的数据流分析中还要再次验证这一点.再以上的iadd指令为例,这个指令用于整数相加,它在执行时,最接近栈顶的俩个元素的类型必须是int性,不能出现一个long和一个float使用iadd命令相加的情况.</p>
<p>另外,在概念模型中,俩个栈帧为虚拟机栈的元素,相互之间是完全独立的.但是大多数虚拟机的实现里都会做一些优化处理,令俩个栈帧出现一部分重叠.让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起,这样在进行方法调用时就可以共有一部分数据,而无需进行额外的参数复制传递:</p>
<p><img src="" alt="俩个栈帧之间的数据共享"></p>
<p>java虚拟机解释执行引擎称为”基于栈的执行引擎”,其中所指的栈就是操作数栈.</p>
<h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><ul>
<li>每个栈帧内部都包含一个指向运行时常量池的引用来支持当前方法的代码实现动态连接.</li>
<li>在Class文件中,描述一个方法调用其他方法,或者访问其他成员变量是通过符号引用来表示的.动态连接就是将这些符号引用所表示的方法转换为实际方法的直接引用.</li>
<li>类加载的过程中将要解析尚未被解析的符号引用, 并且将变量访问转换为访问这些变量的存储结构所在的运行时内存位置的正确偏移量.</li>
<li>由于动态连接的存在,通过晚期绑定使用的其他类的方法和变量在发生变化时,将不会对调用他们的方法构成影响</li>
</ul>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属的方法引用,持有这个引用是为了支持调用过程中的<code>动态连接</code>.Class文件的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用为参数. 这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用,这种转化称为静态解析. 另外一部分将在每一次的运行期间转化为直接引用,这部分称为动态连接</p>
<h2 id="方法正常调用完成"><a href="#方法正常调用完成" class="headerlink" title="方法正常调用完成"></a>方法正常调用完成</h2><ul>
<li>当前栈帧承担着恢复调用者状态的责任, 其状态包括调用这的局部变量表, 操作数栈以及被正确增加用来表示执行了该方法调用指令的程序计数器等</li>
<li>使得调用者的代码能在被调用的方法返回并且返回值被压入调用者栈帧的操作数栈后继续正常执行</li>
</ul>
<h2 id="方法调用非正常完成"><a href="#方法调用非正常完成" class="headerlink" title="方法调用非正常完成"></a>方法调用非正常完成</h2><ul>
<li>指的是在方法调用过程了,某些指令导致了虚拟机抛出异常,而且虚拟机抛出的异常在该方法中没办法处理,或者在执行过程中遇到athrow字节码指令抛出的显式异常,同时在方法内部没有捕获异常</li>
</ul>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法执行后,有俩个方式退出这个地址.第一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者),是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式为正常完成出口.</p>
<p>另一种退出的方法是,在方法执行过程中遇到了异常,并且这个异常没有在方法体内得到处理,无论虚拟机内部产生的异常,还是代码中使用athrow字节码之类产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常完成出口.一个方法使用异常完成出口的方式退出,是不会给它的上层调用者产生任何返回值的.</p>
<p>无论采用何种退出方法,在方法退出之后,都需要返回到方法被调用的位置,程序才能继续执行,方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层方法的执行状态.一般来说,方法正常退出时,调用者的PC计数器的值就可以作为返回地址,栈帧中很可能会保存这个计数器值.而方法异常退出时,返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息.</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈,因此退出时可能执行的操作有:回复上层方法的局部变量表和操作数栈,把返回值(如果有的话)压入调用者栈帧的操作数栈中,调整PC计数器的值以执行方法调用指令后面的一条指令等.</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等于方法执行,方法调用阶段唯一的任务就是确定方法的版本号(即调用哪个方法),暂时还不涉及方法内部的具体运行过程.在承运运行时,进行方法调用是最普遍,最频繁的的操作,单前面已经讲过,Class文件的编译过程中不包含传统编译的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于之前的所说的直接引用).这个特性给java带来了更加强大的动态拓展能力,但也使得java方法的调用过程变得相对复杂起来,需要在类加载期间甚至到运行期间才能确定目标方法的直接引用.</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>继续前面关于方法调用的话题,所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析极端,会将其中的一部分符号引用转化为直接引用,这种解析能够成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本,并且这个方法在运行期是不可改变的.换句话说,调用目标在程序代码写好,编译器进行编译时就必须确定下来.这类方法的调用称为<code>解析(Resolution)</code>.</p>
<p>在java语言中,符合”编译器可知,运行期不可变”这个要求的方法主要是有静态方法和私有方法俩大类,前者与类型直接关联,后者在外部不可被访问,这俩种方法都不可能通过继承或别的方式重写出其他版本,因此他们都适合在类加载阶段进行解析.</p>
<p>与之对应的是,在java虚拟机里面提供了四条方法调用字节码指令:</p>
<ul>
<li><code>invokestatic</code>: 调用静态方法</li>
<li><code>invokespecial</code>:调用实例构造器<code>&lt;init&gt;</code>方法,私有方法和父类方法</li>
<li><code>invokevirtual</code>:调用所有的虚方法</li>
<li><code>invokeinterface</code>:调用接口方法,会在运行时再确定一个实现此接口的对象</li>
</ul>
<p>只要能被<code>invokestatic</code>, <code>invokespecial</code>指令调用的方法,都可以在解析阶段确定唯一的版本,符合这个条件的有静态方法,私有方法,实例构造器和父类方法四类,他们在类加载的时候就会把符号引用解析为该方法的直接引用.这些方法可以称为<code>非虚方法</code>,与此相反,其他方法就称为<code>虚方法</code>(除了final方法).下面的例子中最常见的解析调用的例子,此样例中,静态方法<code>sayHello()</code>只可能属于类型<code>StaticResolution</code>,没有任何手段可以覆盖或者隐藏这个方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过javap查看字节码:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=0, locals=1, args_size=1</span><br><span class="line">        0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">        3: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 9: 0</span><br><span class="line">       line 10: 3</span><br></pre></td></tr></table></figure></p>
<p>java中的非虚方法除了使用<code>invokestatic</code>和<code>invokespecial</code>调用的方法之外还有一种,就是被<code>final</code>修饰的方法.虽然<code>final</code>方法是使用<code>invokespecial</code>指令来调用的,但是由于它无法被覆盖,没有其他版本,所以也无须对方法接受者进行多态选择,又或者说多态选择的结果是唯一的.在java语言规范中明确说明了final方法是一种非虚方法.</p>
<p>解析调用一定是个静态过程,在编译期间就完全确定,在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用,不会延迟到运行期再去完成.而分派调用则可能是静态的也可能是动态的,根据分派依据的宗数量可分为单分派和多分派.这俩类分派方式俩俩组合就构成了静态单分派,静态多分派,动态单分派,动态多分派.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/运行时数据区/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/运行时数据区/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/类加载/" title="类加载机制" itemprop="url">类加载机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>类从被加载进虚拟机内存开始到卸载出内存的生命周期:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 加载</span><br><span class="line"><span class="number">2</span>. 验证</span><br><span class="line"><span class="number">3</span>. 准备</span><br><span class="line"><span class="number">4</span>. 解析</span><br><span class="line"><span class="number">5</span>. 初始化</span><br><span class="line"><span class="number">6</span>. 使用</span><br><span class="line"><span class="number">7</span>. 卸载</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>特殊说明<br>2.验证, 3.准备, 4.解析 又称为连接阶段<br>1.加载, 2.验证, 3.准备, 4.解析, 5. 初始化 被称为类加载</p>
</blockquote>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载:"></a>加载:</h3><p>加载的过程其实就是将class文件字节码加载进虚拟机的方法区中(方法区中数据格式由虚拟机定义),然后在堆中实例化对其实例化一个<code>java.lang.Class</code>对象,然后程序使用该对象访问存储在方法区里的类型数据.</p>
<p>虚拟机通过下面三个阶段完成一个类的加载过程</p>
<ol>
<li>通过一个类的全限定名来获取此类的二进制流.</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时结构</li>
<li>在java堆中生成一个代表这个类的<code>java.class.Class</code>对象.</li>
</ol>
<p>类的加载过程必须完成以上三个过程但是这三个阶段并没有具体说明从哪里获取以及如何获取类的字节码,我们可以使用系统提供的类加载器或者自定义类加载器完成读取二进制流的动作.</p>
<p>加载阶段与连接阶段开始时间顺序是一定的,但是加载阶段可能还没完成,连接阶段就已经开始了,但这些夹在加载阶段的动作,仍然属于连接阶段的内容.</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证:"></a>验证:</h3><p>验证阶段是为了确保Class文件的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.java语言本身是相对安全的语言,使用纯粹的java代码无法做到诸如访问数组边界以外的数据,将一个对象转型为它并未实现的类型,跳转到不存在的代码之类的事情,如果这样做了,编译器将拒绝编译. 在字节码层面上, 上述java代码无法做到的事情是可以实现的,至少语义上是可以表达的. 虚拟机如果不检查输入的字节流,对其完全信任的话,很可能会输入有害的字节流而导致系统崩溃.</p>
<h4 id="校验过程"><a href="#校验过程" class="headerlink" title="校验过程"></a>校验过程</h4><h5 id="class文件格式验证"><a href="#class文件格式验证" class="headerlink" title="class文件格式验证"></a>class文件格式验证</h5><p>保证输入的字节流能正确地解析并存储于方法区之内.确保符合Class文件规范,且能被当前版本的虚拟机处理.</p>
<ol>
<li>是否以魔术0xCAFEBABY 开头</li>
<li>主次版本号是否在当前虚拟机处理范围内.</li>
<li>常量池中是否有不被支持的常量类型(检查常量tag标志)</li>
<li>… 还有很多其他校验</li>
</ol>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>基于方法区的数据结构进行语义分析验证,以便符合java语言规范. 基本上就是在检验数据类型</p>
<ol>
<li>这个类是否是父类.</li>
<li>这个类是否继承了不允许继承的类(被final修饰的类)</li>
<li>如果这个类不是抽象类,是否实现了其父类或接口中所要求实现的所有方法</li>
<li>… 还有很多其他校验</li>
</ol>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>基于方法区的数据结构,基本上是在对方法体进行验证.这个校验是整个验证过程中最复杂的一个阶段,主要是针对数据流和控制流进行分析. 在对元数据信息的数据类型做完校验后,这阶段对类的方法体进行校验.</p>
<ol>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作.例如操作数栈放置一个int类型的数据,不会按照long类型加载到本地变量表.</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>…  还有很多其他校验</li>
</ol>
<p>在JDK1.6之后javac编译器进行了一项优化, 给方法体的Code属性的属性表中增加了一项”StackMapTable”属性,这项属性描述了方法体中所有的基本块(Basic Block,按照控制流拆分的代码块) 开始时本地变量表和操作数栈应有的状态, 这可以将字节码验证的类型推导转变为类型检查从而节省一些时间.</p>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>符号引用的校验是确保解析动作能正常执行.最后一个阶段校验发生在虚拟机将符号引用转化为直接引用的时候,这个转化动作将在连接的第三阶段-解析阶段中发生.符号校验可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性的校验</p>
<ol>
<li>符号引用通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段</li>
<li>… 还有很多其他的校验</li>
</ol>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中进行分配. 这个阶段中有俩个容易产生混淆的概念需要强调一下,首先是这时候进行内存分配的仅包括类变量,而不包括实例变量,实例变量将会在对象实例化时随着对象<br>一起分配在java堆中. 其中是这里所说的初始值”通常情况”下是数据类型为0.例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>变量value在准备阶段初始值为0而不是123,因为这时候尚未开始执行任何java方法,而把value赋值为123的putstatic指令是程序编译后,存放于类构造器<clinit>()方法之中,所以value赋值123的动作将在初始化阶段才会被执行.但是在一些特殊情况下,如果类字段的字段属性表中存在ConstantValue属性,那么在准备阶段value值就会被初始化为ConstantValue指定的属性值.</clinit></p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是虚拟机将常量池符号引用替换为直接引用的过程(符号引用以CONSTANT_Class_info,CONSTANT_Field_info等类型常量)</p>
<ol>
<li>符号引用: 以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.符号引用与内存实现的布局无关,引用的目标不一定已经加载到内存中.</li>
<li>直接引用:可以是直接指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄.直接引用是与虚拟机实现的内存布局相关的,同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同.如果有了直接引用,那引用的目标一定已经在内存中存在.</li>
</ol>
<h4 id="解析时间"><a href="#解析时间" class="headerlink" title="解析时间"></a>解析时间</h4><p>虚拟机并没有规定解析阶段发生的具体时间,只要求在<code>anewarray,checkcast,getfield,getstatic,instanceof,invokeinterface,invokespecial,invokestatic,invokevirtual,mutianewarray,new,putfield,putstatic</code>这13个用于操作符号引用的字节码指令之前,先对他们所使用的符号引用进行解析.所以虚拟机会根据需要来判断,到底是在类被加载器加载时对常量池的符号引用进行解析,还是等到一个符号引用将要被使用前才去解析它.</p>
<h4 id="多次解析"><a href="#多次解析" class="headerlink" title="多次解析"></a>多次解析</h4><p>对同一个符号引用进行多次解析请求是很常见的,虚拟机实现可能会对第一次解析的结果进行缓存(在运行时常量池中记录直接引用,并发常量标志为已解析状态)从而避免重复解析动作.无论是否真正执行了多次解析动作,虚拟机需要保证的都是在同一个实体中,如果一个符号引用之前已经被成功解析过,那么后续的引用解析请求就应当一直成功,同样,如果第一次解析失败,其他指令对这个符号的解析请求也应当收到相同的异常.下面将讲解四种引用的解析过程</p>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><h5 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a>类或接口解析</h5><p>对<code>CONSTANT_Class_info</code>结构体进行解析</p>
<p>假设当前代码所处的类为D,如果把一个从未解析过的符号引用N解析为一个类或接口C的直接引用,虚拟机完成整个解析需要以下步骤</p>
<ol>
<li><p>如果C不是一个数组类型,那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C.在加载过程中,由于元数据验证,字节码验证的需要,又将可能触发其他相关类的加载动作,例如加载这个类的父类或实现的接口.一旦这个加载过程出现了任何异常,解析过程将宣告失败.</p>
</li>
<li><p>如果C是一个数组类型,并且数组的元素类型为对象,也就是N的描述符会是类似”[Ljava.lang.Integer”的形式.那将会按照第一点的规则加载数组元素类型,如果N的描述符如前面所假设的形式,需要加载的元素类型就是”java.lang.Integer”,接着由虚拟机生成一个代表此数组维度和元素的数组对象</p>
</li>
<li><p>如果上述步骤没有出现任何异常,那么C在虚拟机中实际已经称为一个有效的类或接口了,但在解析完成之前还要进行符号引用验证,确认C是否具备对D的访问权限,如果不具备访问权限,抛出”java.lang.IllegalAccessError”异常</p>
</li>
</ol>
<h5 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h5><p>对<code>CONSTANT_Fieldref_info</code>结构体进行解析</p>
<p>要解析一个从未被解析过的字段符号引用,首先会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析,也就是字段所属的类或接口的符号引用. 如果在解析这个类或接口符号引用的过程中出现了任何异常,都会导致字段解析失败,如果解析成功,那将这个字段所属的类或接口用C表示.</p>
<ol>
<li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段,则返回了这个字段的直接引用,查找结束</p>
</li>
<li><p>否则,如果在C中实现了接口,将会按照继承关系从上往下递归搜索各个接口和它的父接口,如果接口中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束.</p>
</li>
<li><p>否则,如果C不是java.lang.Object的话,将会按照继承关系从上往下递归搜索其父类,如果父类中不包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束.</p>
</li>
<li><p>否则,查找失败,抛出java.lang.NoSuchFieldError异常</p>
</li>
</ol>
<p>如果查找过程成功返回了引用,将会对这个字段进行权限验证,如果发现不具备对其字段的访问权限,则抛出”java.lang.IllegalAccessError”异常.尝试在父类和子类中都出现相同的字段,看看编译器是否会编译~.</p>
<h5 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h5><p>对<code>CONSTANT_Methodref_info</code>结构体进行解析</p>
<p>类方法解析的第一个步骤与字段解析一样,也是需要解析类方法表的class_index项中索引的方法所属的类或接口的符号引用,如果解析成功,依然使用C表示这个类.</p>
<ol>
<li><p>类方法和接口方法符号引用的常量类型定义是分开的,如果在类方法表中发现class_index中索引的C是个接口,那就直接抛出java,lang.IncompatibleClassChangeError.</p>
</li>
<li><p>通过第一步,在类C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则直接返回这个方法的引用,查找结束.</p>
</li>
<li><p>否则在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束</p>
</li>
<li><p>否则在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果存在匹配的方法.说明类C是一个抽象类,这时候查找结束,抛出java.lang.AbstractMethodError异常</p>
</li>
<li><p>否则,宣告查找失败,抛出java.lang.NoSuchMethodError.</p>
</li>
</ol>
<p>最后如果查找过程中成功返回了直接引用,将会对这个方法进行权限验证:如果发现不具备对此方法的权限访问,将抛出java.lang.IllegalAccessError</p>
<h5 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h5><p>对<code>CONSTANT_InterfaceMethodref_info</code>结构体进行解析</p>
<p>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用,如果解析成功,依然用C表示这个接口:</p>
<ol>
<li><p>与类方法解析相反,如果在接口方法表中发现class_index中的索引C是个类而不是接口,就将直接抛出java.lang.IncompatibleClassChangeError异常.</p>
</li>
<li><p>否则在接口C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束.</p>
</li>
<li><p>否则在接口C的父接口中递归查找,知道java.lang.Object类为止,看是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束.</p>
</li>
<li><p>否则,宣告方法查找失败,抛出java.lang.NoSuchMethodError异常</p>
</li>
</ol>
<p>由于接口中的所有方法都默认是public的,所以不存在访问权限的问题,因为接口方法的符号引用解析都应当不会抛出”java.lang.IllegalAccessError”异常</p>
<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>类初始化阶段是类加载过程中最后一步,前面的类加载过程中,除了加载阶段用户应用程序可以通过自定义类加载参与之外,其余动作全部由虚拟机主导和控制.到了初始化阶段才真正开始执行类中定义的java字节码.</p>
<p>在准备阶段,变量已经赋值过一次系统要求的初始值,而在初始阶段,则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源,或者可以从另一个角度来表达: 初始化阶段执行类构造器<clinit>方法的过程.</clinit></p>
<p><code>&lt;clinit&gt;</code>方法执行过程可能会影响程序运行行为的一些特点和细节</p>
<ol>
<li><p><clinit>方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块(static{}块)中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序决定的,静态语句块只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块中可以赋值但是不能访问.</clinit></p>
</li>
<li><p><clinit>()方法和实例的构造函数(<init>)不同,他不需要显式地调用父类构造器,虚拟机会保证在子类的<clinit>()方法执行之前,父类的<clinit>方法已经执行完毕,因此虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object</clinit></clinit></clinit></init></clinit></p>
</li>
<li><p>由于父类的<clinit>()方法先执行,也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></p>
</li>
<li><p><clinit>()方法对于对类或者接口来说并不是必须的,如果一个类中没有静态语句块,也没有对变量的赋值操作,那么编译器可以不为这个类生成<clinit>()方法.</clinit></clinit></p>
</li>
<li><p>接口中不能使用静态语句块,但仍然有变量初始化的赋值操作,因此接口与类一样会生成<clinit>()方法.但接口与类不同的是,执行接口<clinit>方法不需要先执行父接口<clinit>()方法.只有当父接口中定义的变量被使用时,父接口才会被初始化.另外,接口的实现类在初始化时也一样不会执行接口的<clinit>()方法.</clinit></clinit></clinit></clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步,如果多个线程同时去初始化一个类,那么只会有一个线程去执行这个类的<clinit>()方法,其他线程都需要阻塞等待,直到活动线程执行<clinit>()方法完毕. 如果,在一个类的<clinit>()方法中有耗时很长的操作,那就很可能造成多个进程阻塞.</clinit></clinit></clinit></clinit></p>
</li>
</ol>
<p><code>&lt;clinit&gt;</code>方法执行顺序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字段解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" init DeadLoopClass "</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" start"</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" run over"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="类初始化的四种情况"><a href="#类初始化的四种情况" class="headerlink" title="类初始化的四种情况"></a>类初始化的四种情况</h4><ol>
<li><p>遇到new, getstatic, putstatic, invokestatic, 这四条字节码指令时, 如果类没有进行过初始化,则必须先触发初始化</p>
</li>
<li><p>使用java.lang.reflect包的方法进行反射调用的时候,如果类没有进行过初始化,则需要先触发其初始化</p>
</li>
<li><p>当初始化一个类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化.</p>
</li>
<li><p>当虚拟机启动的时候,用户需要指定一个要执行的主类,虚拟机会先初始化这个主类.</p>
</li>
</ol>
<ul>
<li><p>被动引用的例子1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * 通过子类引用父类的静态字段,不会导致子类的类初始化</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被动引用的例子2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * 通过数组定义来引用类,不会触发此类的初始化</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被动引用的例子3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * 常量在编译阶段会存入调用类的常量池中,本质上没有直接引用到定义常量的类,</span><br><span class="line"> * 因此不会触发定义常量的类的初始化</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/类加载/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/类加载/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/字节码指令/" title="字节码指令" itemprop="url">字节码指令</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><h3 id="虚拟机指令集所支持的数据类型"><a href="#虚拟机指令集所支持的数据类型" class="headerlink" title="虚拟机指令集所支持的数据类型"></a>虚拟机指令集所支持的数据类型</h3><table>
<thead>
<tr>
<th>操作码</th>
<th style="text-align:right">byte</th>
<th style="text-align:right">short</th>
<th style="text-align:right">int</th>
<th style="text-align:right">long</th>
<th style="text-align:right">float</th>
<th style="text-align:right">double</th>
<th style="text-align:right">char</th>
<th style="text-align:right">refernce</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tipush</td>
<td style="text-align:right">bipush</td>
<td style="text-align:right">sipush</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tconst</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iconst</td>
<td style="text-align:right">lconst</td>
<td style="text-align:right">fconst</td>
<td style="text-align:right">dconst</td>
<td style="text-align:right"></td>
<td style="text-align:right">aconst</td>
</tr>
<tr>
<td>Tload</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iload</td>
<td style="text-align:right">lload</td>
<td style="text-align:right">fload</td>
<td style="text-align:right">dload</td>
<td style="text-align:right"></td>
<td style="text-align:right">aload</td>
</tr>
<tr>
<td>Tstore</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">store</td>
<td style="text-align:right">lstore</td>
<td style="text-align:right">fstore</td>
<td style="text-align:right">dstore</td>
<td style="text-align:right">cstore</td>
<td style="text-align:right">astore</td>
</tr>
<tr>
<td>Tinc</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iinc</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Taload</td>
<td style="text-align:right">baload</td>
<td style="text-align:right">saload</td>
<td style="text-align:right">iaload</td>
<td style="text-align:right">laload</td>
<td style="text-align:right">faload</td>
<td style="text-align:right">daload</td>
<td style="text-align:right">caload</td>
<td style="text-align:right">aaload</td>
</tr>
<tr>
<td>Tastore</td>
<td style="text-align:right">bastore</td>
<td style="text-align:right">sastore</td>
<td style="text-align:right">iastore</td>
<td style="text-align:right">lastore</td>
<td style="text-align:right">fastore</td>
<td style="text-align:right">dastore</td>
<td style="text-align:right">castore</td>
<td style="text-align:right">aastore</td>
</tr>
<tr>
<td>Tadd</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iadd</td>
<td style="text-align:right">ladd</td>
<td style="text-align:right">fadd</td>
<td style="text-align:right">dadd</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tsub</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">isub</td>
<td style="text-align:right">lsub</td>
<td style="text-align:right">fsub</td>
<td style="text-align:right">dsub</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tmul</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">imul</td>
<td style="text-align:right">lmul</td>
<td style="text-align:right">fmul</td>
<td style="text-align:right">dmul</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tdiv</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">idiv</td>
<td style="text-align:right">ldiv</td>
<td style="text-align:right">fdiv</td>
<td style="text-align:right">ddiv</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Trem</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">irem</td>
<td style="text-align:right">lrem</td>
<td style="text-align:right">frem</td>
<td style="text-align:right">drem</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tneg</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ineg</td>
<td style="text-align:right">lneg</td>
<td style="text-align:right">fneg</td>
<td style="text-align:right">dneg</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tshl</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ishl</td>
<td style="text-align:right">lshl</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tshr</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ishr</td>
<td style="text-align:right">lshr</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tushr</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iushr</td>
<td style="text-align:right">lushr</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tand</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">iand</td>
<td style="text-align:right">land</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tor</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ior</td>
<td style="text-align:right">lor</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Txor</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ixor</td>
<td style="text-align:right">lxor</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>i2T</td>
<td style="text-align:right">i2b</td>
<td style="text-align:right">i2s</td>
<td style="text-align:right"></td>
<td style="text-align:right">i2l</td>
<td style="text-align:right">i2f</td>
<td style="text-align:right">i2d</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>l2T</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">l2i</td>
<td style="text-align:right"></td>
<td style="text-align:right">l2f</td>
<td style="text-align:right">l2d</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>f2T</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">f2i</td>
<td style="text-align:right">f2l</td>
<td style="text-align:right"></td>
<td style="text-align:right">f2d</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>d2T</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">d2i</td>
<td style="text-align:right">d2l</td>
<td style="text-align:right">d2f</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tcmp</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">lcmp</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Tcmpl</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">fcmpl</td>
<td style="text-align:right">dcmpl</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>if_TcmpOP</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">if_icmOP</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">if_acmpOP</td>
</tr>
<tr>
<td>Treturn</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">ireturn</td>
<td style="text-align:right">lreturn</td>
<td style="text-align:right">freturn</td>
<td style="text-align:right">dreturn</td>
<td style="text-align:right"></td>
<td style="text-align:right">areturn</td>
</tr>
</tbody>
</table>
<h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><ul>
<li>加载和存储指令用于将数据从栈帧的本地变量表和操作数栈之间来回传递</li>
<li><p>将一个本地变量加载到操作数栈的指令有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. iload,</span><br><span class="line"><span class="number">2</span>. iload_&lt;n&gt;,</span><br><span class="line"><span class="number">3</span>. lload,</span><br><span class="line"><span class="number">4</span>. lload_&lt;n&gt;,</span><br><span class="line"><span class="number">5</span>. fload,</span><br><span class="line"><span class="number">6</span>. fload_&lt;n&gt;,</span><br><span class="line"><span class="number">7</span>. dload,</span><br><span class="line"><span class="number">8</span>. dload_&lt;n&gt;,</span><br><span class="line"><span class="number">9</span>. aload       从局部变量表加载一个reference类型值到操作数栈</span><br><span class="line"><span class="number">10</span>. aload_&lt;n&gt;  从局部变量表加载一个reference类型值到操作数栈</span><br><span class="line"><span class="number">11</span>. caload     从数组中加载一个<span class="keyword">char</span>类型数据到操作数栈</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个数值从操作数栈存储到局部变量表的指令有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. istore</span><br><span class="line"><span class="number">2</span>. istore_&lt;n&gt;</span><br><span class="line"><span class="number">3</span>. lstore</span><br><span class="line"><span class="number">4</span>. lstore_&lt;n&gt;</span><br><span class="line"><span class="number">5</span>. fstore</span><br><span class="line"><span class="number">6</span>. fstore_&lt;n&gt;</span><br><span class="line"><span class="number">7</span>. dstore</span><br><span class="line"><span class="number">8</span>. dstore_&lt;n&gt;</span><br><span class="line"><span class="number">9</span>. astore       将一个reference类型数据保存到本地变量表</span><br><span class="line"><span class="number">10</span>. astore_&lt;n&gt;  将一个reference类型数据保存到本地变量表</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个常量加载到操作数栈的指令有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. bipush       将一个<span class="keyword">byte</span>类型数据入栈</span><br><span class="line"><span class="number">2</span>. sipush</span><br><span class="line"><span class="number">3</span>. ldc</span><br><span class="line"><span class="number">4</span>. ldc_w</span><br><span class="line"><span class="number">5</span>. ldc2_w</span><br><span class="line"><span class="number">6</span>. aconst_null   将一个<span class="keyword">null</span>值入栈到操作数栈中.</span><br><span class="line"><span class="number">7</span>. iconst_m1</span><br><span class="line"><span class="number">8</span>. iconst_&lt;i&gt;</span><br><span class="line"><span class="number">9</span>. locnst_&lt;l&gt;</span><br><span class="line"><span class="number">10</span>. fconst_&lt;f&gt;</span><br><span class="line"><span class="number">11</span>. dconst_&lt;d&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上指令中有部分是以尖括号为结尾的,这种代表了一组指令, 例如iload_1, iload_2, 等等. 他们表面上没有操作数, 不需要进行取操作数的动作,但操作数都包含在指令中</p>
</li>
</ul>
<h3 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h3><ul>
<li>算数指令是对俩个操作数栈上的值进行某种特定运算,然后把结构重新压入操作数栈.</li>
<li><p>加法指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  iadd</span><br><span class="line"><span class="number">2</span>.  ladd</span><br><span class="line"><span class="number">3</span>.  fadd</span><br><span class="line"><span class="number">4</span>.  dadd</span><br></pre></td></tr></table></figure>
</li>
<li><p>减法指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  isub</span><br><span class="line"><span class="number">2</span>.  lsub</span><br><span class="line"><span class="number">3</span>.  fsub</span><br><span class="line"><span class="number">4</span>.  dsub</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  imul</span><br><span class="line"><span class="number">2</span>.  lmul</span><br><span class="line"><span class="number">3</span>.  fmul</span><br><span class="line"><span class="number">4</span>.  dmul</span><br></pre></td></tr></table></figure>
</li>
<li><p>除法指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  idiv</span><br><span class="line"><span class="number">2</span>.  ldiv</span><br><span class="line"><span class="number">3</span>.  fdiv</span><br><span class="line"><span class="number">4</span>.  ddiv</span><br></pre></td></tr></table></figure>
</li>
<li><p>求余指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  irem</span><br><span class="line"><span class="number">2</span>.  lrem</span><br><span class="line"><span class="number">3</span>.  frem</span><br><span class="line"><span class="number">4</span>.  drem</span><br></pre></td></tr></table></figure>
</li>
<li><p>取反指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  ineg</span><br><span class="line"><span class="number">2</span>.  lneg</span><br><span class="line"><span class="number">3</span>.  dneg</span><br><span class="line"><span class="number">4</span>.  dneg</span><br></pre></td></tr></table></figure>
</li>
<li><p>位移指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  ishl</span><br><span class="line"><span class="number">2</span>.  ishr</span><br><span class="line"><span class="number">3</span>.  iushr</span><br><span class="line"><span class="number">4</span>.  lshl</span><br><span class="line"><span class="number">5</span>.  lshr</span><br><span class="line"><span class="number">6</span>.  lushr</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位或指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  ior</span><br><span class="line"><span class="number">2</span>.  lor</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位与指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  iand</span><br><span class="line"><span class="number">2</span>.  land</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位异或指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  ixor</span><br><span class="line"><span class="number">2</span>.  lxor</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量自增指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  iinc</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较之类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  dcmpg</span><br><span class="line"><span class="number">2</span>.  dcmpl</span><br><span class="line"><span class="number">3</span>.  fcmpg</span><br><span class="line"><span class="number">4</span>.  fcmpl</span><br><span class="line"><span class="number">5</span>.  lcmp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><ul>
<li>可以将俩种java虚拟机数值类型进行相互转换</li>
<li>这些转换指令一般用于实现用户代码的显示类型转换或用来处理虚拟机字节码指令集中指令的非完全独立的问题</li>
<li><p>宽化类型转换:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 从<span class="keyword">int</span>类型到<span class="keyword">long</span>, <span class="keyword">float</span>, <span class="keyword">double</span>类型. i2l和i2d 指令都不会丢失精确度,但是i2f可能会发生精度丢失</span><br><span class="line"><span class="number">2</span>. 从<span class="keyword">long</span>类型到<span class="keyword">float</span>, <span class="keyword">double</span>类型. l2f,l2d都可能会发生精度丢失</span><br><span class="line"><span class="number">3</span>. 从<span class="keyword">float</span>到<span class="keyword">double</span>类型. 在FP-strict模式下可以确保,精度不会丢失</span><br></pre></td></tr></table></figure>
</li>
<li><p>窄化类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 从<span class="keyword">int</span>到<span class="keyword">byte</span>, <span class="keyword">short</span>, <span class="keyword">char</span> 类型</span><br><span class="line"><span class="number">2</span>. 从<span class="keyword">long</span>到<span class="keyword">int</span>类型</span><br><span class="line"><span class="number">3</span>. 从<span class="keyword">float</span>到<span class="keyword">int</span> 或者 <span class="keyword">long</span>类型</span><br><span class="line"><span class="number">4</span>. 从<span class="keyword">double</span> 到<span class="keyword">int</span>, <span class="keyword">long</span>, <span class="keyword">float</span>.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象创建与操作"><a href="#对象创建与操作" class="headerlink" title="对象创建与操作"></a>对象创建与操作</h3><ul>
<li><p>创建类实例的指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  <span class="keyword">new</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数组的指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  newarray</span><br><span class="line"><span class="number">2</span>.  anewarray       创建一个类型为reference类型的数组</span><br><span class="line"><span class="number">3</span>.  multianewarray</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问类字段和类实例字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  getstatic</span><br><span class="line"><span class="number">2</span>.  putstatic</span><br><span class="line"><span class="number">3</span>.  getfield</span><br><span class="line"><span class="number">4</span>.  putfield</span><br></pre></td></tr></table></figure>
</li>
<li><p>把一个数组元素加载到操作数栈的指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  baload  从数组中读取<span class="keyword">byte</span>或者<span class="keyword">boolean</span>类型的数据</span><br><span class="line"><span class="number">2</span>.  aload   从局部变量表加载一个reference类型值到操作数栈</span><br><span class="line"><span class="number">3</span>.  saload</span><br><span class="line"><span class="number">4</span>.  iaload</span><br><span class="line"><span class="number">5</span>.  laload</span><br><span class="line"><span class="number">6</span>.  faload</span><br><span class="line"><span class="number">7</span>.  daload</span><br><span class="line"><span class="number">8</span>.  aaload  从数组中加一个reference类型数据到操作数栈.</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个操作数栈元素存储到数组元素中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  bastore  从操作数栈读取一个<span class="keyword">byte</span>或者<span class="keyword">boolean</span>类型数据并存储数组中</span><br><span class="line"><span class="number">2</span>.  castore  从操作数栈读取一个<span class="keyword">char</span>类型并存储数组</span><br><span class="line"><span class="number">3</span>.  sastore</span><br><span class="line"><span class="number">4</span>.  iastore</span><br><span class="line"><span class="number">5</span>.  fastore</span><br><span class="line"><span class="number">6</span>.  dastore</span><br><span class="line"><span class="number">7</span>.  aastore  从操作数栈读取一个reference类型数据存入到数组中.</span><br></pre></td></tr></table></figure>
</li>
<li><p>取数组长度的指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  arraylength  取数组长度</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查类实例类型的指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  <span class="keyword">instanceof</span></span><br><span class="line"><span class="number">2</span>.  instancecast</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><ul>
<li>直接用于操作操作数栈的指令:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. pop</span><br><span class="line"><span class="number">2</span>. pop2</span><br><span class="line"><span class="number">3</span>. dup</span><br><span class="line"><span class="number">4</span>. dup2</span><br><span class="line"><span class="number">5</span>. dip_x1</span><br><span class="line"><span class="number">6</span>. dup2_x1</span><br><span class="line"><span class="number">7</span>. dup_x2</span><br><span class="line"><span class="number">8</span>. dup2_x2</span><br><span class="line"><span class="number">9</span>. swap</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p> 控制转移指令可以让虚拟机有条件或者无条件地从指定指令而不是控制转移指令的下一条指令继续执行程序</p>
<ul>
<li><p>条件分支指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. ifeq</span><br><span class="line"><span class="number">2</span>. iflt</span><br><span class="line"><span class="number">3</span>. ifle</span><br><span class="line"><span class="number">4</span>. ifgt</span><br><span class="line"><span class="number">5</span>. ifnull</span><br><span class="line"><span class="number">6</span>. ifnonnull</span><br><span class="line"><span class="number">7</span>. if_icmpeq</span><br><span class="line"><span class="number">8</span>. if_icmpne</span><br><span class="line"><span class="number">9</span>. if_icmplt</span><br><span class="line"><span class="number">10</span>. if_icmmpgt</span><br><span class="line"><span class="number">11</span>. if_cfimmple</span><br><span class="line"><span class="number">12</span>. if_acmpeq</span><br><span class="line"><span class="number">13</span>. if_acmpne</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合条件分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. tableswitch</span><br><span class="line"><span class="number">2</span>. lookupswitch</span><br></pre></td></tr></table></figure>
</li>
<li><p>无条件分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. goto</span><br><span class="line"><span class="number">2</span>. goto_w</span><br><span class="line"><span class="number">3</span>. jsr</span><br><span class="line"><span class="number">4</span>. jsr_w</span><br><span class="line"><span class="number">5</span>. ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>boolean, byte, char, short 类型作为条件分支比较操作, 都使用int 类型的比较指令完成</p>
</li>
<li>long, float, double 类型的条件分支, 则先会执行相应类型的比较运算指令, 运算指令会返回一个整型值到操作数栈中,然后再执行int类型的条件分支比较操作来完成整个分支的跳转.</li>
<li>所有int类型的条件分支转移指令进行的都是有符号的比较操作</li>
</ul>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><ul>
<li><p>方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. invokevirtual: 用于调用对象的实例方法, 根据对象的实际类型进行分派(虚方法分派).</span><br><span class="line"><span class="number">2</span>. invokeinterface: 用于调用接口方法. 它会在运行时搜索一个实现了这个接口方法的对象, 并找出合适的方法进行调用</span><br><span class="line"><span class="number">3</span>. invokespecial: 指令用于一些需要特殊处理的实例方法, 包括实例初始化方法, 私有方法和父类方法</span><br><span class="line"><span class="number">4</span>. invokestatic:  指令用于调用命名类中的类方法</span><br><span class="line"><span class="number">5</span>. invokedynamic: 指令用于绑定了invokedynamic指令的调用点对象作为目标的方法. 调用点对象是一个特殊的语法结构,</span><br><span class="line">                  当一条invokedynamic首次被java虚拟机执行前, java虚拟机会执行一个引导方法并以这个方法的运行结果</span><br><span class="line">                  作为调用点对象.因此每条invokedynamic指令都有一个独一无二的链接期状态.</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. ireturn  用以返回<span class="keyword">boolean</span>, <span class="keyword">byte</span>, <span class="keyword">char</span>, <span class="keyword">short</span>, <span class="keyword">int</span> 类型使用</span><br><span class="line"><span class="number">2</span>. lreturn</span><br><span class="line"><span class="number">3</span>. freturn</span><br><span class="line"><span class="number">4</span>. dreturn</span><br><span class="line"><span class="number">5</span>. areturn  从方法中返回一个reference类型数据</span><br><span class="line"><span class="number">6</span>. 有一条特殊的<span class="keyword">return</span>指令供声明为<span class="keyword">void</span>的方法, 实例初始化方法, 类和接口的类初始化方法使用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ul>
<li>程序中显式的异常由athrow指令抛出, 其他的异常会在其他指令检测到异常时由虚拟机自动抛出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. athrow  抛出一个异常</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>java虚拟机支持方法级的同步以及方法内部一段指令序列的同步.这俩种同步机制都使用同步锁来支持的.方法级的同步是隐式的,无需通过字节码指令来控制,它实现在方法调用和返回操作之中.</p>
<p>虚拟机从方法常量池中的方法表结构中的<code>ACC_SYNCHRONIZED</code>访问标志来区分一个方法是否是同步方法.当调用同步方法时,调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否设置了,如果设置了,执行线程会先持有同步锁,然后执行方法.最后在方法结束时,释放掉同步锁. 在方法执行期间,执行线程有了同步锁,其他线程都无法再获得同一个同步锁.</p>
<p>同步一段指令集序列, 通常是由java中<code>synchronized</code>块表示的. java虚拟机中有<code>monitorenter</code>和<code>monitorexit</code>俩个指令来支持<code>synchronized</code>语义.</p>
<p>结构化锁定指的是在方法调用期间每一个同步锁退出斗鱼前面的同步锁进入相匹配的情形. 因为无法保证所有提交给java虚拟机执行的代码都满足结构化锁定,所以java虚拟机允许通过以下俩条规则来保证结构化锁定成立. (T代表一个线程, M代表一个同步锁)</p>
<ol>
<li>T在方法执行时持有的同步锁M的次数必须与T在此方法完成时释放同步锁M的次数想等</li>
<li>在方法调用过程中,任何时刻都不会出现线程T释放同步锁M的次数比T持有同步锁M次数多的情况</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/字节码指令/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/字节码指令/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/JVM 参数/" title="java虚拟机参数" itemprop="url">java虚拟机参数</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="内存管理参数"><a href="#内存管理参数" class="headerlink" title="内存管理参数"></a>内存管理参数</h2><p><em><code>-XDisableExplicitGC</code>:忽略来自System.gc()方法触发的垃圾收集
</em><code>-XExplicitGCInvokesConcurrent</code>:当收到System.gc()方法提交的垃圾收集申请时,使用CMS收集器收集<br><em><code>-XUseSerialGC</code>:打开此开关后使用Serial+SerialOld的收集器组合进行内存回收.
</em><code>-XUseParNewGC</code>:虚拟机运行在Client模式下的默认值,打开此开关后,使用ParNew+SeialOld的收集器组合进行垃圾收集<br><em><code>-XUseConcMarkSweepGc</code>:打开次开关后使用<code>ParNew+CMS+SerialOld</code>收集器组合进行垃圾收集.如果CMS收集器出现<code>ConcurrentModeFailure</code>,则<code>SeialOld</code>收集器将作为后备收集器.
</em><code>-XUseParallelGC</code>:虚拟机运行在Server模式下的默认值,打开此开关后,使用ParallelScavenge+SerialOld的收集器组合进行内存回收<br><em><code>-XUseParaelOldGC</code>:打开此开关后,使用ParallelScavenge+ParallelOld的收集器组合进行内存回收
</em><code>-XSurvivorRatio</code>:新生代中Eden区和Survivor区的容量比值(默认为8)<br><em><code>-XPretenureSizeThreshold</code>:直接晋升到老年代的对象大小,设置这个参数后,大于这个参数的对象将直接在老年代分配
</em><code>-XMaxTenuringThreshold</code>:晋升到老年代的对象年龄,每个对象在坚持过一次MinorGC之后,年龄就+1,当超过这个参数值时就进入老年代<br><em><code>-XUseAdaptiveSizePolicy</code>:动态调整java堆中各个区域的大小及进入老年代的年龄
</em><code>-XHandlePromotionFailure</code>:是否允许分配担保失败,即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况<br><em><code>-XParallelGCThreads</code>:设置并行GC时进行内存回收的线程数(少于或等于8个CPU时默认值为CPU数量值,多于8个CPU时比CPU数量值小)
</em><code>-XGCTimeRatio</code>:GC时间占总时间的比率.仅在使用ParallelScavenge收集器时生效<br><em><code>-XMaxGCPauseMillis</code>:设置GC最大停顿时间.仅在使用ParallelScavenge收集器时生效
</em><code>-XCMSInitiatingOccupancyFraction</code>:设置CMS收集器在老年代空间被使用多少后触发垃圾收集<br><em><code>-XUseCMSCompactAtFullCollection</code>:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理
</em><code>-XCMSFullGCBeforeCompaction</code>:设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理<br><em><code>-XScavengeBeforeFullGC</code>:在FullGC发生之前触发一次MinorGC
</em><code>-XUseGCOverheadLimit</code>:禁止GC过程无限制的执行,如果过于频繁,就直接发生OutOfMemory<br><em><code>-XUseTLAB</code>:优先在本地线程缓冲区中分配对象,避免分配内存时的锁定过程
</em><code>-XMaxHeapFreeRatio</code>:当Xmx值比Xms值大时,堆可以动态收缩和扩展,这个参数控制当堆空闲大于指定比率时自动收缩<br><em><code>-XMinHeapFreeRatio</code>:当Xmx值比Xms值大时,堆可以动态收缩和扩展,这个参数控制当堆空闲小于指定比率时自动收缩
</em><code>-XMaxPermSize</code>:永久代的最大值<br><em><code>-Xms</code>:初始堆大小
</em><code>-Xmx</code>:最大堆大小<br>*<code>-Xmn</code>:设置年轻代大小.整个JVM内存大小=年轻代大小+年老代大小+持久代大小.(Xms必须大于Xmn)</p>
<h2 id="即时编译参数"><a href="#即时编译参数" class="headerlink" title="即时编译参数"></a>即时编译参数</h2><p><em><code>CompileThreshold</code>:触发即时编译的阈值
</em><code>OnStackReplacePercentage</code>:OSR比率,它是OSR即时编译阈值计算公司的一个参数,用于代替BackEdgeThreshold参数控制回边计数器的实际溢出阈值<br>*<code>ReservedCodeCacheSize</code>:即时编译器编译的代码缓存使得最大值</p>
<h2 id="类型加载参数"><a href="#类型加载参数" class="headerlink" title="类型加载参数"></a>类型加载参数</h2><p><em><code>UseSplitVerifier</code>:使用依赖StackMapTable信息的类型检查代替数据流分析,以加快字节码校验速度
</em><code>FailOverToOldVerier</code>:当类型校验失败时,是否允许回到老的类型推到校验方式进行校验,如果开启则允许<br>*<code>RelaxAccessControlCheck</code>:在校验阶段放松对类型访问性的限制</p>
<h2 id="多线程相关参数"><a href="#多线程相关参数" class="headerlink" title="多线程相关参数"></a>多线程相关参数</h2><p><em><code>UseSpinning</code>:开启自旋锁以免线程频繁的挂起和唤醒
</em><code>PreBlockSpin</code>:使用自旋锁时默认的自旋次数<br><em><code>UseThreadPriorities</code>:使用本地线程优先级
</em><code>UseBiaseLocking</code>:是否使用偏向锁,如果开启则使用<br>*<code>UseFastAccessorMethods</code>:当频繁反射执行某个方法时,生成字节码来加快反射的执行速度</p>
<h2 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h2><p><em><code>AggressiveOpts</code>:使用激进的优化特征,这些特征一般是具备正面和负面双重影响的,需要根据具体应用特点分析才能判定是否对性能有好处
</em><code>UseLargePages</code>:如果可能,使用大内存分页,这项特性需要操作系统的支持<br><em><code>LargePageSizeInBytes</code>:使用指定大小的内存分页,这项特性需要操作系统的支持
</em><code>StringCache</code>:是否使用字符串缓存,开启则使用</p>
<h2 id="调试参数"><a href="#调试参数" class="headerlink" title="调试参数"></a>调试参数</h2><p><em><code>HeapDumpOnOutOfMemoryError</code>:在发生内存溢出异常时是否生成堆转储快照,关闭则不生成
</em><code>OnOutOfMemoryError</code>:当虚拟机抛出内存溢出异常时,执行指令的命令<br><em><code>OnError</code>:当虚拟机抛出ERROR异常时,执行指令的命令
</em><code>PrintClassHistogram</code>:使用[ctrl]-[break]快捷键输出类统计状态,相当于jmap-histo的功能<br><em><code>PrintConcurrentLocks</code>:打印J.U.C中的状态
</em><code>PrintCommandLineFlags</code>:打印启动虚拟机时输入的非稳定参数<br><em><code>PrintGC</code>:打印GC信息
</em><code>PrintCompilation</code>:显示所有可设置的参数及它们的值(<em>**从JDK6update21开始才可以用)
</em><code>PrintGCDetails</code>:打印GC的详细信息<br><em><code>PrintGCTimesStamps</code>:打印GC停顿耗时
</em><code>PrintTenuingDistribution</code>:打印GC后新生代各个年龄对象的大小<br><em><code>TraceClassLoading</code>:打印类加载信息
</em><code>TraceClassUnloading</code>:打印类卸载信息<br><em><code>PrintInlining</code>:打印方法内联信息
</em><code>PrintCFGToFile</code>:将CFG图信息输出到文件,只有DEBUG版虚拟机才支持此参数<br><em><code>PrintIdealGraphFile</code>:将Ideal图信息输出到文件,只有DEBUG版虚拟机才支持此参数
</em><code>UnlockDiagnosticVMOptions</code>:让虚拟机进入诊断模式,一些参数(如PrintAssembly)需要在诊断模式中才能使用<br>*<code>PrintAssembly</code>:打印即时编译后的二进制信息</p>
<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p>*给远程服务器加debug<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=$debug_port</span><br></pre></td></tr></table></figure></p>
<ul>
<li>suspend:这个参数是用来当JVM启动之后等待debug客户端连接,如果没有debug客户端连接,那么虚拟机就会一直等待，造成假死的现象</li>
</ul>
<p><em><code>-XX:+UseVMInterruptibleIO</code>:线程中断前或是EINTR在OS_INTRPT中对于I/O操作的结果
</em><code>-XX:-UseParallelOldGC</code>:所有的集合使用并行垃圾收集器.能够自动化地设置这个选项-XX:+UseParallelGC<br><em><code>-XX:+FailOverToOldVerifier</code>:当新的类型检测器失败时切换到旧的认证器
</em><code>-XX:-AllowUserSignalHandlers</code>:允许为java进程安装信号处理器（限于Linux和Solaris,默认关闭）</p>
<p><em><code>-XX:NewRatio=n</code>:老年代与新生代比例(默认是2).
</em><code>-XX:ConcGCThreads=n</code>:<code>concurrentgarbagecollectors</code>使用的线程数.(默认值与JVM所在平台有关).<br><em><code>-XX:+UseG1GC</code>:使用<code>GarbageFirst(G1)</code>收集器
</em><code>-XX:InitiatingHeapOccupancyPercent=n</code>:设置触发标记周期的Java堆占用率阈值.默认占用率是整个Java堆的45%.<br><em><code>-XX:G1HeapRegionSize=n</code>:设置的G1区域的大小.值是2的幂,范围是1MB到32MB之间.目标是根据最小的Java堆大小划分出约2048个区域.
</em><code>-XX:G1ReservePercent=n</code>:设置作为空闲空间的预留内存百分比,以降低目标空间溢出的风险.默认值是10%.增加或减少百分比时,请确保对总的Java堆调整相同的量.JavaHotSpotVMbuild23中没有此设置.</p>
<p><em><code>-XX:AllocatePrefetchStyle=1</code>:预取指令的产生代码风格：0-没有预取指令,1-每一次分配内存就执行预取指令,2-当执行预取代码指令时,用TLAB分配水印指针指向门
</em><code>-XX:NewSize=2m</code>:新生代默认大小(单位是字节)<br><em><code>-XX:AllocatePrefetchLines=1</code>:在使用JIT生成的预读取指令分配对象后读取的缓存行数.如果上次分配的对象是一个实例则默认值是1,如果是一个数组则是3
</em><code>-XX:+OptimizeStringConcat</code>:对字符串拼接进行优化<br><em><code>-XX:MaxNewSize=size</code>:新生代最大值(单位字节)
</em><code>-XX:ThreadStackSize=512</code>:线程堆栈大小(单位Kbytes,0使用默认大小)<br><em><code>-XX:+UseCompressedStrings</code>:如果可以表示为纯ASCII的话,则用byte[]代替字符串.
</em><code>-XX:+UseBiasedLocking</code>:使用偏锁.</p>
<p><em><code>-XX:LoopUnrollLimit=n</code>:代表节点数目小于给定值时打开循环体.
</em><code>-XX:GCLogFileSize=8K</code>:gc日志文件大小(必须&gt;=8K).<br><em><code>-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</code>:堆内存溢出存放日志目录.
</em><code>-XX:+PerfDataSaveToFile</code>:Jvm退出时保存jvmstat的二进制数据.<br><em><code>-Xloggc:&lt;filename&gt;</code>:gc日志文件
</em><code>-XX:+AlwaysPreTouch</code>:当JVM初始化时预先对Java堆进行预先摸底(堆中每个页归零处理).<br><em><code>-XX:InlineSmallCode=n</code>:当编译的代码小于指定的值时,内联编译的代码.
</em><code>-XX:InitialTenuringThreshold=7</code>:设置初始的对象在新生代中最大存活次数.<br><em><code>-XX:+UseCompressedOops</code>:使用compressedpointers.这个参数默认在64bit的环境下默认启动,但是如果JVM的内存达到32G后,这个参数就会默认为不启动,因为32G内存后,压缩就没有多大必要了,要管理那么大的内存指针也需要很大的宽度了
</em><code>-XX:-PrintAdaptiveSizePolicy</code>:打印JVM自动划分新生代和老生代大小信息.<br><em><code>-XX:AllocatePrefetchDistance=n</code>:为对象分配设置预取距离.
</em><code>-XX:MaxInlineSize=35</code>:内联函数最大的字节码大小.<br><em><code>-XX:-UseGCLogFileRotation</code>:开启GC日志文件切分功能,前置选项-Xloggc
</em><code>-XX:-CITime</code>:打印<code>JITCompiler</code>的耗时<br><em><code>-XX:-TraceClassResolution</code>:追踪常量池resolutions.
</em><code>-XX:FreqInlineSize=n</code>:经常执行方法内联的最大字节大小<br><em><code>-XX:-TraceLoaderConstraints</code>:跟踪加载器的限制记录.
</em><code>-XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log</code>:如果有Error发生,则将Error输入到该日志.<br><em><code>-XX:NumberOfGClogFiles=1</code>:设置Gc日志文件的数量(必须大于1)
</em><code>-XX:-PrintTenuringDistribution</code>:打印对象的存活期限信息.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/JVM 参数/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/JVM 参数/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/JVM内置工具/" title="JVM内置工具" itemprop="url">JVM内置工具</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h2><p>虚拟机进程状况工具</p>
<p>列出正在运行的虚拟机进程,并显示虚拟机执行主类的名称,以及这些进程的本地虚拟机的唯一ID(LVMID).</p>
<p>对于本地虚拟机进程来说,LVMID与操作系统的进程ID是一致的,使用windwos的任务管理器或者Unix的ps命令也可以查询到虚拟机进程的LVMID,但如果同时启动了多个虚拟机进程,无法根据进程名称定位时,那就只能依赖jps命令显示主类的功能才能区分.</p>
<p>命令格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [hostid]</span><br></pre></td></tr></table></figure></p>
<p>jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态,hostid为RMI注册表中注册的主机名</p>
<p>jps工具主要选项</p>
<ul>
<li><code>-q</code>: 只输出LVMID,省略主类的名称</li>
<li><code>-m</code>: 输出虚拟机进程启动时传递给主类main()函数的参数</li>
<li><code>-l</code>: 输出主类的全名,如果进程执行的jar包,输出jar路径</li>
<li><code>-v</code>: 输出虚拟机进程启动时JVM参数.</li>
</ul>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>虚拟机统计信息监视工具</p>
<p>用于监视虚拟机各种运行状态信息的命令行工具.它可以显示本地或远程虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据.</p>
<p>jstat命令格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval [s|ms] [count]]]</span><br></pre></td></tr></table></figure></p>
<p>对于命令格式中的VMID与LVMID需要特别说明一下:如果是本地虚拟机进程,VMID和LVMID是一致的,如果是远程<br>虚拟机进程,那么VMID的格式应该是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:] [<span class="comment">//]lvmid[@hostname [:port] /servername]</span></span><br></pre></td></tr></table></figure></p>
<p>选项option代表着用户希望查询的虚拟机信息,主要分为三类:类装载,垃圾收集,运行期编译状况.</p>
<p>jstat工具主要选项</p>
<ul>
<li><code>-class</code>: 监视类装载,卸载数量,总空间及类装载所耗费的时间</li>
<li><code>-gc</code>: 监视java堆状况,包括Eden区,2个survivor区,老年代,永久代等的容量,已用空间,GC时间合计等信息.</li>
<li><code>-gccapacity</code>: 监视内容与-gc基本相同,但输出主要关注java堆各个区域使用到最大和最小空间.</li>
<li><code>-gcutil</code>: 监视内容与-gc基本相同,但输出主要关注已使用空间占总空间的百分比.</li>
<li><code>-gccause</code>: 与-gcutil功能一样,但是会额外输出导致上一次GC产生的原因.</li>
<li><code>-gcnew</code>:监视新生代GC的状况.</li>
<li><code>-gcnewcapacity</code>: 监视内容与-gcnew基本相同输出主要关注使用到的最大和最小空间</li>
<li><code>-gcold</code>: 监视老年代GC的状况.</li>
<li><code>-gcoldcapacity</code>: 监视内容与-gcold基本相同,但输出主要关注使用到的最大和最小空间</li>
<li><code>-gcpermcapacity</code>: 输出永久代使用到呃最大和最小空间</li>
<li><code>-compiler</code>: 输出JIT编译器编译过的方法,耗时等信息</li>
<li><code>-printcompilation</code>: 输出已经被JIT编译的方法.</li>
</ul>
<blockquote>
<p>E -&gt; Eden. S0 -&gt; Survivor0. S1 -&gt; Survivor1. O -&gt; Old. P -&gt; Permanent. YGC -&gt; YoungGC,Minor GC.<br>FGC  -&gt; Full GC. FGCT -&gt; Full GC Time.</p>
</blockquote>
<h2 id="Jinfo"><a href="#Jinfo" class="headerlink" title="Jinfo"></a>Jinfo</h2><p>Java配置</p>
<p>jinfo的作用是实时查看和调整虚拟机的各项参数.</p>
<h3 id="jinfo命令格式"><a href="#jinfo命令格式" class="headerlink" title="jinfo命令格式"></a>jinfo命令格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure>
<h2 id="Jmap"><a href="#Jmap" class="headerlink" title="Jmap"></a>Jmap</h2><p>java内存映射工具,用于生成堆转储快照.</p>
<p>如果不使用jmap命令,想要获取java堆转储快照还有一些比较暴力的手段:<br><code>-XX:+HeapDumpOnOutOfMemoryError</code>: 可以让虚拟机在OOM异常自动生成dump文件,通过<br><code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用<code>[CTRL] + [Break]</code>: 键让虚拟机生成dump文件,又或者在Linux系统<br>下通过<code>kill -3</code>命令发送进程退出信号,也能拿到dump文件.</p>
<p>jmap的作用并不仅仅是为了获取dump文件,它还可以查询<code>finalize</code>执行队列,java堆和永久代的详细信息,如空间使用率,当前使用的是哪种收集器.</p>
<p>和jinfo命令一样,jmap有不少功能是在windows平台下受限的,除了生成dump文件<code>-dump</code>选项和用于查看每个类的实例,空间占用统计的<code>-histo</code>选项所有系统操作系统都提供之外,其余选项只能在Linux/Solaris下使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure>
<p>jmap工具主要选项</p>
<ul>
<li><code>-dump</code>: 生成java堆转储快照.格式为:<code>-dump:[live,]format=b,file=&lt;filename&gt;</code>.live表示只dump存活对象</li>
<li><code>-finalizerinfo</code>: 显示在<code>F-Queue</code>中等待<code>Finalizer</code>线程执行<code>finalize</code>方法的对象.</li>
<li><code>-heap</code>: 显示java堆的详细信息,使用哪种回收器,参数配置,分代状况.</li>
<li><code>-histo</code>: 显示堆中对象统计信息,包括类,实例数量和合计容量</li>
<li><code>-permstat</code>: 以<code>ClassLoader</code>为统计口径显示永久代内存状态.</li>
<li><code>-F</code>: 当虚拟机进程对<code>-dump</code>选项没有响应时,可使用这个选项强制生成dump快照</li>
</ul>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>java堆栈跟踪工具. <code>jstack</code>命令用于生成虚拟机当前时刻的线程快照.线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合,生成线程快照的主要目的是定位线程出现长时间停顿的原因,如<a href="">线程间死锁</a>,<a href="">死循环</a>,请求外部资源<br>导致长时间等待.</p>
<p>jstack命令格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure></p>
<p>option值：</p>
<ul>
<li><code>-F</code>: 当正常输出的请求不被响应时,强制说出线程堆栈</li>
<li><code>-l</code>: 除堆栈外,显示关于锁的附加信息</li>
<li><code>-m</code>: 如果调用本地方法的话,可以显示c/c++的堆栈</li>
</ul>
<p>当对线程堆栈分析时，首先查找<code>BLOCKED</code>, 找到锁住的线程。</p>
<h2 id="jstack日志"><a href="#jstack日志" class="headerlink" title="jstack日志"></a>jstack日志</h2><p>下面摘抄的是NETTY中空epoll的一段记录<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"nioEventLoopGroup-2461-1" #4955 prio=10 os_prio=0 tid=0x00007fd857e9a000 nid=0x5e19 runnable [0x00007fd7374bc000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)</span><br><span class="line">	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:79)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)</span><br><span class="line">	- locked &lt;0x00000000e673cf38&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">	- locked &lt;0x00000000e673cd30&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">	- locked &lt;0x00000000e673cc58&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.select(NioEventLoop.java:622)</span><br><span class="line">	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:310)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116)</span><br><span class="line">	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure></p>
<p>第一行数据分析<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-2461-1 表示的是进程名字</span><br><span class="line">#4955</span><br><span class="line">prio=10</span><br><span class="line">os_prio=0</span><br><span class="line">nid: 线程ID的16进制表示(可以通过`top -H`查看pid)</span><br><span class="line">tid:</span><br><span class="line">runnable</span><br><span class="line">[0x00007fd7374bc000]`</span><br></pre></td></tr></table></figure></p>
<p>线程堆栈信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State 线程状态</span><br><span class="line">locked` 锁住的资源,分别锁住了  &lt;<span class="number">0x00000000e673cf38</span>&gt;, &lt;<span class="number">0x00000000e673cd30</span>&gt;, &lt;<span class="number">0x00000000e673cc58</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>java.lang.Thread.State 线程状态</p>
<ul>
<li><code>Runnable</code> : 线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行</li>
<li><p><code>waiting for monitor entry</code> :  在等待进入一个临界区,所以它在<code>Entry Set</code>队列中等待.</p>
<blockquote>
<p>此时线程状态一般都是 <code>Blocked</code>:如果大量线程在<code>waiting for monitor entry</code>, 可能是一个全局锁阻塞住了大量线程.如果短时间内打印的 <code>thread dump</code> 文件反映,随着时间流逝,<code>waiting for monitor entry</code>的线程越来越多,没有减少的趋势,可能意味着某些线程在临界区里呆的时间太长了,以至于越来越多新线程迟迟无法进入临界区.</p>
</blockquote>
</li>
<li><p><code>waiting on condition</code> : 说明它在等待另一个条件的发生,来把自己唤醒,或者干脆它是调用了 <code>sleep(N)</code>.</p>
<blockquote>
<p>如果大量线程在<code>waiting on condition</code>：可能是它们又跑去获取第三方资源,尤其是第三方网络资源,迟迟获取不到<code>Response</code>,导致大量线程进入等待状态.所以如果你发现有大量的线程都处在 <code>Wait on condition</code>,从线程堆栈看,正等待网络读写,这可能是一个网络瓶颈的征兆,因为网络阻塞导致线程无法执行.  此时线程状态大致为以下几种：</p>
<ol>
<li><code>java.lang.Thread.State: WAITING (parking)</code>：一直等那个条件发生；</li>
<li><code>java.lang.Thread.State: TIMED_WAITING</code> (<code>parking</code>或<code>sleeping</code>)：定时的,那个条件不到来,也将定时唤醒自己.</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><code>in Object.wait()</code> : 说明它获得了监视器之后,又调用了 <code>java.lang.Object.wait()</code> 方法.<blockquote>
<p>每个 Monitor在某个时刻,只能被一个线程拥有,该线程就是 <code>Active Thread</code>,而其它线程都是 <code>Waiting Thread</code>,分别在两个队列 <code>Entry Set</code>和 <code>Wait Set</code>里面等候.在 <code>Entry Set</code>中等待的线程状态是 <code>Waiting for monitor entry</code>,而在 <code>Wait Set</code>中等待的线程状态是 <code>in Object.wait()</code>.当线程获得了 <code>Monitor</code>,如果发现线程继续运行的条件没有满足,它则调用对象(一般就是被 <code>synchronized</code> 的对象)的 <code>wait()</code> 方法,放弃了 <code>Monitor</code>,进入 <code>Wait Set</code>队列. 此时线程状态大致为以下几种：</p>
<ol>
<li><code>java.lang.Thread.State: TIMED_WAITING (on object monitor)</code>;</li>
<li><code>java.lang.Thread.State: WAITING (on object monitor)</code>;</li>
</ol>
</blockquote>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/JVM内置工具/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/JVM内置工具/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/08/jvm/内存溢出/" title="内存溢出" itemprop="url">内存溢出</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h3><p>溢出代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * -verbose:gc -Xms20M -Xmx20M -Xmn10M</span><br><span class="line">	 * -XX:PrintGCDetails</span><br><span class="line">	 * -XX:SurvivorRatio=8</span><br><span class="line">	 * <span class="doctag">@param</span> args</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac HeapOOM.java</span><br><span class="line">java -verbose:gc -Xms20M -Xmx20M -Xmn10M   -XX:+PrintGCDetails  -XX:SurvivorRatio=<span class="number">8</span>  HeapOOM</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p>
<p>解决java堆内存溢出,一般的手段是通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出的堆转储快照进行分析.重点是确认内存中的对象是否是必要的,也就是先分清楚是内存泄漏还是内存溢出.</p>
<ol>
<li>如果是内存泄漏可通过工具查看泄漏对象到GC Roots的引用链.于是就能找到泄漏对象是通过怎样的路径与GC Toots相关联,并导致垃圾收集器无法自动回收它们的. 掌握了泄漏对象的类型信息,以及GC Roots引用链信息,就可以比较准确地定位出泄漏代码的位置.</li>
<li>如果不存在泄漏, 换句话说就是内存中的对象确实还都必须存货着, 那就应当检查虚拟机的堆参数,与物理机内存对比查看是否还可以调大,从代码上检查是否存在某些生命周期过长,持有状态时间过长的情况,尝试减少程序运行周期的内存消耗.</li>
</ol>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>溢出代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * -Xoss 设置本地放发栈 但是此参数无效</span><br><span class="line">  * -Xss 虚拟机栈 设置此参数</span><br><span class="line">  * <span class="doctag">@param</span> args</span><br><span class="line">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		stackLength ++;</span><br><span class="line">		stackLeak();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			oom.stackLeak();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					dontStop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JavaVMStackOM om = <span class="keyword">new</span> JavaVMStackOM();</span><br><span class="line">		om.stackLeakByThread();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上俩个实现都都无法让虚拟机产生OutOfMemoryError异常,只能产生StackOverflowError.实验结果表明: 单个线程下,无论由于栈帧太大还是虚拟机容量太小,当内存无法分配时,虚拟机抛出的都是StackOverflowError.如果测试时不是限于单线程,通过不断建立新线程的方式倒是可以产生内存溢出异常. 但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系,或者准确说,在这种情况下,给每个线程的栈分配的内存越大,反而越容易产生内存溢出异常.</p>
<p>当开发多线程应用时应该特别注意的是,出现StackOverflowError异常时有错误堆栈可以阅读,相对来说比较容易找到问题.如果使用虚拟机默认参数,栈深度在大多数情况下达到1000-2000完全没有问题,对于正常的方法调用(包括递归),这个深度应该够用了,但是如果建立过多的线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程.</p>
<h3 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h3><p>溢出代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 运行时常量溢出</span><br><span class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> * <span class="doctag">@author</span> mingwang</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			list.add(String.valueOf(i++).intern());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想运行时常量池添加内容最简单的方式就是String.intern()这个native方法.该方法的作用是:如果池中已经包含一个等于此String对象的字符串,则返回池中这个字符串的String对象.否则将次String对象包含的字符串添加到常量池中,并返回次String对象音乐.</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 借助CGLib使得方法区内存溢出异常</span><br><span class="line"> * -XX:PermSize10M -XX:MaxPermSize10M</span><br><span class="line"> * <span class="doctag">@author</span> mingwang</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">			enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">			enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			enhancer.setCallBack(<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objs,</span><br><span class="line">				MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	javac JavaMethodAreaOOMRun.java</span><br><span class="line">	java -XX:PermSize10M -XX:MaxPermSize10M JavaMethodAreaOOMRun</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p>
<p>方法区用于存放Class信息,为了测试这个区域,基本思路是产生大量的类去填充方法区,直到溢出.本例中使用的是CGLib, 还可以使用ASM等框架进行测试.方法区溢出也是一种常见的内存溢出异常.一个类如果被垃圾收集器回收,其条件是非常苛刻的. 在经常动态生成大量Class的应用中,需要特别注意类的回收状况. (基于OSGI的应用即使是同一个类文件被不同的加载器加载也会视为不同的类)</p>
<h3 id="本地内存直接溢出"><a href="#本地内存直接溢出" class="headerlink" title="本地内存直接溢出"></a>本地内存直接溢出</h3><p>溢出代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span><br><span class="line">	 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">	        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	        Unsafe unsafe = (Unsafe)unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">	        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">	            unsafe.allocateMemory(_1MB);</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接通过反射获取Unsafe实例并进行内存分配,Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例,也就是设计者希望只有rt.jar中的类才能使用unsafe的功能. 因为虽然使用DirectbyeBuffer分配内存也会抛出内存异常,但抛出异常时并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配,于是手动抛出异常,真正申请分配内存的方法是:unsafe.allocateMemory(_1MB);</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/08/jvm/内存溢出/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/08/jvm/内存溢出/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/26/JavaSE/Java网络 BIO server/" title="java BIO服务器" itemprop="url">java BIO服务器</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-25T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>一个Java阻塞服务器实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(ServerSocket server =  <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>)) &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span>(<span class="keyword">final</span> Socket finalSocket = server.accept();) &#123;</span><br><span class="line">			Runnable runnable = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(finalSocket.getInputStream()));</span><br><span class="line">					PrintWriter out = <span class="keyword">new</span> PrintWriter(finalSocket.getOutputStream(), <span class="keyword">true</span>);) &#123;</span><br><span class="line"></span><br><span class="line">					String body = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">while</span> ((body = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">						System.out.println(<span class="string">"Server Revice： "</span> + body);</span><br><span class="line">						out.println(<span class="string">"Server -&gt; client"</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">9090</span>);</span><br><span class="line">	BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">			socket.getInputStream()));</span><br><span class="line">	PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);) &#123;</span><br><span class="line">	System.out.println(<span class="string">"Server Revice： "</span> + in.readLine());</span><br><span class="line">	out.println(<span class="string">"client -&gt; Server"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/26/JavaSE/Java网络 BIO server/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/26/JavaSE/Java网络 BIO server/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/25/JavaSE/Java网络 代理/" title="java代理" itemprop="url">java代理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-24T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="java-代理"><a href="#java-代理" class="headerlink" title="java 代理"></a>java 代理</h2><p>通过系统属性来指出本地代理服务器地址。 采用的参数有<code>http.proxyHost,http.proxyPort,http.nonProxyHost</code>以及三个相同的ftp协议开头的代理参数。 java不支持其他任何应用层协议,但如果对所有TCP连接都使用socks代理则可以使用<code>socksProxyHost</code>和<code>socksProxyPort</code>系统属性来确定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置代理服务器的ip地址</span></span><br><span class="line">System.setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"192.168.254.254"</span>);</span><br><span class="line"><span class="comment">// 设置代理服务器的端口</span></span><br><span class="line">System.setProperty(<span class="string">"http.proxyPort"</span>, <span class="string">"9000"</span>);</span><br><span class="line"><span class="comment">// 设置java.oreilly.com和xml.oreilly.com主机不被代理而是直接连接</span></span><br><span class="line">System.setProperty(<span class="string">"http.nonProxyHost"</span>, <span class="string">"java.oreilly.com|xml.oreilly.com"</span>);</span><br><span class="line"></span><br><span class="line">SocketAddress add = <span class="keyword">new</span> InetSocketAddress(<span class="string">"proxy.example.com"</span>, <span class="number">80</span>);</span><br><span class="line">Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, add);</span><br></pre></td></tr></table></figure></p>
<p>虚拟机都有一个为不同连接定位代理服务器的<code>ProxySelector</code> 对象. 默认的<code>ProxySelector</code>只检查各种系统属性和URL协议,决定如何连接到不同的主机.</p>
<p>下面<code>LocalProxySelect</code>是一个自己实现的选择器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalProxySelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ProxySelector select = <span class="keyword">new</span> LocalProxySelect();</span><br><span class="line">	<span class="comment">// 每个虚拟机只运行着一个ProxySelector对象.setDefault之后所以的连接都会询问这个代理</span></span><br><span class="line">	<span class="comment">// 因此不能在公共的环境下改变代理连接.  那ProxySelector要如何使用</span></span><br><span class="line">	ProxySelector.setDefault(select);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalProxySelect</span> <span class="keyword">extends</span> <span class="title">ProxySelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;Object&gt; failed = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// uri 连接所需的主机</span></span><br><span class="line"></span><br><span class="line">		List&lt;Proxy&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span>(failed.contains(uri) || <span class="string">"http"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">			result.add(Proxy.NO_PROXY);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 所有的连接都会使用proxy.example.com 进行代理</span></span><br><span class="line">			SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"proxy.example.com"</span>, <span class="number">8000</span>);</span><br><span class="line">			Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, address);</span><br><span class="line">			result.add(proxy);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri, SocketAddress sa, IOException ioe)</span> </span>&#123;</span><br><span class="line">		failed.add(uri);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面实现一个socket代理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	SocketAddress proxyAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"myproxy.example.com"</span>, <span class="number">1080</span>);</span><br><span class="line">	Proxy  proxy = <span class="keyword">new</span> Proxy(Proxy.Type.SOCKS, proxyAddress);</span><br><span class="line">	socket = <span class="keyword">new</span> Socket(proxy);</span><br><span class="line">	SocketAddress remote = <span class="keyword">new</span> InetSocketAddress(<span class="string">"login.ibiblio.org"</span>, <span class="number">25</span>);</span><br><span class="line">	socket.connect(remote);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(socket != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/25/JavaSE/Java网络 代理/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/25/JavaSE/Java网络 代理/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/23/JavaSE/Java网络 IP/" title="Java IP" itemprop="url">Java IP</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-22T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>InetAddress是对IP的高级表示</p>
<p>InetAddress将equals方法重写,如果俩个InetAddress对象的ip地址相同则判断这俩个对象相等.但是并不判断主机名是否相等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress i1 = InetAddress.getByName(<span class="string">"www.ibiblio.org"</span>);</span><br><span class="line">InetAddress i2 = InetAddress.getByName(<span class="string">"helios.metalab.unc.edu"</span>);</span><br></pre></td></tr></table></figure></p>
<p>InetAddress将hashCode方法重写,只对ip地址进行hashCode计算.如果俩个InetAddress对象的ip地址相同则判断这俩个对象的hashCode相等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress i1 = InetAddress.getByName(<span class="string">"www.ibiblio.org"</span>);</span><br><span class="line">InetAddress i2 = InetAddress.getByName(<span class="string">"helios.metalab.unc.edu"</span>);</span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, i1.hashCode() == i2.hashCode());</span><br></pre></td></tr></table></figure></p>
<p>下例中toString将主机名一起打印了出来. 但不是所有的InetAddress都含有主机名.java 1.4之后,如果没有主机名就会将其打印成空字符串,而不是像1.3之前的打印点分四段式ip地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress i1 = InetAddress.getByName(<span class="string">"www.ibiblio.org"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"www.ibiblio.org/152.19.134.40"</span>, i1.toString());</span><br></pre></td></tr></table></figure></p>
<p>使用DNS查找主机IP地址,该方法会试图连接本地DNS服务器. 如果没有找到主机会抛出UnknownHostException异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"localhost/127.0.0.1"</span>, address.toString());</span><br></pre></td></tr></table></figure></p>
<p>直接为IP地址创建一个InetAddress对象,但是它不会检查DNS服务器(不会主动查找主机名). 如果没有找到主机也不会抛出UnknownHostException异常. 只有当使用getHostName() 或者使用toString()时才会通过DNS查找主机名.如果没有找到主机名,那它会使用默认值(即点分四段或者16进制式地址)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"180.149.131.98"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"/180.149.131.98"</span>, address.toString());</span><br><span class="line">Assert.assertEquals(<span class="string">"180.149.131.98"</span>, address.getHostName());</span><br></pre></td></tr></table></figure></p>
<p>返回对应该主机名的所有地址,该方法会试图连接本地DNS服务器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InetAddress[] address = InetAddress.getAllByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line"><span class="keyword">for</span> (InetAddress inetAddress : address) &#123;</span><br><span class="line">System.out.println(<span class="string">"testGetAllByName_ok : "</span> + inetAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显示当前机器的IP地址.该方法会试图连接本地DNS服务器.just-PC 为本地DSN服务器为本地域中主机返回的主机名.该地址是路由分配地址(即内网使用的路由地址)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">Assert.assertEquals(<span class="string">"just-PC/192.168.1.101"</span>, address.toString());</span><br></pre></td></tr></table></figure></p>
<p>该方法会试图连接本地DNS服务器<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(<span class="string">""</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="string">"localhost/127.0.0.1"</span>, address.toString())<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>该方法会试图连接本地DNS服务器, 无法找到抛出UnknownHostException异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(<span class="string">"asd"</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取一个主机的字符串形式的主机名. 如果该主机没有主机名(没有在DNS注册)或者安全管理器(SecurityManager)确定阻止该主机名,就会返回点分四段式ip地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(<span class="string">"Host Name : "</span> + address.getHostName()); <span class="comment">// 本地主机名取决于本地NDS在解析本地主机名时的行为</span></span><br><span class="line">InetAddress address1 = InetAddress.getByName(<span class="string">"180.149.131.98"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"180.149.131.98"</span>, address1.getHostName());  <span class="comment">// 为什么没有返回主机名？？</span></span><br></pre></td></tr></table></figure></p>
<p>返回点分四段式ip地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">Assert.assertEquals(<span class="string">"192.168.1.101"</span>, address.getHostAddress());</span><br></pre></td></tr></table></figure></p>
<p>主要是用来测试地址类型是ipv4还是ipv6<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line"><span class="comment">// 返回网络字节顺序(最高位是数组的第一个字节)的字节数组形式的ip地址</span></span><br><span class="line"><span class="keyword">byte</span>[] arr = address.getAddress();  </span><br><span class="line"><span class="keyword">if</span>(arr.length == <span class="number">4</span>)</span><br><span class="line">System.out.print(<span class="string">"Address Type : IPv4---"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr.length == <span class="number">16</span>)</span><br><span class="line">System.out.print(<span class="string">"Address Type : IPv6---"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : arr) &#123;</span><br><span class="line">System.out.print(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试地址可达性,尝试连接远程主机的echo接口,查看是否可达. 该方法在全球Internet上并不可靠,防火墙会拦截java用于查看主机是否可大的网络协议<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"180.149.131.98"</span>);</span><br><span class="line">System.out.println(<span class="string">"is Rechable : "</span> + address.isReachable(<span class="number">5</span>));</span><br><span class="line">System.out.println(address.isReachable(InetAddress., ttl, timeout));</span><br></pre></td></tr></table></figure></p>
<p>测试是否是通配符地址. 通配符地址可匹配本地系统中所有地址. IPv4中通配符地址是0.0.0.0 IPv6是::<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isAnyLocalAddress();</span><br></pre></td></tr></table></figure></p>
<p>测试是否是回路地址. 回路地址在IP层连接同一台电脑,不使用任何物理硬件. 这就绕过了可能有问题的硬件设备进行测试  地址是127.0.0.1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isLoopbackAddress();</span><br></pre></td></tr></table></figure></p>
<p>测试是否是IPv6本地连接地址(以FE80开头地址,后8个字节用以太网mac地址(本地地址)填充). 这个地址有助于实现IPv6网络自动配置 ,并且不会将包转发出本地子网<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isLinkLocalAddress();</span><br></pre></td></tr></table></figure></p>
<p>测试是否是IPv6本地网站地址(以FEC0开头地址,后8个字节用以太网mac地址(本地地址)填充). 这个地址只会被路由器在网站内转发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isSiteLocalAddress();</span><br></pre></td></tr></table></figure></p>
<p>是否是组广播地址(IPV4:224.0.0.0-239.255.255.255) 向预定计算机进行广播<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMulticastAddress();</span><br></pre></td></tr></table></figure></p>
<p>测试是否是全球广播地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMCGlobal();</span><br></pre></td></tr></table></figure></p>
<p>组织范围内广播地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMCOrgLocal();</span><br></pre></td></tr></table></figure></p>
<p>是否是网站内组播地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMCSiteLocal();</span><br></pre></td></tr></table></figure></p>
<p>子网范围内组播地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMCLinkLocal();</span><br></pre></td></tr></table></figure></p>
<p>本地接口组播地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">address.isMCNodeLocal();</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/23/JavaSE/Java网络 IP/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/23/JavaSE/Java网络 IP/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/22/JavaSE/Java网络 Socket/" title="Java Socket" itemprop="url">Java Socket</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-21T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="socket-api"><a href="#socket-api" class="headerlink" title="socket api"></a>socket api</h2><h3 id="Socket-String-int-InetAddress-int"><a href="#Socket-String-int-InetAddress-int" class="headerlink" title="Socket(String, int, InetAddress, int)"></a><code>Socket(String, int, InetAddress, int)</code></h3><p>这个构造函数创建一个指向指定主机指定端口的TCP socket,并尝试连接远程socket.它连接到前俩个参数指定的主机上,从后俩个参数指定的本地网络接口和端口进行连接.本地网络接口<br>可以是物理的(如不同的以太网卡)或者虚拟的(一个多宿主主机).如果本地端口为0,会从1024-65535之间随机可用端口.之所以希望显示选择本地地址,这种情况可能出现在使用双以太网端口的路由器/防火墙上.入站连接会在一个接口接受,处理并通过另一个接口转发到本地网络.</p>
<blockquote>
<p><code>Socket(InetAddress, int, InetAddress, int)</code>作用与<code>Socket(String, int, InetAddress, int)</code>相同,只不过连接地址是通过InteAdderss进行连接</p>
</blockquote>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket()"></a><code>Socket()</code></h3><p>如果要要派生<code>Socket</code>子类或者实现一种特殊的socket,从而能加密事务或者理解本地代理服务器,此时就要用到这个函数.新的socket类的大部分实现要在一个<code>SocketImpl</code>对象中编写.该构造函数安装默认的<code>SocketImpl</code>(来自工厂方法或者<code>PlainSocketImpl</code>).</p>
<h3 id="Socket-String-int"><a href="#Socket-String-int" class="headerlink" title="Socket(String, int)"></a><code>Socket(String, int)</code></h3><p>这个构造函数创建一个指向指定主机指定端口的TCP socket,并尝试连接远程socket.</p>
<h3 id="Socket-InetAddress-int"><a href="#Socket-InetAddress-int" class="headerlink" title="Socket(InetAddress, int)"></a><code>Socket(InetAddress, int)</code></h3><p>这个构造函数创建一个指向指定主机指定端口的TCP socket,并尝试连接远程socket.在很少的情况下,当你向相同的主机打开很多socket时,先将主机名转换为InetAddress,然后重复使用此InetAddress是更有效的.</p>
<h3 id="connect-SocketAddress"><a href="#connect-SocketAddress" class="headerlink" title="connect(SocketAddress)"></a><code>connect(SocketAddress)</code></h3><p>我们一般使用INetSocketAddress</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a><code>close()</code></h3><p>对于socket敏感的程序,在垃圾回收器介入之前,系统会很快达到所能打开socket的上限.关闭一个<code>Socket</code>之后,其<code>InetAddress</code>,端口号,本地地址,本地端口号仍然可以通过<code>getInetAddress(),getPort(),getLocalAddress(),getLocalPort()</code></p>
<p>方法访问.不过虽然扔可以调用<code>getInputStream</code>或<code>getOutputStream()</code>,但试图从<code>InputStream</code>读取数据或者<code>OutputStream</code>写入数据抛出一个<code>IOException</code>异常.</p>
<h3 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream()"></a><code>getInputStream()</code></h3><p>返回一个输入流,可以将socket的数据读入程序</p>
<h3 id="getPort"><a href="#getPort" class="headerlink" title="getPort()"></a><code>getPort()</code></h3><p>获取Socket连接(或过去连接或将要连接)远程主机的哪个端口返回一个原始的<code>OutputStream</code>,用于将应用程序的数据写入socket另一端.出于性能原因,将其缓冲也是个好主意.</p>
<h3 id="getInetAddress"><a href="#getInetAddress" class="headerlink" title="getInetAddress()"></a><code>getInetAddress()</code></h3><p>socket连接哪台远程服务器,或者当连接已关闭时,告知它连接时所连接的是哪台主机</p>
<h3 id="getLocalAddress"><a href="#getLocalAddress" class="headerlink" title="getLocalAddress()"></a><code>getLocalAddress()</code></h3><p>获取socket绑定于哪个网络接口,一般会在多宿主主机或有多个网络接口的主机使用此方法</p>
<h3 id="setTcpNoDelay-boolean"><a href="#setTcpNoDelay-boolean" class="headerlink" title="setTcpNoDelay(boolean)"></a><code>setTcpNoDelay(boolean)</code></h3><p>设置<code>TCP_NODELAY</code>为<code>true</code>,可确保包会尽快地发送,而无论包的大小.正常情况下,小的包(1byte)在发送前会组合为大点的包.在发送另一个包之前,本地主机要等待远程系统对前一个包的响应,这称为<code>Nagle</code>算法.<code>Nagle</code>算法的问题是,如果远程系统没有尽可能快地将回应发送回本地系统,那么依赖于小数据量信息稳定传输的应用程序会变得很慢.为true关闭socket缓冲,为false再次打开socket缓冲.</p>
<h3 id="setSoLinger-boolean-int"><a href="#setSoLinger-boolean-int" class="headerlink" title="setSoLinger(boolean, int)"></a><code>setSoLinger(boolean, int)</code></h3><p>该设置规定了当socket关闭时如何处理尚未发送的数据报.如果socket关闭(close方法)系统仍会将剩余的数据发送出去.如果延迟时间为0,那所有未发送的数据都会被丢弃.如果延迟时间为任意正数,close方法会被堵塞指定秒数,等待数据发送和接受回应,该段时间过去后socket被关闭,将会关闭输出输入流,既不会接收到数据也不会在发送数据.</p>
<h3 id="sendUrgentData-int"><a href="#sendUrgentData-int" class="headerlink" title="sendUrgentData(int)"></a><code>sendUrgentData(int)</code></h3><h3 id="setOOBInline-boolean"><a href="#setOOBInline-boolean" class="headerlink" title="setOOBInline(boolean)"></a><code>setOOBInline(boolean)</code></h3><p>用于发送紧急数据</p>
<h3 id="setSoTimeout-int"><a href="#setSoTimeout-int" class="headerlink" title="setSoTimeout(int)"></a><code>setSoTimeout(int)</code></h3><p>当socket尝试读取数据时,<code>read</code>方法会阻塞尽可能长的时间来得到足够的字节.该选项就是确保此次调用阻塞的时间不会大于某个固定的毫秒数,如果阻塞时间长于固定毫秒数就会抛出<code>InterruptedIoException</code>.尽管抛出了该异常但是socket仍然是连接的.此次read失败,但是仍然可以尝试再次读取该socket</p>
<h3 id="setSendBufferSize-int"><a href="#setSendBufferSize-int" class="headerlink" title="setSendBufferSize(int)"></a><code>setSendBufferSize(int)</code></h3><p>设置socket网络输出的缓冲区字节数</p>
<h3 id="setReceiveBufferSize-int"><a href="#setReceiveBufferSize-int" class="headerlink" title="setReceiveBufferSize(int)"></a><code>setReceiveBufferSize(int)</code></h3><p>设置socket网络输入的缓冲区的字节数.大多数TCP栈使用缓冲区提升网络性能,较大的缓冲区会提升快速连接(比如10M或更快)的网络性能,而较慢的拨号连接在较小的缓冲区下表现更加.一般来讲,传输大的连续的数据块(在FTP和HTTP很常见),这可以从大缓冲区收益;而大缓冲区对交互式会话如<code>telnet</code>和许多游戏则没有多大帮助.</p>
<h3 id="setKeepAlive-boolean"><a href="#setKeepAlive-boolean" class="headerlink" title="setKeepAlive(boolean)"></a><code>setKeepAlive(boolean)</code></h3><p>启用<code>SO_KEEPALIVE</code>客户端会偶尔(一般俩个小时)利用一个空闲连接发送一个数据包,确保服务器没有崩溃.如果服务器没有响应,客户端会在11分钟之内持续发送此包,直到接受到服务器的回馈或者到12分钟左右直接将客户端关闭.</p>
<h3 id="setTrafficClass-int"><a href="#setTrafficClass-int" class="headerlink" title="setTrafficClass(int)"></a><code>setTrafficClass(int)</code></h3><h3 id="setReuseAddress-boolean"><a href="#setReuseAddress-boolean" class="headerlink" title="setReuseAddress(boolean)"></a><code>setReuseAddress(boolean)</code></h3><p>设置主机地址可重用</p>
<h3 id="getReuseAddress"><a href="#getReuseAddress" class="headerlink" title="getReuseAddress()"></a><code>getReuseAddress()</code></h3><p>socket关闭时,可能不会立即释放本地地址,一般会等待一段时间,确保所有寻址到待端口在网络上传输的数据接受到.关闭后一般接收到的数据报不会再进行任何处理,这么做是为了当有新的进程关联到该端口的时候不会接受到莫名其妙的数据.要想使用这个设置必须将老的socket如下设置</p>
<h3 id="shutdownInput"><a href="#shutdownInput" class="headerlink" title="shutdownInput()"></a><code>shutdownInput()</code></h3><p>半关闭连接.关闭socket的输入流,实际上这并不会关闭socket,但是它会影响与之连接的流认为已经到了流的末尾.即使半关闭了连接,甚至关闭了俩次,仍需要在结束使用时关闭socket.该方法只影响输出流,他们不释放与socket关联的资源,如占用的端口.</p>
<h3 id="shutdownOutput"><a href="#shutdownOutput" class="headerlink" title="shutdownOutput()"></a><code>shutdownOutput()</code></h3><h3 id="isConnected"><a href="#isConnected" class="headerlink" title="isConnected()"></a><code>isConnected()</code></h3><p>指向远端服务器.这个方法不能告诉你socket当前是否连接到远程主机,而是告知socket是否曾经连接过主机.如果socket能够连接到远程主机,则此主机返回为<code>true</code>,即使此时socket已被关闭.要判断socket当前是否打开,需要检查<code>isConnected()</code>返回<code>true</code>,并且<code>isClosed()</code>返回<code>false</code>.</p>
<h3 id="isBound"><a href="#isBound" class="headerlink" title="isBound()"></a><code>isBound()</code></h3><p> 指的是本地端,它告知socket是否绑定于本地系统的向外端口.</p>
<h3 id="isClosed"><a href="#isClosed" class="headerlink" title="isClosed()"></a><code>isClosed()</code></h3><p> 在socket已经关闭时返回<code>true</code>,未关闭时返回<code>false</code>.但是如果socket从未连接过也降返回<code>false</code>.</p>
<h3 id="isInputShutdown"><a href="#isInputShutdown" class="headerlink" title="isInputShutdown()"></a><code>isInputShutdown()</code></h3><h3 id="isOutputShutdown"><a href="#isOutputShutdown" class="headerlink" title="isOutputShutdown()"></a><code>isOutputShutdown()</code></h3><h3 id="setPerformancePreferences-int-int-int"><a href="#setPerformancePreferences-int-int-int" class="headerlink" title="setPerformancePreferences(int, int, int)"></a><code>setPerformancePreferences(int, int, int)</code></h3><h2 id="ServerSocket-api"><a href="#ServerSocket-api" class="headerlink" title="ServerSocket api"></a>ServerSocket api</h2><p>socket实现进程通信(实质上提供了进程通信的端点). 每一个socket用一个半相关描述:(协议，本地地址，本地端口). 一个完整的socket有一个本地唯一的socket号，由操作系统分配。于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别.</p>
<p>适用于在绑定端口前设置服务器socket选项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket socket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line"><span class="comment">// 设置socket选项</span></span><br><span class="line">SocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">socket.bind(address); <span class="comment">// 绑定端口</span></span><br></pre></td></tr></table></figure></p>
<p>在当前主机的所有网络接口或者所有IP地址的指定port上进行入站监听,如果port为0系统会随意指定一个端口<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">new</span> <span class="type">ServerSocket</span>(<span class="keyword">port</span>);</span><br></pre></td></tr></table></figure></p>
<p>在当前主机的所有网络接口或者所以IP地址的该指定port上进行入站监听.如果port为0系统会随意指定一个端口,queueLenght设置入栈请求的队列长度(如果队列超过最大值,会使用系统最大值)</p>
<p>第二个参数为backlog参数,accept()方法，该方法从队列中取出连接请求，使得队列能够及时的腾出空间，以容纳新的连接请求。 即ServerSocket构造函数中的backlog参数时，是可以serverSocket在不调用accept方法取出连接时，能接受的最大连接数<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ServerSocket(<span class="keyword">port</span>, queueLenght);</span><br></pre></td></tr></table></figure></p>
<p>在当前主机的指定的IP地址的指定port上进行入站监听(适用于多IP地址系统上运行的服务器)如果port为0系统会随意指定一个端口queueLenght设置入栈请求的队列长度(如果队列超过最大值,会使用系统最大值)<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">new</span> <span class="type">ServerSocket</span>(<span class="keyword">port</span>, queueLenght, address);</span><br></pre></td></tr></table></figure></p>
<p>关闭ServerSocket ：释放本地主机的绑定端口,允许其他程序继续使用释放掉的端口。终端ServerSocket接受的目前处于打开状态的所以Socket 关闭Socket .尽管在程序结束时ServerSocket会自动关闭但是尽量还是在程序中保证,当ServerSocket结束时将其手动关闭<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></p>
<p>检查ServerSocket是否打开.当关闭后isClosed会返回true, isBound指的是是否曾经绑定过端口,但是并不指现在的状态</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(!<span class="built_in">connect</span>.isClosed() &amp;&amp; <span class="built_in">connect</span>.isBound())</span><br><span class="line">	<span class="built_in">return</span> false;</span><br></pre></td></tr></table></figure>
<p>该选项是在accept抛出java.ioInterruptedIOException前等待入栈连接的时间,以毫秒计<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setSoTimeout</span><span class="params">(timeout)</span></span></span><br></pre></td></tr></table></figure></p>
<p>指定如果仍有旧的数据在网络上传输,新的程序是否可以绑定到该端口<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>.setReuseAddress(isSet);</span><br></pre></td></tr></table></figure></p>
<p>这相当于调用accept()返回的socket的socket.setReceiveBufferSize(size);可以在绑定服务器socket之前或之后设置此选项 除非要设置大于64K的缓冲区大小,这时对于未绑定的ServerSocket必须在绑定他之前设置这个选项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRcvBuf</span><span class="params">(ServerSocket connect)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		size = connect.getReceiveBufferSize();</span><br><span class="line">		<span class="keyword">if</span>(size &lt; <span class="number">131072</span>)</span><br><span class="line">			connect.setReceiveBufferSize(<span class="number">131072</span>);</span><br><span class="line">		connect.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/22/JavaSE/Java网络 Socket/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/22/JavaSE/Java网络 Socket/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/21/JavaSE/java网络 URL/" title="Java URL" itemprop="url">Java URL</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-20T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Java支持的传输协议：</p>
<ul>
<li>超文本传输协议: <code>http://www.baidu.com</code>        </li>
<li>安全http协议: <code>https://www.amazon.com/exec/obidos/order2</code></li>
<li>文件传输协议: <code>ftp://metalab.unc.edu/pub/languages/java/javafaq</code></li>
<li>简单邮件传输协议: <code>mailto:elharo@metalab.unc.edu</code></li>
<li>telnet协议: <code>telnet://dibner.poly.edu</code></li>
<li>本地文件访问协议: <code>file:</code></li>
<li>gopher: <code>gopher://gopher.anc.org.za</code></li>
<li>轻量级目录访问协议: <code>ldap://ldap.itd.umich.edu</code></li>
<li>jar: <code>jar://</code></li>
<li>NFS,网络文件协议: <code>nfs://utopia.poly.edu/usr/tmp</code></li>
<li>JDBC 定制协议   通过java.sql包支持: <code>jdbc:mysql://luna.matalab.unc.edu:3306/NEWS</code></li>
<li>rmi  远程方法的调用协议   通过java.rmi包支持: <code>rmi://metalab.unc.edu/RenderEngine</code></li>
<li>HotJava的定制协议: <code>doc:/UserGuide/release.html</code>,<code>netdoc:/UserGuide/release.html</code>, <code>systemresource://www.adc.org/+/index.html</code>, <code>verbatim:http://www.adc.org</code></li>
</ul>
<p>不带端口构造<code>URL</code>(需要注意的是：该构造器生成的URL端口为-1,所以回使用该协议的默认端口   第三个参数加反斜线也是需要注意的)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http"</span> , <span class="string">"www.eff.org"</span>, <span class="string">"/blueribbon.html#intro"</span>);</span><br></pre></td></tr></table></figure></p>
<p>带端口构造<code>URL</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http"</span> , <span class="string">"www.eff.org"</span>, <span class="number">8080</span>, <span class="string">"/blueribbon.html#intro"</span>);</span><br></pre></td></tr></table></figure></p>
<p>根据相对URL和基础URL构建一个绝对URL,当希望迭代处理位于相同目录下的一组文件时, 可以考虑使用该构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/javafaq/index.html"</span>);</span><br><span class="line">URL newURL = <span class="keyword">new</span> URL(url, <span class="string">"mailinglists.html"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"http://ibiblio.org/javafaq/mailinglists.html"</span>, newURL.toString());</span><br></pre></td></tr></table></figure></p>
<p>利用ClassLoader可以加载资源,例如图片 音频等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = ClassLoader.getSystemResource(<span class="string">"resource/simple.txt"</span>);</span><br><span class="line">Assert.assertEquals(<span class="keyword">null</span>, url);</span><br></pre></td></tr></table></figure></p>
<p>利用ClassLoader可以加载资源,例如图片 音频等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = getClass().getResource(<span class="string">"resource/simple.txt"</span>);</span><br><span class="line">Assert.assertEquals(<span class="keyword">null</span>, url);</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/javafaq/index.html"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"http"</span>, url.getProtocol());</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.ibiblio.org/javafaq/index.html"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"www.ibiblio.org"</span>, url.getHost());</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的路径 (范围：主机名后面的第一个/ 到片段标示符# 之前) 包含查询字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/nywc/compositions.pthml?category=Piano"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"/nywc/compositions.pthml?category=Piano"</span>, url.getFile());</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的路径 (范围：主机名后面的第一个/ 到片段标示符# 之前)  不包含查询字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/nywc/compositions.pthml?category=Piano"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"/nywc/compositions.pthml"</span>, url.getPath());</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的查询字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/nywc/compositions.pthml?category=Piano"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"category=Piano"</span>, url.getQuery());</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的查询字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"ftp://mp3:secret@ftp.example.com/c%3a/stuff/mp3"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"mp3:secret"</span>, url.getUserInfo());</span><br></pre></td></tr></table></figure></p>
<p>查看URL中的Authority(授权机构,包含用户信息,主机和端口.一般都回返回主机信息,但是不一定包含用户信息和端口)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"ftp://mp3:secret@ftp.example.com/c%3a/stuff/mp3"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"mp3:secret@ftp.example.com"</span>, url.getAuthority());</span><br></pre></td></tr></table></figure></p>
<p>sameFile 只是简单的测试url中的主机名是否是别名, 需要更细致的测试, sameFile 与 equals的区别是sameFile不考虑标示符儿equals需要考虑标示符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL u1 = <span class="keyword">new</span> URL(<span class="string">"http://www.ncsa.uiuc.edu/HTMLPrimer.html#GS"</span>);</span><br><span class="line">URL u2 = <span class="keyword">new</span> URL(<span class="string">"http://www.ncsa.uiuc.edu/HTMLPrimer.html#HD"</span>);</span><br><span class="line"><span class="keyword">if</span>(u1.sameFile(u2))</span><br><span class="line">	System.out.println(u1 + <span class="string">" is same file with "</span> + u2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(u1 + <span class="string">" is not same file with "</span> + u2);</span><br></pre></td></tr></table></figure></p>
<p>连接URl所指向的资源.执行客户端和服务器之间任何必要的握手.返回一个可以读取数据的<code>InputStream</code>,该流读取文件里的原始内容,不包括任何HTTP首部或者任何与协议有关的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>).openStream()) &#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="string">'&lt;'</span>) System.out.println();</span><br><span class="line">		System.out.write(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>openConnection</code>打开指定URL的socket,返回URLConnection对象(一个打开网络资源的连接)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URLConnection conn = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>).openConnection();</span><br><span class="line"><span class="keyword">try</span>(InputStream in = conn.getInputStream()) &#123;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">		System.out.write(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/21/JavaSE/java网络 URL/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/21/JavaSE/java网络 URL/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/20/JavaSE/Java网络 网卡/" title="Java网络接口" itemprop="url">Java网络接口</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-19T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>网络接口的命名</p>
<ul>
<li>eth0: ethernet的简写，一般用于以太网接口。</li>
<li>wifi0:wifi是无线局域网，因此wifi0一般指无线网络接口。</li>
<li>ath0: Atheros的简写，一般指Atheros芯片所包含的无线网络接口。</li>
<li>lo: local的简写，一般指本地环回接口。</li>
</ul>
<p>lo:虚拟网络接口,其并不真实地从外界接收和发送数据包，而是在系统内部接收和发送数据包，因此虚拟网络接口不需要驱动程序硬件网卡的网络接口由驱动程序创建。而虚拟的网络接口由系统创建或通过应用层程序创建。<br>假如包是由一个本地进程为另一个本地进程产生的, 它们将通过外出链的’lo’接口,然后返回进入链的’lo’接口</p>
<p>Java网络接口相关主要用到<code>java.net.NetworkInterface</code>这个类，其表示一个本地IP地址,该类可以是一个物理接口或者绑定于同一个物理接口的虚拟接口.</p>
<p>获取某个名的网络接口对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkInterface net = NetworkInterface.getByName(<span class="string">"eth0"</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取一个绑定于制定ip地址的网络接口对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">NetworkInterface net = NetworkInterface.getByInetAddress(address);</span><br></pre></td></tr></table></figure></p>
<p>列出本机所有的网络接口  包括物理或者虚拟网络接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;NetworkInterface&gt; nets = NetworkInterface.getNetworkInterfaces();</span><br><span class="line"><span class="keyword">while</span>(nets.hasMoreElements()) &#123;</span><br><span class="line"> System.out.println(<span class="string">"网络接口 ： "</span> + nets.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>列出本机所有绑定到该网络接口上的ip地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NetworkInterface net = NetworkInterface.getByName(<span class="string">"eth0"</span>);</span><br><span class="line"> Enumeration&lt;InetAddress&gt; address = net.getInetAddresses();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(address.hasMoreElements()) &#123;</span><br><span class="line">	 System.out.println(<span class="string">"IP 地址 ： "</span> + address.nextElement());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.NetworkInterface;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 获取全部的网络接口(由操作系统设置,每个硬件网卡(一个MAC)对应一个网络接口)</span></span><br><span class="line">		Enumeration&lt;?&gt; nets = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">		<span class="keyword">while</span> (nets.hasMoreElements()) &#123;</span><br><span class="line">			NetworkInterface net = (NetworkInterface) nets.nextElement();</span><br><span class="line">			printNetworkInterface(net);</span><br><span class="line">			Enumeration&lt;?&gt; addresses = net.getInetAddresses();  <span class="comment">// 返回该接口中所有绑定的ip</span></span><br><span class="line">			System.out.println(<span class="string">"该接口下所有的ip:"</span>);</span><br><span class="line">			<span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">				InetAddress ip = (InetAddress) addresses.nextElement();</span><br><span class="line">                pickUpHosyAddress(ip);</span><br><span class="line">				printInetAddress(ip);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNetworkInterface</span><span class="params">(NetworkInterface net)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"网络接口的显示名称   :"</span> + net.getDisplayName());</span><br><span class="line">		System.out.println(<span class="string">"网络接口的名称       :"</span> + net.getName());</span><br><span class="line">		System.out.println(<span class="string">"idx                	:"</span> + net.getIndex());</span><br><span class="line">		System.out.println(<span class="string">"最大传输单元         :"</span> + net.getMTU());</span><br><span class="line">		System.out.println(<span class="string">"mac地址              :"</span> + displayMac(net.getHardwareAddress()));</span><br><span class="line">		System.out.println(<span class="string">"是否是回送接口       :"</span> + net.isLoopback());</span><br><span class="line">		System.out.println(<span class="string">"是否是点对点接口     :"</span> + net.isPointToPoint());</span><br><span class="line">		System.out.println(<span class="string">"是否已经开启并运行   :"</span> + net.isUp());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 输出ip地址</span><br><span class="line">	 * <span class="doctag">@param</span> ip</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pickUpHosyAddress</span><span class="params">(InetAddress ip)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ip.isLoopbackAddress() &amp;&amp; !ip.isSiteLocalAddress() &amp;&amp; ip.getHostAddress().indexOf(<span class="string">":"</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"外网 HostAddress   :"</span> + ip.getHostAddress());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ip.isLoopbackAddress() &amp;&amp; !ip.isSiteLocalAddress() &amp;&amp; ip.getHostAddress().indexOf(<span class="string">":"</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"内网 HostAddress   :"</span> + ip.getHostAddress());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ip != <span class="keyword">null</span> &amp;&amp; !ip.isLoopbackAddress() &amp;&amp; ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">			System.out.println(<span class="string">"HostAddress        :"</span> + ip.getHostAddress());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 打印InetAddress 相关信息</span><br><span class="line">	 * <span class="doctag">@param</span> ip</span><br><span class="line">	 * <span class="doctag">@throws</span> Exception</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInetAddress</span><span class="params">(InetAddress ip)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"远程主机的主机名         :"</span> + ip.getCanonicalHostName());</span><br><span class="line">		System.out.println(<span class="string">"主机地址                 :"</span> + ip.getHostAddress());</span><br><span class="line">		System.out.println(<span class="string">"远程主机的别名           :"</span> + ip.getHostName());</span><br><span class="line">		System.out.println(<span class="string">"mac Address             :"</span> + displayMac(ip.getAddress()));</span><br><span class="line">		System.out.println(<span class="string">"本机主机名               :"</span> + ip.getLocalHost().getHostName());</span><br><span class="line">		System.out.println(<span class="string">"回环地址 主机名          :"</span> + ip.getLoopbackAddress().getHostName());</span><br><span class="line">		<span class="comment">// (127.0.0.0 ~ 127.255.255.255)</span></span><br><span class="line">		System.out.println(<span class="string">"是否是本机的IP地址       :"</span> + ip.isLoopbackAddress());</span><br><span class="line">		<span class="comment">//(10.0.0.0 ~ 10.255.255.255)(172.16.0.0 ~ 172.31.255.255)(192.168.0.0 ~ 192.168.255.255)</span></span><br><span class="line">		System.out.println(<span class="string">"是否是地区本地地址       :"</span> + ip.isSiteLocalAddress());</span><br><span class="line">		<span class="comment">// 允许服务器主机接受来自任何网络接口的客户端连接</span></span><br><span class="line">		System.out.println(<span class="string">"是否是通配符地址         :"</span> + ip.isAnyLocalAddress());</span><br><span class="line">		<span class="comment">// (169.254.0.0 ~ 169.254.255.255)</span></span><br><span class="line">		System.out.println(<span class="string">"是否是本地连接地址       :"</span> + ip.isLinkLocalAddress());</span><br><span class="line">		<span class="comment">// (224.0.0.0 ~ 239.255.255.255)广播地址可以向网络中的所有计算机发送信息</span></span><br><span class="line">		System.out.println(<span class="string">"是否是 广播地址           :"</span> + ip.isMulticastAddress());</span><br><span class="line">		<span class="comment">//  除了(224.0.0.0)和第一个字节是239的IP地址都是全球范围的广播地址</span></span><br><span class="line">		System.out.println(<span class="string">"是否是全球范围的广播地址:"</span> + ip.isMCGlobal());</span><br><span class="line">		<span class="comment">// (224.0.0.0 ~ 224.0.0.255)</span></span><br><span class="line">		System.out.println(<span class="string">"是否是子网广播地址         :"</span> + ip.isMCLinkLocal());</span><br><span class="line">		<span class="comment">// 本地接口广播地址不能将广播信息发送到产生广播信息的网络接口</span></span><br><span class="line">		<span class="comment">// 所有的IPv4广播地址都不是本地接口广播地址。</span></span><br><span class="line">		System.out.println(<span class="string">"是否是本地接口广播地址      :"</span> + ip.isMCNodeLocal());</span><br><span class="line">		<span class="comment">// 可以向公司或企业内部的所有的计算机发送广播信息</span></span><br><span class="line">		<span class="comment">// IPv4的组织范围广播地址的第一个字节是239，第二个字节不小于192，第三个字节不大于195</span></span><br><span class="line">		System.out.println(<span class="string">"是否是组织范围的广播地址:"</span> + ip.isMCOrgLocal());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">displayMac</span><span class="params">(<span class="keyword">byte</span>[] mac)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mac == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuilder bufferBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mac.length; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span> b = mac[i];</span><br><span class="line">			<span class="keyword">int</span> intValue = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (b &gt;= <span class="number">0</span>)</span><br><span class="line">				intValue = b;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				intValue = <span class="number">256</span> + b;</span><br><span class="line">			bufferBuilder.append(Integer.toHexString(intValue));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i != mac.length - <span class="number">1</span>)</span><br><span class="line">				bufferBuilder.append(<span class="string">"-"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bufferBuilder.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/20/JavaSE/Java网络 网卡/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/20/JavaSE/Java网络 网卡/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/19/JavaSE/Java网络/" title="java网络基础" itemprop="url">java网络基础</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-18T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Java里使用的是TCP/IP</p>
<ul>
<li>应用层协议：(例如Http协议) 该层数据由下三层协议共同制定</li>
<li>传输层协议：(常用TCP,UDP)(ICMP Ping命令基于该协议). 该层协议用于确保数据报以发送时的顺序接受,并且不会丢包. 如果发现顺序有误,或者数据丢失,则可要求对方重新发送数据(TCP会要求这一点, 但是UDP协议只是检查数据发送顺序,以及数据是否丢失并不要求对方重传数据)</li>
<li>网络层协议：(使用最广泛的是IP协议)<blockquote>
<p>网络层第一任务是对数据位或者字节进行分组,打成包(包内数据称为数据报).网络层第二任务定义了主机彼此间的寻址方式(例如IPV4用四个字节来标识一个地址).在JAVA里,IP协议是它唯一理解的网络层协议.</p>
</blockquote>
</li>
</ul>
<p>IP数据报格式<br>链路层协议：定义了网络接口(以太网接口或者环牌接口)</p>
<p>谈一下Internet地址分类 (具体定义参考 WIKI IP地址), IP地址分为A,B,C,D,E,F类 (E,F分别作为广播地址这里不说了)</p>
<ul>
<li>A类地址 第一个字节固定</li>
<li>B类地址 前俩个地址固定</li>
<li>C类地址 前三个地址固定<br>这里所说的固定指的是ISP给你的时候就固定了,你只能使用固定之后几位的地址.例如给了你一个C类地址 那么你只有256个地址可以使用.</li>
</ul>
<p>后来为了节约地址,出现了CIDR  用/nn 指定前几位为固定的.例如/24 为前24位即前三个字节是固定的也就是一个c类地址.这么着就拟补了有的组织使用的IP大于c类却远远小于B类而造成的地址浪费.</p>
<p>在这里需要特殊说明的是有一些非路由地址,例如10; 192.16或者172.16到172.31 开头的地址.这些地址用于构建组织内部网路(例如家里只有一个IP但是却有很多设备,这时就需要通过路由为这些设备分配IP地址了),或者一些大型组织使用C类地址时非常有用<br>路由器会将非路由地址转换为外部地址</p>
<p>URI<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:scheme-specific-part (模式:模式特有部分)</span><br></pre></td></tr></table></figure></p>
<p>URI模式包含 data, file, ftp, http, news, telnet, urn (还有基于JAVA的rmi, jndi 等非标准模式,也称为protocol)<br>例如：<code>http://www.ming15.wang/2015/10/13/%E5%B7%A5%E5%85%B7/2015-10-12-AWK/</code>这个例子中模式为<code>http</code>, 负责解析该URI的机构<code>ming15.wang</code> 负责将<code>/2015/10/13/%E5%B7%A5%E5%85%B7/2015-10-12-AWK/</code>地址映射到主机资源</p>
<p>还有的URI路径中含有? 这是URI的查询部分.后面紧跟查询参数,多个参数用&amp;分割. 例如：<code>git@github.com:ming15/VertxServer.git</code>该URI中模式为<code>git</code> 解析结构为<code>github.com</code> 还可以在git和@之间加上用户名和密码<code>git://username:password@github.com:ming15/VertxServer.git</code></p>
<p>URI一般由以下组成</p>
<ul>
<li>模式</li>
<li>URI解析结构</li>
<li>资源路径</li>
<li>查询参数构成</li>
</ul>
<h3 id="URI分为类"><a href="#URI分为类" class="headerlink" title="URI分为类"></a>URI分为类</h3><ol>
<li>URL ： 指向Internet上某个位置的某个文件.用于标识Internet上的资源位置. 指定访问服务器的协议, 服务器名, 文件在次服务器上的位置<code>protocol://username@hostname:port/path/filename?query##fragment</code>协议可以看成是模式但是它不包含URN.</li>
<li>URN ：不指向位置的资源名.  (具体的内容参考例子磁力链接)<code>urn:namespace:resource_name</code>. <code>namespace</code>:某个授权机构维护的某类资源的集合名.  <code>resource_name</code> 集合中的资源名</li>
</ol>
<p>这里简述一下相对URL. 举例来说<code>&lt;a href=&quot;java.html&quot;&gt;</code> 这个超链接会继承父文档(当前文档)的协议, 主机名, 资源路径<code>.java.html</code>会替换掉,父文档里最后的文件名,还有例如<code>&lt;a href=&quot;/demo/java.html&quot;&gt;</code>那这个超链接会将主机名后的资源路径一起换掉 ，用该路径替换</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/19/JavaSE/Java网络/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/19/JavaSE/Java网络/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/08/mgits/gitbook/" title="gitbook使用" itemprop="url">gitbook使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-09-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-09-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="安装gitbook命令行"><a href="#安装gitbook命令行" class="headerlink" title="安装gitbook命令行"></a>安装gitbook命令行</h1><ol>
<li>下载安装<code>npm</code>和<code>io.js</code></li>
<li>安装<code>git</code>, <code>gitbook</code>需要依赖<code>git</code>.</li>
<li>将<code>git</code>的<code>bin</code>目录放到环境变量<code>Path</code>里</li>
<li>在windows下npm module一般都是安装到<code>C:\Users\Administrator\AppData\Roaming\npm\node_modules</code>这<br> 里,所以为了我们能够使用安装好的module,我们将这个路径添加到环境变量<code>Path</code>里</li>
<li>然后使用<code>npm install gitbook-cli -g</code> 安装gitbook</li>
<li>最后验证一下gitbook是否安装成功： <code>gitbook -V</code> 我安装的是<code>0.3.3</code>, 所以在命令行里直接输出了<code>0.3.3</code></li>
</ol>
<h1 id="gitbook-github简历博客"><a href="#gitbook-github简历博客" class="headerlink" title="gitbook + github简历博客"></a>gitbook + github简历博客</h1><p>我们假设下列所有操作都在<code>D:\git</code>这个目录下操作</p>
<ol>
<li>我们将github上创建的项目<code>demo</code>检出到<code>D:\git</code>目录里,最好你也是用svn检出的，因为我是在svn检出的前提下写了个小工具</li>
<li>然后我们进入到<code>D:\git\demo</code>目录里,我们会看到<code>branches</code>和<code>trunk</code>俩个文件夹,<code>branches</code>用于存储博客的web文件,<code>trunk</code>用于存放博客的<code>markdown</code>源文件</li>
<li>接着我们进入到<code>D:\git\demo\trunk</code>新建<code>blog</code>文件夹</li>
<li>进入到<code>D:\git\demo\trunk\blog</code>在这个目录里新建一个<code>build.bat</code>批处理脚本文件,同时创建一个<code>repository</code></li>
<li><code>build.bat</code>批处理脚本文件内容为<code>gitbook build ./repository ../../branches/gh-pages</code></li>
<li>我们使用gitbook客户端在<code>repository</code>文件夹内创建一个gitbook项目</li>
<li>双击运行<code>build.bat</code></li>
<li>查看<code>D:\git\demo\branches\gh-pages</code>是否生成了一个web站点呢？这个就是我们的博客了</li>
<li>最后在<code>D:\git\demo</code>这个目录里上传所有的文件就好了</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/mgits/">mgits</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/08/mgits/gitbook/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/08/mgits/gitbook/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovy/" title="groovy注释和标识符" itemprop="url">groovy注释和标识符</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>想要使用单行注释, 使用<code>//</code>就可以了.  本行中<code>//</code>后续的内容都会被认为是注释的一部分<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a standalone single line comment</span></span><br><span class="line">println <span class="string">"hello"</span> <span class="comment">// a comment till the end of the line</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释从<code>/*</code>开始, 直到<code>*/</code>结束(跨行也包含在内)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a standalone multiline comment</span><br><span class="line">spanning two lines */</span></span><br><span class="line">println <span class="string">"hello"</span> <span class="comment">/* a multiline comment starting</span><br><span class="line">at the end of a statement */</span></span><br><span class="line">println <span class="number">1</span> <span class="comment">/* one */</span> + <span class="number">2</span> <span class="comment">/* two */</span></span><br></pre></td></tr></table></figure></p>
<h4 id="GroovyDoc-注释"><a href="#GroovyDoc-注释" class="headerlink" title="GroovyDoc 注释"></a>GroovyDoc 注释</h4><p><code>GroovyDoc</code> 注释也是多行的, 但是它是以<code>/**</code>开始, <code>*/</code>结束定义的.<br>这种注释一般用于以下情况：</p>
<ul>
<li>类型定义(包含 classes, interfaces, enums, annotations)</li>
<li>字段和属性定义</li>
<li>方法定义</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * A Class description</span><br><span class="line">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">     <span class="comment">/** the name of the person */</span></span><br><span class="line">     String name</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span><br><span class="line">      * Creates a greeting method for a certain person.</span><br><span class="line">      *</span><br><span class="line">      * <span class="doctag">@param</span> otherPerson the person to greet</span><br><span class="line">      * <span class="doctag">@return</span> ag reeting message</span><br><span class="line">      */</span></span><br><span class="line">     String greet(String otherPerson) &#123;</span><br><span class="line">        <span class="string">"Hello $&#123;otherPerson&#125;"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shebang-line"><a href="#Shebang-line" class="headerlink" title="Shebang line"></a>Shebang line</h3><p>除了上面提到的单行注释外, 还有一种特殊的单行注释.这种注释在UNIX系统下通常称为shebang线, 这种注释允许脚本直接在命令行里执行( 但是前提是你已经在系统是安装了<code>groovy</code>,并且在<code>PATH</code>里进行了配置)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println <span class="string">"Hello from the shebang line"</span></span><br></pre></td></tr></table></figure>
<p><code>#</code>字符必须是这个文件里的第一个字符,否则编译器将会抛出一个编译错误.</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="普通标识符"><a href="#普通标识符" class="headerlink" title="普通标识符"></a>普通标识符</h3><p>标识符以一个<code>字母</code>或者<code>$</code>或者<code>_</code>开始, 不能以数字打头.<br>如果以字母打头,他们在下列范围内</p>
<ul>
<li>‘a’ to ‘z’ (lowercase ascii letter)</li>
<li>‘A’ to ‘Z’ (uppercase ascii letter)</li>
<li>‘\u00C0’ to ‘\u00D6’</li>
<li>‘\u00D8’ to ‘\u00F6’</li>
<li>‘\u00F8’ to ‘\u00FF’</li>
<li>‘\u0100’ to ‘\uFFFE’</li>
</ul>
<p>剩下的字符就可以包含字母或者数字了.  下面列举了一些合法的标识符：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name</span><br><span class="line"><span class="keyword">def</span> item3</span><br><span class="line"><span class="keyword">def</span> with_underscore</span><br><span class="line"><span class="keyword">def</span> $dollarStart</span><br></pre></td></tr></table></figure></p>
<p>下面是一些非法的标识符<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 3tier</span><br><span class="line">def a+b</span><br><span class="line">def a#b</span><br></pre></td></tr></table></figure></p>
<p><code>.</code>后面的关键字也是合法的标识符<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo.<span class="keyword">as</span></span><br><span class="line">foo.<span class="keyword">assert</span></span><br><span class="line">foo.<span class="keyword">break</span></span><br><span class="line">foo.<span class="keyword">case</span></span><br><span class="line">foo.<span class="keyword">catch</span></span><br></pre></td></tr></table></figure></p>
<h3 id="带引号的标识符"><a href="#带引号的标识符" class="headerlink" title="带引号的标识符"></a>带引号的标识符</h3><p>带引号的标识符出现在<code>.\</code>. 例如<code>person.name</code>表达式中的<code>name</code>部分能通过这俩种方式引起来<code>person.&quot;name&quot;</code>或者<code>person.\&#39;name&#39;</code>. 当特定标识符中包含非法字符(java语言禁止的字符),但是通过引号的方式可以达到在Groovy的合法. 例如,一个破折号,一个空格,一个感叹号,<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"></span><br><span class="line">map.<span class="string">"an identifier with a space and double quotes"</span> = <span class="string">"ALLOWED"</span></span><br><span class="line">map.<span class="string">'with-dash-signs-and-single-quotes'</span> = <span class="string">"ALLOWED"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">"an identifier with a space and double quotes"</span> == <span class="string">"ALLOWED"</span></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">'with-dash-signs-and-single-quotes'</span> == <span class="string">"ALLOWED"</span></span><br></pre></td></tr></table></figure></p>
<p>正像一会我们在strings模块看到的一样, Groovy提供了不同的string字面量. 以下所列举的都是合法的<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="string">'single quote'</span></span><br><span class="line">map.<span class="string">"double quote"</span></span><br><span class="line">map.<span class="string">'''triple single quote'''</span></span><br><span class="line">map.<span class="string">"""triple double quote"""</span></span><br><span class="line">map.<span class="regexp">/slashy string/</span></span><br><span class="line">map.<span class="string">$/dollar slashy string/$</span></span><br></pre></td></tr></table></figure></p>
<p>strings 和 Groovy’s GStrings 在纯字符上面是有一点不同的,as in that the latter case, the interpolated values are inserted in the final string for evaluating the whole identifier:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> firstname = <span class="string">"Homer"</span></span><br><span class="line">map.<span class="string">"Simson-$&#123;firstname&#125;"</span> = <span class="string">"Homer Simson"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">'Simson-Homer'</span> == <span class="string">"Homer Simson"</span></span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovy/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovy/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovyIO/" title="groovy IO" itemprop="url">groovy IO</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>作为第一个例子,让我们看一下,如何输出一个文本文件里的所有行<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir, <span class="string">'haiku.txt'</span>).eachLine &#123; line -&gt;</span><br><span class="line">    println line</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>eachLine</code>方法是Groovy自动添加到File Class的,同时呢,Groovy还添加了很多变量,例如,你如果想要知道每一行的行号,你可以使用这个变量:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir, <span class="string">'haiku.txt'</span>).eachLine &#123; line, nb -&gt;</span><br><span class="line">    println <span class="string">"Line $nb: $line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论由于什么原因, 当<code>eachLine</code>中抛出了异常,这个方法都会确保,资源已经被正确的关闭掉了. 这对所有Groovy自动添加的关于I/O资源的方法都有效.</p>
<p>例如, 某种情况你使用了<code>Reader</code>, 但是你还想让Groovy自己管理资源. 下面这个例子, 即使抛出了exception, reader仍然会被自动关闭.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> count = <span class="number">0</span>, MAXSIZE = <span class="number">3</span></span><br><span class="line"><span class="keyword">new</span> File(baseDir,<span class="string">"haiku.txt"</span>).withReader &#123; reader -&gt;</span><br><span class="line">    <span class="keyword">while</span> (reader.readLine()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++count &gt; MAXSIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">'Haiku should only have 3 verses'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你想要把文本文件中每一行都放进一个list中, 你可以这么做:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = <span class="keyword">new</span> File(baseDir, <span class="string">'haiku.txt'</span>).collect &#123;it&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者你想利用操作符将文件中每一行都添加到一个数组中:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> array = <span class="keyword">new</span> File(baseDir, <span class="string">'haiku.txt'</span>) <span class="keyword">as</span> String[]</span><br></pre></td></tr></table></figure></p>
<p>下面这个示例,非常简单的实现了,将一个文件存进一个字节数组里:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] contents = file.bytes</span><br></pre></td></tr></table></figure></p>
<p>如下例,我们轻松地获得了一个输入流.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> is = <span class="keyword">new</span> File(baseDir,<span class="string">'haiku.txt'</span>).newInputStream()</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">is.close()</span><br></pre></td></tr></table></figure></p>
<p>上个例子中我们获得了一个输入流,但是最后我们不得不手动关闭它, Groovy提供另一个方法<code>withInputStream</code>, 这个方法可以帮我们自动的关闭输入流.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir,<span class="string">'haiku.txt'</span>).withInputStream &#123; stream -&gt;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>有时候,你需要的也许只是写文件,下面展示了,如何在Groovy中写文件<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir,<span class="string">'haiku.txt'</span>).withWriter(<span class="string">'utf-8'</span>) &#123; writer -&gt;</span><br><span class="line">    writer.writeLine <span class="string">'Into the ancient pond'</span></span><br><span class="line">    writer.writeLine <span class="string">'A frog jumps'</span></span><br><span class="line">    writer.writeLine <span class="string">'Water’s sound!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但对于一个要求很简单的需求来说,我们可以使用<code>&lt;&lt;</code>向文件中写<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir,<span class="string">'haiku.txt'</span>) &lt;&lt; <span class="string">'''Into the ancient pond</span><br><span class="line">A frog jumps</span><br><span class="line">Water’s sound!'''</span></span><br></pre></td></tr></table></figure></p>
<p>当然不是每一次我们都是向文件中输出文本,下面的例子演示了,我们如何向一个文件中写入字节:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.bytes = [<span class="number">66</span>,<span class="number">22</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure></p>
<p>当然,你也可以直接打开一个输出流,下面的例子演示了如何开启一个输出流.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> os = <span class="keyword">new</span> File(baseDir,<span class="string">'data.bin'</span>).newOutputStream()</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">os.close()</span><br></pre></td></tr></table></figure></p>
<p>同<code>newInputStream</code>一样,<code>newOutputStream</code>同样需要手动关闭, ok,你大概想到了<code>withOutputStream</code>:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> File(baseDir,<span class="string">'data.bin'</span>).withOutputStream &#123; stream -&gt;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h3><p>在脚本中, 有个很常用的需求就是,遍历一个目录,然后找到一个文件,进行某些操作. Groovy提供了很多方法,来达到这个效果. 下面的例子演示了将一个目录下的所有文件都执行某个操作:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir.eachFile &#123; file -&gt;                      (<span class="number">1</span>)</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br><span class="line">dir.eachFileMatch(<span class="regexp">~/.*\.txt/</span>) &#123; file -&gt;     (<span class="number">2</span>)</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>在目录下的每个文件上执行闭包操作.</li>
<li>根据正则表达式在目录下找到符合条件的文件,然后执行闭包操作.</li>
</ol>
<p>也许你想要遍历某个目录和目录里的所有子目录, 那么你可以使用<code>eachFileRecurse</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir.eachFileRecurse &#123; file -&gt;                      (<span class="number">1</span>)</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dir.eachFileRecurse(FileType.FILES) &#123; file -&gt;      (<span class="number">2</span>)</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对目录里的所有子目录进行递归, 然后对找到的文件和目录进行闭包操作</li>
<li>对目录里进行递归查找,但是只查找文件.</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir.traverse &#123; file -&gt;</span><br><span class="line">    <span class="keyword">if</span> (file.directory &amp;&amp; file.name==<span class="string">'bin'</span>) &#123;</span><br><span class="line">        FileVisitResult.TERMINATE                   (<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println file.name</span><br><span class="line">        FileVisitResult.CONTINUE                    (<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果找到的文件是目录,且它的名字是”dir”, 则停止遍历</li>
<li>打印出文件的名字,接着遍历</li>
</ol>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>在java中会使用<code>java.io.DataOutputStream</code> 序列化数据也不罕见. Groovy对这个需求也做了非常简单的实现, 下面的例子演示了如何序列化和反序列化:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="literal">true</span></span><br><span class="line">String message = <span class="string">'Hello from Groovy'</span></span><br><span class="line"><span class="comment">// Serialize data into a file</span></span><br><span class="line">file.withDataOutputStream &#123; out -&gt;</span><br><span class="line">    out.writeBoolean(b)</span><br><span class="line">    out.writeUTF(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Then read it back</span></span><br><span class="line">file.withDataInputStream &#123; input -&gt;</span><br><span class="line">    <span class="keyword">assert</span> input.readBoolean() == b</span><br><span class="line">    <span class="keyword">assert</span> input.readUTF() == message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样,如果这个数据实例了序列化接口<code>Serializable</code>, 你可以使用 object output stream将整个数据序列化到文件:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">name:</span><span class="string">'Bob'</span>, <span class="string">age:</span><span class="number">76</span>)</span><br><span class="line"><span class="comment">// Serialize data into a file</span></span><br><span class="line">file.withObjectOutputStream &#123; out -&gt;</span><br><span class="line">    out.writeObject(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Then read it back</span></span><br><span class="line">file.withObjectInputStream &#123; input -&gt;</span><br><span class="line">    <span class="keyword">def</span> p2 = input.readObject()</span><br><span class="line">    <span class="keyword">assert</span> p2.name == p.name</span><br><span class="line">    <span class="keyword">assert</span> p2.age == p.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>前面的章节介绍了在Groovy中操作files, readers or streams非常简单. 然而, 像系统管理员或者开发者,可能更多的是执行一个系统命令.</p>
<p>Groovy同样提供了非常简单的方式执行命令行命令. 只需要定义一个命令的字符串,然后执行这个字符串的<code>execute()</code>. 在类Unix系统中(如果在windows中也安装了类Unix命令行工具也算),你可以这样执行命令.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">"ls -l"</span>.execute()             (<span class="number">1</span>)</span><br><span class="line">println <span class="string">"Found text $&#123;process.text&#125;"</span>        (<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>在外部过程(external process)执行ls命令</li>
<li>获得命令的输出,并输出</li>
</ol>
<p><code>execute()</code>方法返回一个<code>java.lang.Process</code>实例, 随后选择一种输出流<code>in/out/err</code>, 同时检查<code>exit</code>值,查看是否命令执行完毕.</p>
<p>下面的例子使用了和刚才那个例子一样的命令,但是现在我们每次都会对获得的结果进行行输出.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">def</span> process = <span class="string">"ls -l"</span>.execute()             (<span class="number">1</span>)</span><br><span class="line">            process.<span class="keyword">in</span>.eachLine &#123; line -&gt;               (<span class="number">2</span>)</span><br><span class="line">                println line                            (<span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> process <span class="keyword">instanceof</span> Process</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testProcessConsumeOutput() &#123;</span><br><span class="line">        <span class="keyword">if</span> (unixlike) &#123;</span><br><span class="line">            doInTmpDir &#123; b -&gt;</span><br><span class="line">                File file = <span class="literal">null</span></span><br><span class="line">                <span class="keyword">def</span> tmpDir = b.tmp &#123;</span><br><span class="line">                    file = <span class="string">'foo.tmp'</span>(<span class="string">'foo'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> file.exists()</span><br><span class="line">                <span class="keyword">def</span> p = <span class="string">"rm -f foo.tmp"</span>.execute([], tmpDir)</span><br><span class="line">                p.consumeProcessOutput()</span><br><span class="line">                p.waitFor()</span><br><span class="line">                <span class="keyword">assert</span> !file.exists()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testProcessPipe() &#123;</span><br><span class="line">        <span class="keyword">if</span> (unixlike) &#123;</span><br><span class="line">            doInTmpDir &#123; b -&gt;</span><br><span class="line">                <span class="keyword">def</span> proc1, proc2, proc3, proc4</span><br><span class="line">                proc1 = <span class="string">'ls'</span>.execute()</span><br><span class="line">                proc2 = <span class="string">'tr -d o'</span>.execute()</span><br><span class="line">                proc3 = <span class="string">'tr -d e'</span>.execute()</span><br><span class="line">                proc4 = <span class="string">'tr -d i'</span>.execute()</span><br><span class="line">                proc1 | proc2 | proc3 | proc4</span><br><span class="line">                proc4.waitFor()</span><br><span class="line">                <span class="keyword">if</span> (proc4.exitValue()) &#123;</span><br><span class="line">                    println proc4.err.text</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    println proc4.text</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">def</span> sout = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">                <span class="keyword">def</span> serr = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">                proc2 = <span class="string">'tr -d o'</span>.execute()</span><br><span class="line">                proc3 = <span class="string">'tr -d e'</span>.execute()</span><br><span class="line">                proc4 = <span class="string">'tr -d i'</span>.execute()</span><br><span class="line">                proc4.consumeProcessOutput(sout, serr)</span><br><span class="line">                proc2 | proc3 | proc4</span><br><span class="line">                [proc2, proc3].each &#123; it.consumeProcessErrorStream(serr) &#125;</span><br><span class="line">                proc2.withWriter &#123; writer -&gt;</span><br><span class="line">                    writer &lt;&lt; <span class="string">'testfile.groovy'</span></span><br><span class="line">                &#125;</span><br><span class="line">                proc4.waitForOrKill(<span class="number">1000</span>)</span><br><span class="line">                println <span class="string">"Standard output: $sout"</span></span><br><span class="line">                println <span class="string">"Standard error: $serr"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">        String name</span><br><span class="line">        <span class="keyword">int</span> age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1    executes the ls command in an external process<br>2    for each line of the input stream of the process<br>3    print the line</p>
<ol>
<li>在外部进程中执行ls命令<br>2.</li>
</ol>
<p>It is worth noting that in corresponds to an input stream to the standard output of the command. out will refer to a stream where you can send data to the process (its standard input).</p>
<p>Remember that many commands are shell built-ins and need special handling. So if you want a listing of files in a directory on a Windows machine and write:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">"dir"</span>.execute()</span><br><span class="line">println <span class="string">"$&#123;process.text&#125;"</span></span><br></pre></td></tr></table></figure>
<p>接着你会收到一个异常<code>IOException</code>,异常信息为<code>Cannot run program &quot;dir&quot;: CreateProcess error=2</code>,系统找不到指定的文件.</p>
<p>这是因为<code>dir</code>是内建于<code>windows shell(cmd.ext)</code>, 想要使用那个命令,你要像下面这个样操作:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> process = <span class="string">"cmd /c dir"</span>.execute()</span><br><span class="line">println <span class="string">"$&#123;process.text&#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>还有,因为上述的功能是在内部使用的<code>java.lang.Process</code>, 这个类的一些不足的地方,我们也要充分考虑. 在javadoc中,是这样描述这个类的:</p>
<blockquote>
<p>Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the subprocess may cause the subprocess to block, and even deadlock<br>Because of this, Groovy provides some additional helper methods which make stream handling for processes easier.</p>
</blockquote>
<p>现在演示一下,如何输出进程里所有的输出(包括error stream).<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> p = <span class="string">"rm -f foo.tmp"</span>.execute([], tmpDir)</span><br><span class="line">p.consumeProcessOutput()</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure></p>
<p><code>consumeProcessOutput</code>仍然有很多对<code>StringBuffer</code>, <code>InputStream</code>, <code>OutputStream</code>等封装的变量, 如果想要获取一个完整的封装列表的,那可以参考 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html" target="_blank" rel="external">GDK API for java.lang.Process</a></p>
<p>另外, <code>pipeTo</code>命令 可以让一个进程的输出流连接到一个进程的输入流里. 如下例:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proc1 = <span class="string">'ls'</span>.execute()</span><br><span class="line">proc2 = <span class="string">'tr -d o'</span>.execute()</span><br><span class="line">proc3 = <span class="string">'tr -d e'</span>.execute()</span><br><span class="line">proc4 = <span class="string">'tr -d i'</span>.execute()</span><br><span class="line">proc1 | proc2 | proc3 | proc4</span><br><span class="line">proc4.waitFor()</span><br><span class="line"><span class="keyword">if</span> (proc4.exitValue()) &#123;</span><br><span class="line">    println proc4.err.text</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println proc4.text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consuming errors<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sout = <span class="keyword">new</span> StringBuilder()</span><br><span class="line"><span class="keyword">def</span> serr = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">proc2 = <span class="string">'tr -d o'</span>.execute()</span><br><span class="line">proc3 = <span class="string">'tr -d e'</span>.execute()</span><br><span class="line">proc4 = <span class="string">'tr -d i'</span>.execute()</span><br><span class="line">proc4.consumeProcessOutput(sout, serr)</span><br><span class="line">proc2 | proc3 | proc4</span><br><span class="line">[proc2, proc3].each &#123; it.consumeProcessErrorStream(serr) &#125;</span><br><span class="line">proc2.withWriter &#123; writer -&gt;</span><br><span class="line">    writer &lt;&lt; <span class="string">'testfile.groovy'</span></span><br><span class="line">&#125;</span><br><span class="line">proc4.waitForOrKill(<span class="number">1000</span>)</span><br><span class="line">println <span class="string">"Standard output: $sout"</span></span><br><span class="line">println <span class="string">"Standard error: $serr"</span></span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovyIO/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovyIO/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovy json/" title="groovy JSON" itemprop="url">groovy JSON</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<p>Groovy 原生支持Groovy对象和JSON之间的转换. <code>groovy.json</code>包内的类用于JSON的序列化和解析功能</p>
<h2 id="JsonSlurper"><a href="#JsonSlurper" class="headerlink" title="JsonSlurper"></a>JsonSlurper</h2><p><code>JsonSlurper</code>用于将JSON文本或者其他数据内容解析成Groovy里的数据结构,例如<code>maps&lt;/code&gt;,</code>lists, 或者其他原生基本类型 <code>Integer&lt;/code&gt;,</code>Double, <code>Boolean&lt;/code&gt;,</code>String`。</p>
<p>这个类重载了很多方法, 而且还添加了一些特殊的方法, 例如<code>parseText&lt;/code&gt;,</code>parseFile<code>等.下面这个例子中我们使用了</code>parseText<code>方法, 它会解析一个JSON字符串, 然后递归地将它转换成</code>list, <code>map</code>结构. 一些其他的`parse* 方法和这个方法很类似, 都返回了JSON字符串, 只不过其他的方法接受的参数不一样.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> jsonSlurper = <span class="keyword">new</span> JsonSlurper()</span><br><span class="line"><span class="keyword">def</span> object = jsonSlurper.parseText(<span class="string">'&#123; "name": "John Doe" &#125; /* some comment */'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> object <span class="keyword">instanceof</span> Map</span><br><span class="line"><span class="keyword">assert</span> object.name == <span class="string">'John Doe'</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是, 产生的结果是一个纯map, 可以像一个普通的Groovy对象实例持有它. <code>JsonSlurper</code>根据<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" target="_blank" rel="external">ECMA-404 JSON Interchange Standard</a>定义来解析JSON, 同时支持JavaScript的注释和时间类型.</p>
<p>除了支持maps之外, <code>JsonSlurper</code> 还支持将JSON数组解析成list的功能<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> jsonSlurper = <span class="keyword">new</span> JsonSlurper()</span><br><span class="line"><span class="keyword">def</span> object = jsonSlurper.parseText(<span class="string">'&#123; "myList": [4, 8, 15, 16, 23, 42] &#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> object <span class="keyword">instanceof</span> Map</span><br><span class="line"><span class="keyword">assert</span> object.myList <span class="keyword">instanceof</span> List</span><br><span class="line"><span class="keyword">assert</span> object.myList == [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure></p>
<p>JSON标准上只支持下面这些原生数据类型：<code>string&lt;/code&gt;,</code>number, <code>object&lt;/code&gt;,</code>true, <code>false&lt;/code&gt;,</code>null. <code>JsonSlurper</code> 将那些JSON类型转换成Groovy类型.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> jsonSlurper = <span class="keyword">new</span> JsonSlurper()</span><br><span class="line"><span class="keyword">def</span> object = jsonSlurper.parseText <span class="string">'''</span><br><span class="line">    &#123; "simple": 123,</span><br><span class="line">      "fraction": 123.66,</span><br><span class="line">      "exponential": 123e12</span><br><span class="line">    &#125;'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> object <span class="keyword">instanceof</span> Map</span><br><span class="line"><span class="keyword">assert</span> object.simple.<span class="keyword">class</span> == Integer</span><br><span class="line"><span class="keyword">assert</span> object.fraction.<span class="keyword">class</span> == BigDecimal</span><br><span class="line"><span class="keyword">assert</span> object.exponential.<span class="keyword">class</span> == BigDecimal</span><br></pre></td></tr></table></figure></p>
<p><code>JsonSlurper</code> 生成的结果就是纯Groovy对象实例, 她的内部不会包含任何的JSON相关的类对象, 它的用法是相当透明的. 事实上<code>JsonSlurper</code>的结果遵循<code>GPath</code>表达式. <code>GPath</code>是一个非常强大的表达式语言, 它支持多种不同的数据格式(例如<code>XmlSlurper</code>支持<code>XML</code> 就是其中一个例子)</p>
<p>如果想要了解更多的内容, 你可以直接去<a href="http://docs.groovy-lang.org/latest/html/documentation/core-semantics.html#gpath_expressions" target="_blank" rel="external">GPath expressions</a>看一看.<br>下面给出了JSON类型与Groovy数据类型之间的对应关系.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSON			Groovy</span><br><span class="line">string			java.lang.String</span><br><span class="line">number			java.lang.BigDecimal or java.lang.Integer</span><br><span class="line">object			java.util.LinkedHashMap</span><br><span class="line">array			java.util.ArrayList</span><br><span class="line"><span class="literal">true</span>			<span class="literal">true</span></span><br><span class="line"><span class="literal">false</span>			<span class="literal">false</span></span><br><span class="line"><span class="literal">null</span>			<span class="literal">null</span></span><br><span class="line">date			java.util.Date based on the yyyy-MM-dd’T’<span class="string">HH:</span><span class="string">mm:</span>ssZ date format</span><br></pre></td></tr></table></figure></p>
<p>如果JSON中的一个值是<code>null&lt;/code&gt;,</code>JsonSlurper<code>支持它转换成Groovy中的</code>null.这就与其他JSON解析器形成了对比, 代表一个空值与库提供的单一对象。</p>
<h3 id="Parser-Variants"><a href="#Parser-Variants" class="headerlink" title="Parser Variants"></a>Parser Variants</h3><p>Groovy 有多个<code>JsonSlurper</code> 解析器实现. 每一个解析器都对应着不同的需求, 每一个特定的解析都能很好的处理特定需求, 所以默认的解析器并不是适应于所有的情况. 下面就对各个解析器做个简介:</p>
<p><code>JsonParserCharArray</code> 解析器接受一个JSON字符串, 然后其内部使用一个字节数组进行解析. During value conversion it copies character sub-arrays (a mechanism known as “chopping”) and operates on them.</p>
<ul>
<li><p><code>JsonFastParser</code>解析器是<code>JsonParserCharArray</code>解析器的变种, 它是最快的解析器. 尽管它是最快的,但是基于某些原因,它并不是默认的解析器. <code>JsonFastParser</code>解析器也被称为索引覆盖(index-overlay)解析器. 当解析给定JSON字符串的时候,该解析器会极力避免创建新的字节数组或者字符串实例. 它一直指向原生的字节数组。 另外, 它会尽可能的推迟对象的创建. If parsed maps are put into long-term caches care must be taken as the map objects might not be created and still consist of pointer to the original char buffer only. <code>JsonFastParser</code>采取了一种特殊的切割模型, 它会尽早地分割char buffer, 以便能维持一份对原生buffer比较小的拷贝. 如果你想使用<code>JsonFastParser&lt;/code&gt;, 那么给你的建议是保持</code>JsonFastParser`的JSON buffer在2MB左右, 而且时刻要保持长期缓存限制.</p>
</li>
<li><p><code>JsonParserLax</code> 是<code>JsonFastParser</code>的一个变种实现. 它与<code>JsonFastParser</code> 有一些相似的想能特点, 但是不同的是它不是仅仅依靠`ECMA-404 JSON grammar. 例如,在下面例子中它支持不带引号的字符串注释.</p>
</li>
</ul>
<p><code>JsonParserUsingCharacterSource</code> 用于解析非常大的文件. 它使用一种称为<code>“character windowing”</code>的技术去解析非常大(超过2MB)的JSON文件,而且性能上也非常稳定</p>
<p><code>JsonSlurper</code>的默认实现是 <code>JsonParserCharArray&lt;/code&gt;.</code>JsonParserType`包含了解析器种类的枚举类型:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Implementation					Constant</span><br><span class="line">JsonParserCharArray				JsonParserType#CHAR_BUFFER</span><br><span class="line">JsonFastParser					JsonParserType#INDEX_OVERLAY</span><br><span class="line">JsonParserLax					JsonParserType#LAX</span><br><span class="line">JsonParserUsingCharacterSource	JsonParserType#CHARACTER_SOURCE</span><br></pre></td></tr></table></figure>
<p>如果想要改变解析器的实现也非常简单, 只需要通过调用<code>JsonSlurper#setType()&lt;/code&gt;方法给</code>JsonParserType`设置上不同的值就可以了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> jsonSlurper = <span class="keyword">new</span> JsonSlurper(<span class="string">type:</span> JsonParserType.INDEX_OVERLAY)</span><br><span class="line"><span class="keyword">def</span> object = jsonSlurper.parseText(<span class="string">'&#123; "myList": [4, 8, 15, 16, 23, 42] &#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> object <span class="keyword">instanceof</span> Map</span><br><span class="line"><span class="keyword">assert</span> object.myList <span class="keyword">instanceof</span> List</span><br><span class="line"><span class="keyword">assert</span> object.myList == [<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure>
<h3 id="JsonOutput"><a href="#JsonOutput" class="headerlink" title="JsonOutput"></a>JsonOutput</h3><p><code>JsonOutput</code>用于将Groovy对象序列化成JSON字符串.</p>
<p><code>JsonOutput</code> 重载了<code>toJson</code>静态方法. 每个不同的<code>toJson</code>方法都会接受一个不同的参数类型.</p>
<p><code>toJson</code>方法返回的是一个包含JSOn格式的字符串<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> json = JsonOutput.toJson([<span class="string">name:</span> <span class="string">'John Doe'</span>, <span class="string">age:</span> <span class="number">42</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> json == <span class="string">'&#123;"name":"John Doe","age":42&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p><code>JsonOutput</code>不仅支持原生类型, map, list等类型序列化到JSON, 甚至还支持序列化`POGOs(一种比较老的Groovy对象)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> String name &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> json = JsonOutput.toJson([ <span class="keyword">new</span> Person(<span class="string">name:</span> <span class="string">'John'</span>), <span class="keyword">new</span> Person(<span class="string">name:</span> <span class="string">'Max'</span>) ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> json == <span class="string">'[&#123;"name":"John"&#125;,&#123;"name":"Max"&#125;]'</span></span><br></pre></td></tr></table></figure>
<p>刚才那个例子中, JSON输出默认没有进行pretty输出. 因此<code>JsonSlurper</code>还提供了<code>prettyPrint</code>方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> json = JsonOutput.toJson([<span class="string">name:</span> <span class="string">'John Doe'</span>, <span class="string">age:</span> <span class="number">42</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> json == <span class="string">'&#123;"name":"John Doe","age":42&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> JsonOutput.prettyPrint(json) == <span class="string">'''\</span><br><span class="line">&#123;</span><br><span class="line">    "name": "John Doe",</span><br><span class="line">    "age": 42</span><br><span class="line">&#125;'''</span>.stripIndent()</span><br></pre></td></tr></table></figure></p>
<p><code>prettyPrint</code>方法只接受一个String类型的字符串, 它不能和<code>JsonOutput</code>里其他的方式结合起来使用, it can be applied on arbitrary JSON String instances.</p>
<p>在Groovy中还可以使用<code>JsonBuilder&lt;/code&gt;,</code>StreamingJsonBuilder<code>方式创建JSON. 这俩个构建起都提供了一个</code>DSL, 当构建器生成一个JSON的时候,可以制定一个对象图.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an inclusive range</span></span><br><span class="line"><span class="keyword">def</span> range = <span class="string">'a'</span>..<span class="string">'d'</span></span><br><span class="line"><span class="keyword">assert</span> range.size() == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> range.get(<span class="number">2</span>) == <span class="string">'c'</span></span><br><span class="line"><span class="keyword">assert</span> range[<span class="number">2</span>] == <span class="string">'c'</span></span><br><span class="line"><span class="keyword">assert</span> range <span class="keyword">instanceof</span> java.util.List</span><br><span class="line"><span class="keyword">assert</span> range.contains(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">assert</span> range.contains(<span class="string">'d'</span>)</span><br><span class="line"><span class="keyword">assert</span> !range.contains(<span class="string">'e'</span>)</span><br></pre></td></tr></table></figure>
<p>You can iterate on a range using a classic for loop:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    println <span class="string">"Hello $&#123;i&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>but alternatively you can achieve the same effect in a more Groovy idiomatic style, by iterating a range with each method:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1.</span><span class="number">.10</span>).each &#123; i -&gt;</span><br><span class="line">    println <span class="string">"Hello $&#123;i&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ranges can be also used in the switch statement:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (years) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1.</span><span class="number">.10</span>: interestRate = <span class="number">0.076</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11.</span><span class="number">.25</span>: interestRate = <span class="number">0.052</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="symbol">    default:</span> interestRate = <span class="number">0.037</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovy json/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovy json/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovy数字/" title="groovy数字" itemprop="url">groovy数字</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<p>Groovy支持多种不同的整数字面量和小数字面量 (通过依靠Java数字类型实现)</p>
<h3 id="Integral-literals"><a href="#Integral-literals" class="headerlink" title="Integral literals"></a>Integral literals</h3><p>The integral literal types are the same as in Java:</p>
<p>证书类型变量和Java里的一样</p>
<ul>
<li>byte</li>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>java.lang.BigInteger</li>
</ul>
<p>You can create integral numbers of those types with the following declarations:</p>
<p>可以通过以下声明方式创建整数类型变量<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive types</span></span><br><span class="line"><span class="keyword">byte</span>  b = <span class="number">1</span></span><br><span class="line"><span class="keyword">char</span>  c = <span class="number">2</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span>   i = <span class="number">4</span></span><br><span class="line"><span class="keyword">long</span>  l = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite precision</span></span><br><span class="line">BigInteger bi =  <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>def</code>关键字, 整型类型会发生改变：它会自动适配成能够存储number类型的类型<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> a <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> b = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">assert</span> b <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> c = <span class="number">2147483648</span></span><br><span class="line"><span class="keyword">assert</span> c <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> d = <span class="number">9223372036854775807</span></span><br><span class="line"><span class="keyword">assert</span> d <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> e = <span class="number">9223372036854775808</span></span><br><span class="line"><span class="keyword">assert</span> e <span class="keyword">instanceof</span> BigInteger</span><br></pre></td></tr></table></figure></p>
<p>As well as for negative numbers:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> na = <span class="number">-1</span></span><br><span class="line"><span class="keyword">assert</span> na <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MIN_VALUE</span></span><br><span class="line"><span class="keyword">def</span> nb = <span class="number">-2147483648</span></span><br><span class="line"><span class="keyword">assert</span> nb <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MIN_VALUE - 1</span></span><br><span class="line"><span class="keyword">def</span> nc = <span class="number">-2147483649</span></span><br><span class="line"><span class="keyword">assert</span> nc <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MIN_VALUE</span></span><br><span class="line"><span class="keyword">def</span> nd = <span class="number">-9223372036854775808</span></span><br><span class="line"><span class="keyword">assert</span> nd <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MIN_VALUE - 1</span></span><br><span class="line"><span class="keyword">def</span> ne = <span class="number">-9223372036854775809</span></span><br><span class="line"><span class="keyword">assert</span> ne <span class="keyword">instanceof</span> BigInteger</span><br></pre></td></tr></table></figure></p>
<h4 id="Alternative-non-base-10-representations"><a href="#Alternative-non-base-10-representations" class="headerlink" title="Alternative non-base 10 representations"></a>Alternative non-base 10 representations</h4><h5 id="Binary-literal"><a href="#Binary-literal" class="headerlink" title="Binary literal"></a>Binary literal</h5><p>在Java6以前和Groovy中,number类型可以是小数, 8进制和16进制. 但是在Java7和Groovy2中,可以使用0b前缀表示二进制数据.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xInt = <span class="number">0b10101111</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">175</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">0b11001001</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">201</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">0b11</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">3</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0b101101101101</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">2925</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">0b111100100001</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">3873</span>g</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-0</span>b10101111</span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-175</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Octal-literal"><a href="#Octal-literal" class="headerlink" title="Octal literal"></a>Octal literal</h5><p>8进制的电话,只需要开头是0后跟要表示的8进制数即可.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xInt = <span class="number">077</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">63</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">011</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">9</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">032</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">26</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0246</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">166</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">01111</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">585</span>g</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-077</span></span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-63</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Hexadecimal-literal"><a href="#Hexadecimal-literal" class="headerlink" title="Hexadecimal literal"></a>Hexadecimal literal</h5><p>Hexadecimal numbers are specified in the typical format of 0x followed by hex digits.</p>
<p>16进制的电话,只需要开头是0x后跟要表示的16进制数即可.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> xInt = <span class="number">0x77</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">119</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">0xaa</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">170</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">0x3a</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">58</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0xffff</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">65535</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">0xaaaa</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">43690</span>g</span><br><span class="line"></span><br><span class="line">Double xDouble = <span class="keyword">new</span> Double(<span class="string">'0x1.0p0'</span>)</span><br><span class="line"><span class="keyword">assert</span> xDouble == <span class="number">1.0</span>d</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-0x77</span></span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-119</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Decimal-literals"><a href="#Decimal-literals" class="headerlink" title="Decimal literals"></a>Decimal literals</h3><p>小数字面量和在java 里一样</p>
<ul>
<li>float</li>
<li>double</li>
<li>java.lang.BigDecimal</li>
</ul>
<p>可以通过下面的方式创建小数类型的number<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive types</span></span><br><span class="line"><span class="keyword">float</span>  f = <span class="number">1.234</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite precision</span></span><br><span class="line">BigDecimal bd =  <span class="number">3.456</span></span><br></pre></td></tr></table></figure></p>
<p>Decimals can use exponents, with the e or E exponent letter, followed by an optional sign, and a integral number representing the exponent:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1e3</span>  ==  <span class="number">1</span>_000<span class="number">.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">2E4</span>  == <span class="number">20</span>_000<span class="number">.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">3e+1</span> ==     <span class="number">30.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">4E-2</span> ==      <span class="number">0.04</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">5e-1</span> ==      <span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p>Conveniently for exact decimal number calculations, Groovy choses java.lang.BigDecimal as its decimal number type. In addition, both float and double are supported, but require an explicit type declaration, type coercion or suffix. Even if BigDecimal is the default for decimal numbers, such literals are accepted in methods or closures taking float or double as parameter types.</p>
<p>Decimal numbers can’t be represented using a binary, octal or hexadecimal representation.</p>
<h3 id="Underscore-in-literals"><a href="#Underscore-in-literals" class="headerlink" title="Underscore in literals"></a>Underscore in literals</h3><p>When writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</span><br><span class="line"><span class="keyword">long</span> socialSecurityNumbers = <span class="number">999</span>_99_9999L</span><br><span class="line"><span class="keyword">double</span> monetaryAmount = <span class="number">12</span>_345_132<span class="number">.12</span></span><br><span class="line"><span class="keyword">long</span> hexBytes = <span class="number">0xFF</span>_EC_DE_5E</span><br><span class="line"><span class="keyword">long</span> hexWords = <span class="number">0xFFEC</span>_DE5E</span><br><span class="line"><span class="keyword">long</span> maxLong = <span class="number">0x7fff</span>_ffff_ffff_ffffL</span><br><span class="line"><span class="keyword">long</span> alsoMaxLong = <span class="number">9</span>_223_372_036_854_775_807L</span><br><span class="line"><span class="keyword">long</span> bytes = <span class="number">0b11010010</span>_01101001_10010100_10010010</span><br></pre></td></tr></table></figure>
<h3 id="Number-type-suffixes"><a href="#Number-type-suffixes" class="headerlink" title="Number type suffixes"></a>Number type suffixes</h3><p>我们可以通过添加后缀的方式强制指定一个数字的类型(包含二进制,八进制和十六进制)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type			Suffix</span><br><span class="line">BigInteger		G or g</span><br><span class="line">Long			L or l</span><br><span class="line">Integer			I or i</span><br><span class="line">BigDecimal		G or g</span><br><span class="line">Double			D or d</span><br><span class="line">Float			F or f</span><br></pre></td></tr></table></figure></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">42</span>I == <span class="keyword">new</span> Integer(<span class="string">'42'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">42</span>i == <span class="keyword">new</span> Integer(<span class="string">'42'</span>) <span class="comment">// lowercase i more readable</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">123</span>L == <span class="keyword">new</span> Long(<span class="string">"123"</span>) <span class="comment">// uppercase L more readable</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">2147483648</span> == <span class="keyword">new</span> Long(<span class="string">'2147483648'</span>) <span class="comment">// Long type used, value too large for an Integer</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">456</span>G == <span class="keyword">new</span> BigInteger(<span class="string">'456'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">456</span>g == <span class="keyword">new</span> BigInteger(<span class="string">'456'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">123.45</span> == <span class="keyword">new</span> BigDecimal(<span class="string">'123.45'</span>) <span class="comment">// default BigDecimal type used</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.200065</span>D == <span class="keyword">new</span> Double(<span class="string">'1.200065'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.234</span>F == <span class="keyword">new</span> Float(<span class="string">'1.234'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.23E23</span>D == <span class="keyword">new</span> Double(<span class="string">'1.23E23'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">0b1111</span>L.<span class="keyword">class</span> == Long <span class="comment">// binary</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0xFF</span>i.<span class="keyword">class</span> == Integer <span class="comment">// hexadecimal</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">034</span>G.<span class="keyword">class</span> == BigInteger <span class="comment">// octal</span></span><br></pre></td></tr></table></figure>
<h3 id="Math-operations"><a href="#Math-operations" class="headerlink" title="Math operations"></a>Math operations</h3><p>尽管接下来我们还要详细讨论操作符, 但是鉴于数学操作符的重要性, 现在我们还是要先讨论其行为和返回类型</p>
<ul>
<li>byte, char, short 和 int 之间的二进制计算返回的是int类型</li>
<li>byte, char, short 和 int 之间的二进制计算中涉及到long的话, 那么返回的就是long类型</li>
<li>BigInteger 与任何整数类型的二进制计算 返回的结果都是BigInteger类型</li>
<li>float, double 和 BigDecimal 之间的二进制计算返回的结果都是double类型</li>
<li>俩个BigDecimal之间的二进制运算返回的都是BigDecimal类型.</li>
</ul>
<p>由于Groovy提供了操作符重载功能, BigInteger和BigDecimal之间的算术运算也得以实现, 但是在Java中需要调用一些方法才能计算这些不同类型的数字.</p>
<h4 id="The-case-of-the-power-operator"><a href="#The-case-of-the-power-operator" class="headerlink" title="The case of the power operator"></a>The case of the power operator</h4><p>Groovy 里有一种强大的操作符<code>**</code>, 这个操作符带有base和exponent俩个参数. 这个操作符的结果依赖于它的操作数和操作结果.Groovy使用下面的规则来决定该操作符的返回类型</p>
<h5 id="如果exponent为小数类型"><a href="#如果exponent为小数类型" class="headerlink" title="如果exponent为小数类型"></a>如果exponent为小数类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 如果结果能表示为Integer类型,那就返回Integer类型</span><br><span class="line"><span class="number">2</span>. 否则如果结果能表示为Long类型,那就返回Long类型</span><br><span class="line"><span class="number">3</span>. 否则的话就返回Double</span><br></pre></td></tr></table></figure>
<h5 id="如果exponent为整数类型"><a href="#如果exponent为整数类型" class="headerlink" title="如果exponent为整数类型"></a>如果exponent为整数类型</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 如果exponent负数负数, 那就返回Integer, Long 或者Double,</span><br><span class="line"><span class="number">2.</span> 如果exponent是正数或者<span class="number">0</span>, 那就要根据base来判断了</span><br><span class="line">	A. 如果base是 BigDecimal, 那就返回BigDecimal类型</span><br><span class="line">	B. 如果base是 BigInteger, 那就返回BigInteger类型</span><br><span class="line">	C. 如果base是 Integer, 那就返回Integer类型, 如果返回的值超过Integer范围的话,就返回BigInteger</span><br><span class="line">	D. 如果base是 Long, 那就返回Long类型, 如果返回的值超过Long范围的话,就返回BigInteger</span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base and exponent are ints and the result can be represented by an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">2</span>    **   <span class="number">3</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  8</span></span><br><span class="line"><span class="keyword">assert</span>   <span class="number">10</span>    **   <span class="number">9</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  1_000_000_000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a long, so fit the result in a Long</span></span><br><span class="line"><span class="comment">// (although it could have fit in an Integer)</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">5</span>L   **   <span class="number">2</span>    <span class="keyword">instanceof</span> Long       <span class="comment">//  25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the result can't be represented as an Integer or Long, so return a BigInteger</span></span><br><span class="line"><span class="keyword">assert</span>  <span class="number">100</span>    **  <span class="number">10</span>    <span class="keyword">instanceof</span> BigInteger <span class="comment">//  10e20</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1234</span>    ** <span class="number">123</span>    <span class="keyword">instanceof</span> BigInteger <span class="comment">//  170515806212727042875...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a BigDecimal and the exponent a negative int</span></span><br><span class="line"><span class="comment">// but the result can be represented as an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">0.5</span>  **  <span class="number">-2</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is an int, and the exponent a negative float</span></span><br><span class="line"><span class="comment">// but again, the result can be represented as an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">1</span>    **  <span class="number">-0.3</span>f <span class="keyword">instanceof</span> Integer    <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is an int, and the exponent a negative int</span></span><br><span class="line"><span class="comment">// but the result will be calculated as a Double</span></span><br><span class="line"><span class="comment">// (both base and exponent are actually converted to doubles)</span></span><br><span class="line"><span class="keyword">assert</span>   <span class="number">10</span>    **  <span class="number">-1</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">1.2</span>  **  <span class="number">10</span>    <span class="keyword">instanceof</span> BigDecimal <span class="comment">//  6.1917364224</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a float or double, and the exponent is an int</span></span><br><span class="line"><span class="comment">// but the result can only be represented as a Double value</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">3.4</span>f **   <span class="number">5</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  454.35430372146965</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">5.6</span>d **   <span class="number">2</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  31.359999999999996</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the exponent is a decimal value</span></span><br><span class="line"><span class="comment">// and the result can only be represented as a Double value</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">7.8</span>  **   <span class="number">1.9</span>  <span class="keyword">instanceof</span> Double     <span class="comment">//  49.542708423868476</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">2</span>    **   <span class="number">0.1</span>f <span class="keyword">instanceof</span> Double     <span class="comment">//  1.0717734636432956</span></span><br></pre></td></tr></table></figure>
<h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>Boolean是一种特殊的数据类型, 他们的值只有俩种情况：true 和 false.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myBooleanVariable = <span class="literal">true</span></span><br><span class="line"><span class="keyword">boolean</span> untypedBooleanVar = <span class="literal">false</span></span><br><span class="line">booleanField = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>true and false are the only two primitive boolean values. But more complex boolean expressions can be represented using logical operators.</p>
<p>In addition, Groovy has special rules (often referred to as Groovy Truth) for coercing non-boolean objects to a boolean value.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovy数字/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovy数字/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovy ant/" title="groovy ANT" itemprop="url">groovy ANT</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<p>虽然<code>Ant</code>只是一个构建工具, 但其提供了例如能够操作文件(包括zip文件), 拷贝, 资源管理等诸多实用功能. 然而如果你不喜欢使用<code>build.xml</code>文件或者<code>Jelly</code>脚本, 而是想要一种清晰简洁的构建方式, 那么你就可以试试使用Groovy编写构建过程.</p>
<p>Groovy提供了一个辅助类<code>AntBuilder</code>帮忙编写Ant构建任务. 它看起来很像一个不带尖括号的Ant’s XML的简洁版本. 因此你可以在脚本中混合和匹配标记. Ant本身是一组Jar文件的集合. 将这组jar文件添加到你的classpath上, 你就可以在Groovy中轻轻松松的使用它们.</p>
<p><code>AntBuilder</code>通过便捷的构造器语法直接暴露了Ant task. 下面是一个简单的示例, 它的功能是在标准输出上输出一条消息.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> ant = <span class="keyword">new</span> AntBuilder()          </span><br><span class="line">ant.echo(<span class="string">'hello from Ant!'</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>创建一个<code>AntBuilder</code>实例</li>
<li>执行<code>AntBuilder</code>实例的echo task</li>
</ol>
<p>假设,现在你需要创建一个ZIP文件：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> ant = <span class="keyword">new</span> AntBuilder()</span><br><span class="line">ant.zip(<span class="string">destfile:</span> <span class="string">'sources.zip'</span>, <span class="string">basedir:</span> <span class="string">'src'</span>)</span><br></pre></td></tr></table></figure></p>
<p>在下面的例子中, 我们将展示在Groovy中使用传统的Ant 模式通过<code>AntBuilder</code>拷贝一组文件.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lets just call one task</span></span><br><span class="line">ant.echo(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// here is an example of a block of Ant inside GroovyMarkup</span></span><br><span class="line">ant.sequential &#123;</span><br><span class="line">    echo(<span class="string">"inside sequential"</span>)</span><br><span class="line">    <span class="keyword">def</span> myDir = <span class="string">"target/AntTest/"</span></span><br><span class="line">    mkdir(<span class="string">dir:</span> myDir)</span><br><span class="line">    copy(<span class="string">todir:</span> myDir) &#123;</span><br><span class="line">        fileset(<span class="string">dir:</span> <span class="string">"src/test"</span>) &#123;</span><br><span class="line">            include(<span class="string">name:</span> <span class="string">"**/*.groovy"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    echo(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now lets do some normal Groovy again</span></span><br><span class="line"><span class="keyword">def</span> file = <span class="keyword">new</span> File(ant.project.baseDir,<span class="string">"target/AntTest/groovy/util/AntTest.groovy"</span>)</span><br><span class="line"><span class="keyword">assert</span> file.exists()</span><br></pre></td></tr></table></figure></p>
<p>下面的例子是遍历一组文件, 然后将每个文件根据特殊模式进行匹配.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lets create a scanner of filesets</span></span><br><span class="line"><span class="keyword">def</span> scanner = ant.fileScanner &#123;</span><br><span class="line">    fileset(<span class="string">dir:</span><span class="string">"src/test"</span>) &#123;</span><br><span class="line">        include(<span class="string">name:</span><span class="string">"**/Ant*.groovy"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now lets iterate over</span></span><br><span class="line"><span class="keyword">def</span> found = <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> (f <span class="keyword">in</span> scanner) &#123;</span><br><span class="line">    println(<span class="string">"Found file $f"</span>)</span><br><span class="line">    found = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">assert</span> f <span class="keyword">instanceof</span> File</span><br><span class="line">    <span class="keyword">assert</span> f.name.endsWith(<span class="string">".groovy"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> found</span><br></pre></td></tr></table></figure></p>
<p>Or execute a JUnit test:</p>
<p>下面我们执行JUnit<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lets create a scanner of filesets</span></span><br><span class="line">ant.junit &#123;</span><br><span class="line">    test(<span class="string">name:</span><span class="string">'groovy.util.SomethingThatDoesNotExist'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在, 让我们的步子迈地更大一点：在Groovy中编译然后执行一个Java文件.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ant.echo(<span class="string">file:</span><span class="string">'Temp.java'</span>, <span class="string">'''</span><br><span class="line">    class Temp &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            System.out.println("Hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">'''</span>)</span><br><span class="line">ant.javac(<span class="string">srcdir:</span><span class="string">'.'</span>, <span class="string">includes:</span><span class="string">'Temp.java'</span>, <span class="string">fork:</span><span class="string">'true'</span>)</span><br><span class="line">ant.java(<span class="string">classpath:</span><span class="string">'.'</span>, <span class="string">classname:</span><span class="string">'Temp'</span>, <span class="string">fork:</span><span class="string">'true'</span>)</span><br><span class="line">ant.echo(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure></p>
<p>需要提及的是, <code>AntBuilder</code>是内嵌于<code>Gradle</code>中的. 你可以像在Groovy中那样, 在<code>Gradle</code>使用<code>AntBuilder</code></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovy ant/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovy ant/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/04/08/groovy/groovy集合/" title="groovy集合" itemprop="url">groovy集合</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming15" target="_blank" itemprop="author">ming15</a>
		
  <p class="article-time">
    <time datetime="2014-04-07T16:00:00.000Z" itemprop="datePublished"> Published 2014-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>本文是对Groovy部分官方文档进行了翻译</p>
</blockquote>
<p>Groovy 语言层面上就支持多种集合类型,包括list, map, range. 大多数类型集合都是基于java的集合框架,而且Groovy development kit对这些集合内置很多快捷方法.</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Groovy使用了一种被<code>[]</code>括起来,值通过<code>,</code>分割的语法 定义list. Groovy list 采用的是 JDK里<code>java.util.List</code>的实现, 因为它自身并没有定义自己的集合类.<br>Groovy list 的默认实现是<code>java.util.ArrayList</code>, 在后面我们可以看到其他形式的list</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]         (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numbers <span class="keyword">instanceof</span> List  (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> numbers.size() == <span class="number">3</span>      (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>我们定义了一个Number类型的List,然后将这个list分配给一个变量</li>
<li>判断list是 Java’s <code>java.util.List</code> interface 的实例</li>
<li>list的大小可以通过size()来进行查询, 例子中也给我们展示了这个list确实包含3个元素</li>
</ol>
<p>在上面的list中,我们使用的是同类元素的list, 但其实Groovy list中的数据类型还可以不一样：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> heterogeneous = [<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>]  (<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>我们定义了一个包含有number,string,boolean 三个类型的list</li>
</ol>
<p>在上面我们提到过, list实际上是<code>java.util.ArrayList</code>实例, 但其实list还可以是其他不同类型的实例, 下面我们通过操作符或者显式类型声明来强制指定 list使用不同的List实现<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> arrayList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> arrayList <span class="keyword">instanceof</span> java.util.ArrayList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> linkedList = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> LinkedList    (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> linkedList <span class="keyword">instanceof</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line">LinkedList otherLinked = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]          (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> otherLinked <span class="keyword">instanceof</span> java.util.LinkedList</span><br></pre></td></tr></table></figure></p>
<ol>
<li>我们使用操作符强制将类型显式地声明为<code>java.util.LinkedList</code></li>
<li>我们使用显式声明方式, 将list声明为<code>java.util.LinkedList</code></li>
</ol>
<p>我们可以通过<code>[]</code>下标操作符来访问list中的元素(读写都可以). 下标既如果是正数的话,那就从左到右访问元素, 如果下标是负数那就从右到左访问元素. 我们好可以使用<code>&lt;&lt;</code>操作符向list里追加元素<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">0</span>] == <span class="string">'a'</span>     (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>] == <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'d'</span>    (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-2</span>] == <span class="string">'c'</span></span><br><span class="line"></span><br><span class="line">letters[<span class="number">2</span>] = <span class="string">'C'</span>             (<span class="number">3</span>)</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2</span>] == <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line">letters &lt;&lt; <span class="string">'e'</span>               (<span class="number">4</span>)</span><br><span class="line"><span class="keyword">assert</span> letters[ <span class="number">4</span>] == <span class="string">'e'</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'e'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>, <span class="number">3</span>] == [<span class="string">'b'</span>, <span class="string">'d'</span>]         (<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2.</span><span class="number">.4</span>] == [<span class="string">'C'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]    (<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>访问第一个元素(从这可以看出,list的下标是从0开始的)</li>
<li>通过-1 下标访问list中的最后一个元素.</li>
<li>使用下标对list中第三个元素重新赋值</li>
<li>使用<code>&lt;&lt;</code>向list尾部添加一个元素</li>
<li>一次性访问list中俩个元素,这个操作的结果是返回一个包含俩个元素的新的list</li>
<li>使用值域符来访问list中一定范围内的值.</li>
</ol>
<p>由于list支持多种不同类型的元素, 那么list中也可以包含list,这样就可以制造出多维list<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> multi = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]     (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> multi[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">2</span>          (<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>定义了一个包含Number类型list的list</li>
<li>访问外层的第二个元素(第二个list), 然后访问内部list的第一个元素(第二个list的第一个元素)</li>
</ol>
<h4 id="List-literals"><a href="#List-literals" class="headerlink" title="List literals"></a>List literals</h4><p>你可以像下面这样创建集合, 注意<code>[]</code>是空集合表达式.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">assert</span> list.get(<span class="number">2</span>) == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> list[<span class="number">2</span>] == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> list <span class="keyword">instanceof</span> java.util.List</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> emptyList = []</span><br><span class="line"><span class="keyword">assert</span> emptyList.size() == <span class="number">0</span></span><br><span class="line">emptyList.add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> emptyList.size() == <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>每一个list表达式都是实现自<code>java.util.List</code></p>
<p>当然list也可以指定其具体的实现类型<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="comment">//construct a new list, seeded with the same items as in list1</span></span><br><span class="line"><span class="keyword">def</span> list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(list1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> list2 == list1 <span class="comment">// == checks that each corresponding element is the same</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clone() can also be called</span></span><br><span class="line"><span class="keyword">def</span> list3 = list1.clone()</span><br><span class="line"><span class="keyword">assert</span> list3 == list1</span><br></pre></td></tr></table></figure></p>
<p>list本质上是一个有序的对象集合.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">assert</span> list.size() == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> list.getClass() == ArrayList     <span class="comment">// the specific kind of list being used</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> list[<span class="number">2</span>] == <span class="number">7</span>                     <span class="comment">// indexing starts at 0</span></span><br><span class="line"><span class="keyword">assert</span> list.getAt(<span class="number">2</span>) == <span class="number">7</span>               <span class="comment">// equivalent method to subscript operator []</span></span><br><span class="line"><span class="keyword">assert</span> list.get(<span class="number">2</span>) == <span class="number">7</span>                 <span class="comment">// alternative method</span></span><br><span class="line"></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>,]           <span class="comment">// trailing comma OK</span></span><br><span class="line"></span><br><span class="line">list.putAt(<span class="number">2</span>, <span class="number">10</span>)                       <span class="comment">// equivalent method to [] when value being changed</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">assert</span> list.set(<span class="number">2</span>, <span class="number">11</span>) == <span class="number">10</span>            <span class="comment">// alternative method that returns old value</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="number">2.5</span>, <span class="number">2.5</span>f, <span class="number">2.5</span>d, <span class="string">'hello'</span>, <span class="number">7</span>g, <span class="literal">null</span>, <span class="number">9</span> <span class="keyword">as</span> <span class="keyword">byte</span>]</span><br><span class="line"><span class="comment">//objects can be of different types; duplicates allowed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][<span class="number">-1</span>] == <span class="number">5</span>             <span class="comment">// use negative indices to count from the end</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][<span class="number">-2</span>] == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].getAt(<span class="number">-2</span>) == <span class="number">4</span>       <span class="comment">// getAt() available with negative index...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].get(<span class="number">-2</span>)                 <span class="comment">// but negative index not allowed with get()</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">assert</span> e <span class="keyword">instanceof</span> ArrayIndexOutOfBoundsException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="List-as-a-boolean-expression"><a href="#List-as-a-boolean-expression" class="headerlink" title="List as a boolean expression"></a>List as a boolean expression</h4><p>list还可以计算出boolean表达式.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> ![]             <span class="comment">// an empty list evaluates as false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//all other lists, irrespective of contents, evaluate as true</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>] &amp;&amp; [<span class="string">'a'</span>] &amp;&amp; [<span class="number">0</span>] &amp;&amp; [<span class="number">0.0</span>] &amp;&amp; [<span class="literal">false</span>] &amp;&amp; [<span class="literal">null</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="Iterating-on-a-list"><a href="#Iterating-on-a-list" class="headerlink" title="Iterating on a list"></a>Iterating on a list</h4><p>可以通过<code>each</code>, <code>eachWithIndex</code>遍历整个集合.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].each &#123;</span><br><span class="line">    println <span class="string">"Item: $it"</span> <span class="comment">// `it` is an implicit parameter corresponding to the current element</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].eachWithIndex &#123; it, i -&gt; <span class="comment">// `it` is the current element, while `i` is the index</span></span><br><span class="line">    println <span class="string">"$i: $it"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在遍历的时候,我们经常需要将遍历出来的值经过某些运算,然后再重新放进一个新的list中. 这种操作经常称为映射(mapping), 这种操作通过<code>collect</code>方法实现.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].collect &#123; it * <span class="number">2</span> &#125; == [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// shortcut syntax instead of collect</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]*.multiply(<span class="number">2</span>) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].collect &#123; it.multiply(<span class="number">2</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list = [<span class="number">0</span>]</span><br><span class="line"><span class="comment">// it is possible to give `collect` the list which collects the elements</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].collect(list) &#123; it * <span class="number">2</span> &#125; == [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="Manipulating-lists"><a href="#Manipulating-lists" class="headerlink" title="Manipulating lists"></a>Manipulating lists</h4><h5 id="Filtering-and-searching"><a href="#Filtering-and-searching" class="headerlink" title="Filtering and searching"></a>Filtering and searching</h5><p><a href="http://www.groovy-lang.org/gdk.html" target="_blank" rel="external">Groovy development kit</a>提供了许多强大有趣的方法用来强化标准集合:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].find &#123; it &gt; <span class="number">1</span> &#125; == <span class="number">2</span>           <span class="comment">// find 1st element matching criteria</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].findAll &#123; it &gt; <span class="number">1</span> &#125; == [<span class="number">2</span>, <span class="number">3</span>]   <span class="comment">// find all elements matching critieria</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>].findIndexOf &#123;      <span class="comment">// find index of 1st element matching criteria</span></span><br><span class="line">    it <span class="keyword">in</span> [<span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'g'</span>]</span><br><span class="line">&#125; == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>].indexOf(<span class="string">'c'</span>) == <span class="number">2</span>  <span class="comment">// index returned</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>].indexOf(<span class="string">'z'</span>) == <span class="number">-1</span> <span class="comment">// index -1 means value not in list</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>].lastIndexOf(<span class="string">'c'</span>) == <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].every &#123; it &lt; <span class="number">5</span> &#125;               <span class="comment">// returns true if all elements match the predicate</span></span><br><span class="line"><span class="keyword">assert</span> ![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].every &#123; it &lt; <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].any &#123; it &gt; <span class="number">2</span> &#125;                 <span class="comment">// returns true if any element matches the predicate</span></span><br><span class="line"><span class="keyword">assert</span> ![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].any &#123; it &gt; <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].sum() == <span class="number">21</span>                <span class="comment">// sum anything with a plus() method</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>].sum &#123;</span><br><span class="line">    it == <span class="string">'a'</span> ? 1 : it == <span class="string">'b'</span> ? 2 : it == <span class="string">'c'</span> ? 3 : it == <span class="string">'d'</span> ? 4 : it == <span class="string">'e'</span> ? 5 : <span class="number">0</span></span><br><span class="line">    <span class="comment">// custom value to use in sum</span></span><br><span class="line">&#125; == <span class="number">15</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>].sum &#123; ((<span class="keyword">char</span>) it) - ((<span class="keyword">char</span>) <span class="string">'a'</span>) &#125; == <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>].sum() == <span class="string">'abcde'</span></span><br><span class="line"><span class="keyword">assert</span> [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'c'</span>, <span class="string">'d'</span>]].sum() == [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// an initial value can be provided</span></span><br><span class="line"><span class="keyword">assert</span> [].sum(<span class="number">1000</span>) == <span class="number">1000</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sum(<span class="number">1000</span>) == <span class="number">1006</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">'-'</span>) == <span class="string">'1-2-3'</span>           <span class="comment">// String joining</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].inject(<span class="string">'counting: '</span>) &#123;</span><br><span class="line">    str, item -&gt; str + item                     <span class="comment">// reduce operation</span></span><br><span class="line">&#125; == <span class="string">'counting: 123'</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].inject(<span class="number">0</span>) &#123; count, item -&gt;</span><br><span class="line">    count + item</span><br><span class="line">&#125; == <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>下面这段代码是由Groovy语言支撑的在集合中找到最大和最小数的例子:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">assert</span> list.max() == <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> list.min() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we can also compare single characters, as anything comparable</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>].min() == <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we can use a closure to specify the sorting behaviour</span></span><br><span class="line"><span class="keyword">def</span> list2 = [<span class="string">'abc'</span>, <span class="string">'z'</span>, <span class="string">'xyzuvw'</span>, <span class="string">'Hello'</span>, <span class="string">'321'</span>]</span><br><span class="line"><span class="keyword">assert</span> list2.max &#123; it.size() &#125; == <span class="string">'xyzuvw'</span></span><br><span class="line"><span class="keyword">assert</span> list2.min &#123; it.size() &#125; == <span class="string">'z'</span></span><br></pre></td></tr></table></figure></p>
<p>在闭包里,你还可以自定义一个比较规则.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Comparator mc = &#123; a, b -&gt; a == b ? 0 : (a &lt; b ? -1 : <span class="number">1</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">-6</span>, <span class="number">-1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>, <span class="number">5</span>, <span class="number">-13</span>]</span><br><span class="line"><span class="keyword">assert</span> list.max(mc) == <span class="number">11</span></span><br><span class="line"><span class="keyword">assert</span> list.min(mc) == <span class="number">-13</span></span><br><span class="line"></span><br><span class="line">Comparator mc2 = &#123; a, b -&gt; a == b ? 0 : (Math.abs(a) &lt; Math.abs(b)) ? -1 : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> list.max(mc2) == <span class="number">-13</span></span><br><span class="line"><span class="keyword">assert</span> list.min(mc2) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> list.max &#123; a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : <span class="number">1</span> &#125; == <span class="number">-13</span></span><br><span class="line"><span class="keyword">assert</span> list.min &#123; a, b -&gt; a.equals(b) ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : <span class="number">1</span> &#125; == <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Adding-or-removing-elements"><a href="#Adding-or-removing-elements" class="headerlink" title="Adding or removing elements"></a>Adding or removing elements</h5><p>我们可以使用<code>[]</code>去声明一个新的空list, 然后使用<code>&lt;&lt;</code>向list追加元素<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = []</span><br><span class="line"><span class="keyword">assert</span> list.empty</span><br><span class="line"></span><br><span class="line">list &lt;&lt; <span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> list.size() == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">list &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="string">'i'</span> &lt;&lt; <span class="number">11</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">5</span>, <span class="number">7</span>, <span class="string">'i'</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">list &lt;&lt; [<span class="string">'m'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">5</span>, <span class="number">7</span>, <span class="string">'i'</span>, <span class="number">11</span>, [<span class="string">'m'</span>, <span class="string">'o'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//first item in chain of &lt;&lt; is target list</span></span><br><span class="line"><span class="keyword">assert</span> ([<span class="number">1</span>, <span class="number">2</span>] &lt;&lt; <span class="number">3</span> &lt;&lt; [<span class="number">4</span>, <span class="number">5</span>] &lt;&lt; <span class="number">6</span>) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//using leftShift is equivalent to using &lt;&lt;</span></span><br><span class="line"><span class="keyword">assert</span> ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;&lt; <span class="number">4</span>) == ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].leftShift(<span class="number">4</span>))</span><br><span class="line">```groovy</span><br><span class="line">We can add to a list <span class="keyword">in</span> many <span class="string">ways:</span></span><br><span class="line">```groovy</span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>] + <span class="number">3</span> + [<span class="number">4</span>, <span class="number">5</span>] + <span class="number">6</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// equivalent to calling the `plus` method</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>].plus(<span class="number">3</span>).plus([<span class="number">4</span>, <span class="number">5</span>]).plus(<span class="number">6</span>) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a += <span class="number">4</span>      <span class="comment">// creates a new list and assigns it to `a`</span></span><br><span class="line">a += [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">assert</span> a == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, *[<span class="number">222</span>, <span class="number">333</span>], <span class="number">456</span>] == [<span class="number">1</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">456</span>]</span><br><span class="line"><span class="keyword">assert</span> [*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>], <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]].flatten() == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list.add(<span class="number">3</span>)</span><br><span class="line">list.addAll([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list.add(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// add 3 just before index 1</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">list.addAll(<span class="number">2</span>, [<span class="number">5</span>, <span class="number">4</span>]) <span class="comment">//add [5,4] just before index 2</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'z'</span>, <span class="string">'e'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'g'</span>]</span><br><span class="line">list[<span class="number">8</span>] = <span class="string">'x'</span> <span class="comment">// the [] operator is growing the list as needed</span></span><br><span class="line"><span class="comment">// nulls inserted if required</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'z'</span>, <span class="string">'e'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'g'</span>, <span class="literal">null</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure></p>
<p>在list中<code>+</code>的语义并没有发生变化,这是何等的重要啊~~~ 与<code>&lt;&lt;</code>相比, <code>+</code>会创建一个新的list,  但是这个创建的list很可能不是你所预期的, 而且这种方式也可能会导致一些性能问题.</p>
<p><code>Groovy development kit</code>同样提供了很多便捷的方式从list里删除元素:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>] - <span class="string">'c'</span> == [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>] - <span class="string">'b'</span> == [<span class="string">'a'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>] - [<span class="string">'b'</span>,<span class="string">'c'</span>] == [<span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">list -= <span class="number">3</span>           <span class="comment">// creates a new list by removing `3` from the original one</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">assert</span> ( list -= [<span class="number">2</span>,<span class="number">4</span>] ) == [<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>同样,你也能通过索引的方式从list里删除元素.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">assert</span> list.remove(<span class="number">2</span>) == <span class="number">3</span>          <span class="comment">// remove the third element, and return it</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>假设,你如果从list中删除多个相同元素中的第一个, 那你可以调用<code>remove</code>方法.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list= [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">assert</span> list.remove(<span class="string">'c'</span>)             <span class="comment">// remove 'c', and return true because element removed</span></span><br><span class="line"><span class="keyword">assert</span> list.remove(<span class="string">'b'</span>)             <span class="comment">// remove first 'b', and return true because element removed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> ! list.remove(<span class="string">'z'</span>)           <span class="comment">// return false because no elements removed</span></span><br><span class="line"><span class="keyword">assert</span> list == [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果你想要将list清空的话,只需要调用<code>clear</code>方法即可<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list= [<span class="string">'a'</span>,<span class="number">2</span>,<span class="string">'c'</span>,<span class="number">4</span>]</span><br><span class="line">list.clear()</span><br><span class="line"><span class="keyword">assert</span> list == []</span><br></pre></td></tr></table></figure></p>
<h5 id="Set-operations"><a href="#Set-operations" class="headerlink" title="Set operations"></a>Set operations</h5><p><code>Groovy development kit</code>还包含很多逻辑运算的方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">'a'</span> <span class="keyword">in</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]             <span class="comment">// returns true if an element belongs to the list</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].contains(<span class="string">'a'</span>)      <span class="comment">// equivalent to the `contains` method in Java</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>].containsAll([<span class="number">1</span>,<span class="number">4</span>])       <span class="comment">// `containsAll` will check that all elements are found</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].count(<span class="number">3</span>) == <span class="number">4</span>  <span class="comment">// count the number of elements which have some value</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].count &#123;</span><br><span class="line">    it%<span class="number">2</span>==<span class="number">0</span>                             <span class="comment">// count the number of elements which match the predicate</span></span><br><span class="line">&#125; == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>].intersect([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>]) == [<span class="number">1</span>,<span class="number">6</span>,<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].disjoint( [<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>] )</span><br><span class="line"><span class="keyword">assert</span> ![<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].disjoint( [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>] )</span><br></pre></td></tr></table></figure></p>
<h5 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h5><p>Groovy还提供了很多使用闭包比较器的排序操作<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>].sort() == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list = [<span class="string">'abc'</span>, <span class="string">'z'</span>, <span class="string">'xyzuvw'</span>, <span class="string">'Hello'</span>, <span class="string">'321'</span>]</span><br><span class="line"><span class="keyword">assert</span> list.sort &#123;</span><br><span class="line">    it.size()</span><br><span class="line">&#125; == [<span class="string">'z'</span>, <span class="string">'abc'</span>, <span class="string">'321'</span>, <span class="string">'Hello'</span>, <span class="string">'xyzuvw'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list2 = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">-6</span>, <span class="number">-1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-9</span>, <span class="number">5</span>, <span class="number">-13</span>]</span><br><span class="line"><span class="keyword">assert</span> list2.sort &#123; a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : <span class="number">1</span> &#125; ==</span><br><span class="line">        [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-9</span>, <span class="number">11</span>, <span class="number">-13</span>]</span><br><span class="line"></span><br><span class="line">Comparator mc = &#123; a, b -&gt; a == b ? 0 : Math.abs(a) &lt; Math.abs(b) ? -1 : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 8+ only</span></span><br><span class="line"><span class="comment">// list2.sort(mc)</span></span><br><span class="line"><span class="comment">// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> list3 = [<span class="number">6</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">-7</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">Collections.sort(list3)</span><br><span class="line"><span class="keyword">assert</span> list3 == [<span class="number">-7</span>, <span class="number">-3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">Collections.sort(list3, mc)</span><br><span class="line"><span class="keyword">assert</span> list3 == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="Duplicating-elements"><a href="#Duplicating-elements" class="headerlink" title="Duplicating elements"></a>Duplicating elements</h5><p><code>roovy development kit</code>还通过重载操作符的方式, 内部提供了一些方法进行list元素复制.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span> == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].multiply(<span class="number">2</span>) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> Collections.nCopies(<span class="number">3</span>, <span class="string">'b'</span>) == [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// nCopies from the JDK has different semantics than multiply for lists</span></span><br><span class="line"><span class="keyword">assert</span> Collections.nCopies(<span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>]) == [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]] <span class="comment">//not [1,2,1,2]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Groovy 数组重用了list符号, 但是如果想要创建数组, 那么就必须强制地显式定义数组类型<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] arrStr = [<span class="string">'Ananas'</span>, <span class="string">'Banana'</span>, <span class="string">'Kiwi'</span>]  (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> arrStr <span class="keyword">instanceof</span> String[]    (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> !(arrStr <span class="keyword">instanceof</span> List)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> numArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">int</span>[]      (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numArr <span class="keyword">instanceof</span> <span class="keyword">int</span>[]       (<span class="number">4</span>)</span><br><span class="line"><span class="keyword">assert</span> numArr.size() == <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用显式变量类型定义了一个字符串数组</li>
<li>断言刚才创建的数组是否是string类型</li>
<li>使用操作符定义一个int数组</li>
<li>断言刚才创建的数组是否是int类型</li>
</ol>
<p>我们也可以创建出一个多维数组<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> matrix3 = <span class="keyword">new</span> Integer[<span class="number">3</span>][<span class="number">3</span>]         (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span> matrix3.size() == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Integer[][] matrix2                     (<span class="number">2</span>)</span><br><span class="line">matrix2 = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">assert</span> matrix2 <span class="keyword">instanceof</span> Integer[][]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>我们指定了新数组的边界</li>
<li>当然我们也可以不指定它的边界</li>
</ol>
<p>访问数组元素和访问list元素的方式相同<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = [<span class="string">'Cédric'</span>, <span class="string">'Guillaume'</span>, <span class="string">'Jochen'</span>, <span class="string">'Paul'</span>]</span><br><span class="line"><span class="keyword">assert</span> names[<span class="number">0</span>] == <span class="string">'Cédric'</span>     (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">names[<span class="number">2</span>] = <span class="string">'Blackdrag'</span>          (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> names[<span class="number">2</span>] == <span class="string">'Blackdrag'</span></span><br></pre></td></tr></table></figure></p>
<p>1    Retrieve the first element of the array<br>2    Set the value of the third element of the array to a new value</p>
<ol>
<li>检索数组中第一个元素</li>
<li>对数组中第三个元素重新赋值</li>
</ol>
<p>Groovy不支持Java数组初始化语法, 因为Java数组中的花括号可能被会Groovy无解成闭包</p>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>有时候我们在其他语言中称map为 字典或者关联数组. Map将key和value关联起来, 在Groovy中map被<code>[]</code>括起来, 通过<code>,</code>分割键值对, 键值通过<code>:</code>分割<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> colors = [<span class="string">red:</span> <span class="string">'#FF0000'</span>, <span class="string">green:</span> <span class="string">'#00FF00'</span>, <span class="string">blue:</span> <span class="string">'#0000FF'</span>]   (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">'red'</span>] == <span class="string">'#FF0000'</span>    (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> colors.green  == <span class="string">'#00FF00'</span>    (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">colors[<span class="string">'pink'</span>] = <span class="string">'#FF00FF'</span>           (<span class="number">4</span>)</span><br><span class="line">colors.yellow  = <span class="string">'#FFFF00'</span>           (<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors.pink == <span class="string">'#FF00FF'</span></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">'yellow'</span>] == <span class="string">'#FFFF00'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors <span class="keyword">instanceof</span> java.util.LinkedHashMap</span><br></pre></td></tr></table></figure></p>
<ol>
<li>我们定义了一个string类型的代表颜色名字的数组,</li>
<li>然后使用下标来检索map中是否包含red这个key</li>
<li>我们还可以直接使用<code>.</code>来索引到某个key</li>
<li>我们可以使用下标向map中添加一个新的键值对</li>
<li>我们也可以使用<code>.</code>添加一个新的键值对</li>
</ol>
<p>Groovy创建的map类型默认的是<code>java.util.LinkedHashMap</code></p>
<p>当你想要访问一个不存在的key时：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> colors.unknown == <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<p>你将检索出一个null的结果</p>
<p>在上面的例子中我们使用的是以string作为key, 但是你还可以使用其他类型作为map的key：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> numbers = [<span class="number">1</span>: <span class="string">'one'</span>, <span class="number">2</span>: <span class="string">'two'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numbers[<span class="number">1</span>] == <span class="string">'one'</span></span><br></pre></td></tr></table></figure>
<p>我们使用了number作为了map新的key类型, number类型就会直接被解释为number类型, 因此Groovy不会像先前那样创建一个string类型的key. 但是假设你想要传递一个变量作为key,是变量的值作为key：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> key = <span class="string">'name'</span></span><br><span class="line"><span class="keyword">def</span> person = [<span class="string">key:</span> <span class="string">'Guillaume'</span>]      (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> !person.containsKey(<span class="string">'name'</span>)   (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> person.containsKey(<span class="string">'key'</span>)     (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>与<code>\&#39;Guillaume&#39;</code> 关联的key实际上是<code>&quot;key&quot;</code>这个字符串, 而不是这个key的引用值<code>&#39;name&#39;</code></li>
<li>map中不包含<code>&#39;name&#39;</code>key</li>
<li>取而代之的是map中包含一个<code>&quot;key&quot;</code>的字符串</li>
</ol>
<p>你可以向map中传递一个引号字符串作为key,例如<code>[&quot;name&quot;: &quot;Guillaume&quot;]</code>.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = [(key): <span class="string">'Guillaume'</span>]        (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> person.containsKey(<span class="string">'name'</span>)    (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> !person.containsKey(<span class="string">'key'</span>)    (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>1    This time, we surround the key variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key<br>2    The map does contain the name key<br>3    But the map doesn’t contain the key key as before<br>1.<br>2.<br>3.</p>
<h4 id="Map-literals"><a href="#Map-literals" class="headerlink" title="Map literals"></a>Map literals</h4><p>在Groovy中可以使用<code>[:]</code> 创建一个map.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [<span class="string">name:</span> <span class="string">'Gromit'</span>, <span class="string">likes:</span> <span class="string">'cheese'</span>, <span class="string">id:</span> <span class="number">1234</span>]</span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="string">'name'</span>) == <span class="string">'Gromit'</span></span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="string">'id'</span>) == <span class="number">1234</span></span><br><span class="line"><span class="keyword">assert</span> map[<span class="string">'name'</span>] == <span class="string">'Gromit'</span></span><br><span class="line"><span class="keyword">assert</span> map[<span class="string">'id'</span>] == <span class="number">1234</span></span><br><span class="line"><span class="keyword">assert</span> map <span class="keyword">instanceof</span> java.util.Map</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> emptyMap = [:]</span><br><span class="line"><span class="keyword">assert</span> emptyMap.size() == <span class="number">0</span></span><br><span class="line">emptyMap.put(<span class="string">"foo"</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> emptyMap.size() == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> emptyMap.get(<span class="string">"foo"</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>Map的key默认是<code>string</code>, 例如<code>[a:1]</code>等同于<code>[&#39;a&#39;:1]</code>. 比较荣誉造成疑惑的就是,如果你创建了一个变量a(值为b), 但是你将变量a<code>put</code>进map后, map的key会是a,而不是b. 如果你遇到了这个情况的话,那么你必须对使用<code>()</code>key进行转义了.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="string">'Bob'</span></span><br><span class="line"><span class="keyword">def</span> ages = [<span class="string">a:</span> <span class="number">43</span>]</span><br><span class="line"><span class="keyword">assert</span> ages[<span class="string">'Bob'</span>] == <span class="literal">null</span> <span class="comment">// `Bob` is not found</span></span><br><span class="line"><span class="keyword">assert</span> ages[<span class="string">'a'</span>] == <span class="number">43</span>     <span class="comment">// because `a` is a literal!</span></span><br><span class="line"></span><br><span class="line">ages = [(a): <span class="number">43</span>]            <span class="comment">// now we escape `a` by using parenthesis</span></span><br><span class="line"><span class="keyword">assert</span> ages[<span class="string">'Bob'</span>] == <span class="number">43</span>   <span class="comment">// and the value is found!</span></span><br></pre></td></tr></table></figure></p>
<p>通过下面的方式你可以轻松克隆一个map<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [</span><br><span class="line">        <span class="string">simple :</span> <span class="number">123</span>,</span><br><span class="line"><span class="symbol">        complex:</span> [<span class="string">a:</span> <span class="number">1</span>, <span class="string">b:</span> <span class="number">2</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">def</span> map2 = map.clone()</span><br><span class="line"><span class="keyword">assert</span> map2.get(<span class="string">'simple'</span>) == map.get(<span class="string">'simple'</span>)</span><br><span class="line"><span class="keyword">assert</span> map2.get(<span class="string">'complex'</span>) == map.get(<span class="string">'complex'</span>)</span><br><span class="line">map2.get(<span class="string">'complex'</span>).put(<span class="string">'c'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="string">'complex'</span>).get(<span class="string">'c'</span>) == <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Map-property-notation"><a href="#Map-property-notation" class="headerlink" title="Map property notation"></a>Map property notation</h4><p>Maps和beans也是非常相像的, 所以你可以对map使用<code>get/set</code>操作元素,当然这也有个前提,那就是map中的key必须是符合Groovy标识符的key.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [<span class="string">name:</span> <span class="string">'Gromit'</span>, <span class="string">likes:</span> <span class="string">'cheese'</span>, <span class="string">id:</span> <span class="number">1234</span>]</span><br><span class="line"><span class="keyword">assert</span> map.name == <span class="string">'Gromit'</span>     <span class="comment">// can be used instead of map.get('Gromit')</span></span><br><span class="line"><span class="keyword">assert</span> map.id == <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> emptyMap = [:]</span><br><span class="line"><span class="keyword">assert</span> emptyMap.size() == <span class="number">0</span></span><br><span class="line">emptyMap.foo = <span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> emptyMap.size() == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> emptyMap.foo == <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>注意:<code>map.foo</code>总是会在map中查找key<code>foo</code>. 这意味着,<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [<span class="string">name:</span> <span class="string">'Gromit'</span>, <span class="string">likes:</span> <span class="string">'cheese'</span>, <span class="string">id:</span> <span class="number">1234</span>]</span><br><span class="line"><span class="keyword">assert</span> map.<span class="keyword">class</span> == <span class="literal">null</span></span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="string">'class'</span>) == <span class="literal">null</span></span><br><span class="line"><span class="keyword">assert</span> map.getClass() == LinkedHashMap <span class="comment">// this is probably what you want</span></span><br><span class="line"></span><br><span class="line">map = [<span class="number">1</span>      : <span class="string">'a'</span>,</span><br><span class="line">       (<span class="literal">true</span>) : <span class="string">'p'</span>,</span><br><span class="line">       (<span class="literal">false</span>): <span class="string">'q'</span>,</span><br><span class="line">       (<span class="literal">null</span>) : <span class="string">'x'</span>,</span><br><span class="line">       <span class="string">'null'</span> : <span class="string">'z'</span>]</span><br><span class="line"><span class="keyword">assert</span> map.containsKey(<span class="number">1</span>) <span class="comment">// 1 is not an identifier so used as is</span></span><br><span class="line"><span class="keyword">assert</span> map.<span class="literal">true</span> == <span class="literal">null</span></span><br><span class="line"><span class="keyword">assert</span> map.<span class="literal">false</span> == <span class="literal">null</span></span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="literal">true</span>) == <span class="string">'p'</span></span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="literal">false</span>) == <span class="string">'q'</span></span><br><span class="line"><span class="keyword">assert</span> map.<span class="literal">null</span> == <span class="string">'z'</span></span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="literal">null</span>) == <span class="string">'x'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Iterating-on-maps"><a href="#Iterating-on-maps" class="headerlink" title="Iterating on maps"></a>Iterating on maps</h4><p><code>Groovy development kit</code>还提供了<code>eachWithIndex</code>方法遍历map.值得注意的是,map会保留put元素的顺序,也就是说,当你遍历一个map的时候,无论进行多少次,你获得的元素的顺序是一定的.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [</span><br><span class="line">        <span class="string">Bob  :</span> <span class="number">42</span>,</span><br><span class="line"><span class="symbol">        Alice:</span> <span class="number">54</span>,</span><br><span class="line">        <span class="string">Max  :</span> <span class="number">33</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// `entry` is a map entry</span></span><br><span class="line">map.each &#123; entry -&gt;</span><br><span class="line">    println <span class="string">"Name: $entry.key Age: $entry.value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `entry` is a map entry, `i` the index in the map</span></span><br><span class="line">map.eachWithIndex &#123; entry, i -&gt;</span><br><span class="line">    println <span class="string">"$i - Name: $entry.key Age: $entry.value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternatively you can use key and value directly</span></span><br><span class="line">map.each &#123; key, value -&gt;</span><br><span class="line">    println <span class="string">"Name: $key Age: $value"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key, value and i as the index in the map</span></span><br><span class="line">map.eachWithIndex &#123; key, value, i -&gt;</span><br><span class="line">    println <span class="string">"$i - Name: $key Age: $value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Manipulating-maps"><a href="#Manipulating-maps" class="headerlink" title="Manipulating maps"></a>Manipulating maps</h4><h5 id="Adding-or-removing-elements-1"><a href="#Adding-or-removing-elements-1" class="headerlink" title="Adding or removing elements"></a>Adding or removing elements</h5><p>向map中添加元素你可以使用<code>put</code>方法, <code>下标</code>, <code>putAll</code>方法.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> defaults = [<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>]</span><br><span class="line"><span class="keyword">def</span> overrides = [<span class="number">2</span>: <span class="string">'z'</span>, <span class="number">5</span>: <span class="string">'x'</span>, <span class="number">13</span>: <span class="string">'x'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> result = <span class="keyword">new</span> LinkedHashMap(defaults)</span><br><span class="line">result.put(<span class="number">15</span>, <span class="string">'t'</span>)</span><br><span class="line">result[<span class="number">17</span>] = <span class="string">'u'</span></span><br><span class="line">result.putAll(overrides)</span><br><span class="line"><span class="keyword">assert</span> result == [<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'z'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>, <span class="number">5</span>: <span class="string">'x'</span>, <span class="number">13</span>: <span class="string">'x'</span>, <span class="number">15</span>: <span class="string">'t'</span>, <span class="number">17</span>: <span class="string">'u'</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果想要删除map中全部的元素,可以使用<code>clear</code>方法.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> m = [<span class="number">1</span>:<span class="string">'a'</span>, <span class="number">2</span>:<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">assert</span> m.get(<span class="number">1</span>) == <span class="string">'a'</span></span><br><span class="line">m.clear()</span><br><span class="line"><span class="keyword">assert</span> m == [:]</span><br></pre></td></tr></table></figure></p>
<p>通过map字面量标记创建的map会使用<code>object</code>的<code>equals</code>方法和<code>hashcode</code>方法.</p>
<p>还要注意的是,不要使用GString作为map的key, 因为GString的hashcode方法和String的hashcode方法不一样.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> key = <span class="string">'some key'</span></span><br><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"><span class="keyword">def</span> gstringKey = <span class="string">"$&#123;key.toUpperCase()&#125;"</span></span><br><span class="line">map.put(gstringKey,<span class="string">'value'</span>)</span><br><span class="line"><span class="keyword">assert</span> map.get(<span class="string">'SOME KEY'</span>) == <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Keys-values-and-entries"><a href="#Keys-values-and-entries" class="headerlink" title="Keys, values and entries"></a>Keys, values and entries</h5><p>我们可以在视图中inspect<code>keys, values, and entries</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [<span class="number">1</span>:<span class="string">'a'</span>, <span class="number">2</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> entries = map.entrySet()</span><br><span class="line">entries.each &#123; entry -&gt;</span><br><span class="line">  <span class="keyword">assert</span> entry.key <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">assert</span> entry.value <span class="keyword">in</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> keys = map.keySet()</span><br><span class="line"><span class="keyword">assert</span> keys == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">as</span> Set</span><br></pre></td></tr></table></figure></p>
<p>Mutating values returned by the view (be it a map entry, a key or a value) is highly discouraged because success of the operation directly depends on the type of the map being manipulated. In particular, Groovy relies on collections from the JDK that in general make no guarantee that a collection can safely be manipulated through keySet, entrySet, or values.</p>
<h5 id="Filtering-and-searching-1"><a href="#Filtering-and-searching-1" class="headerlink" title="Filtering and searching"></a>Filtering and searching</h5><p>The Groovy development kit contains filtering, searching and collecting methods similar to those found for lists:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> people = [</span><br><span class="line"><span class="symbol">    1:</span> [<span class="string">name:</span><span class="string">'Bob'</span>, <span class="string">age:</span> <span class="number">32</span>, <span class="string">gender:</span> <span class="string">'M'</span>],</span><br><span class="line"><span class="symbol">    2:</span> [<span class="string">name:</span><span class="string">'Johnny'</span>, <span class="string">age:</span> <span class="number">36</span>, <span class="string">gender:</span> <span class="string">'M'</span>],</span><br><span class="line"><span class="symbol">    3:</span> [<span class="string">name:</span><span class="string">'Claire'</span>, <span class="string">age:</span> <span class="number">21</span>, <span class="string">gender:</span> <span class="string">'F'</span>],</span><br><span class="line"><span class="symbol">    4:</span> [<span class="string">name:</span><span class="string">'Amy'</span>, <span class="string">age:</span> <span class="number">54</span>, <span class="string">gender:</span><span class="string">'F'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> bob = people.find &#123; it.value.name == <span class="string">'Bob'</span> &#125; <span class="comment">// find a single entry</span></span><br><span class="line"><span class="keyword">def</span> females = people.findAll &#123; it.value.gender == <span class="string">'F'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// both return entries, but you can use collect to retrieve the ages for example</span></span><br><span class="line"><span class="keyword">def</span> ageOfBob = bob.value.age</span><br><span class="line"><span class="keyword">def</span> agesOfFemales = females.collect &#123;</span><br><span class="line">    it.value.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> ageOfBob == <span class="number">32</span></span><br><span class="line"><span class="keyword">assert</span> agesOfFemales == [<span class="number">21</span>,<span class="number">54</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// but you could also use a key/pair value as the parameters of the closures</span></span><br><span class="line"><span class="keyword">def</span> agesOfMales = people.findAll &#123; id, person -&gt;</span><br><span class="line">    person.gender == <span class="string">'M'</span></span><br><span class="line">&#125;.collect &#123; id, person -&gt;</span><br><span class="line">    person.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> agesOfMales == [<span class="number">32</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// `every` returns true if all entries match the predicate</span></span><br><span class="line"><span class="keyword">assert</span> people.every &#123; id, person -&gt;</span><br><span class="line">    person.age &gt; <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `any` returns true if any entry matches the predicate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> people.any &#123; id, person -&gt;</span><br><span class="line">    person.age == <span class="number">54</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Grouping"><a href="#Grouping" class="headerlink" title="Grouping"></a>Grouping</h5><p>We can group a list into a map using some criteria:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="number">7</span>, <span class="string">'b'</span>, [<span class="number">2</span>, <span class="number">3</span>]].groupBy &#123;</span><br><span class="line">    it.<span class="keyword">class</span></span><br><span class="line">&#125; == [(String)   : [<span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">      (Integer)  : [<span class="number">7</span>],</span><br><span class="line">      (ArrayList): [[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [</span><br><span class="line">        [<span class="string">name:</span> <span class="string">'Clark'</span>, <span class="string">city:</span> <span class="string">'London'</span>], [<span class="string">name:</span> <span class="string">'Sharma'</span>, <span class="string">city:</span> <span class="string">'London'</span>],</span><br><span class="line">        [<span class="string">name:</span> <span class="string">'Maradona'</span>, <span class="string">city:</span> <span class="string">'LA'</span>], [<span class="string">name:</span> <span class="string">'Zhang'</span>, <span class="string">city:</span> <span class="string">'HK'</span>],</span><br><span class="line">        [<span class="string">name:</span> <span class="string">'Ali'</span>, <span class="string">city:</span> <span class="string">'HK'</span>], [<span class="string">name:</span> <span class="string">'Liu'</span>, <span class="string">city:</span> <span class="string">'HK'</span>],</span><br><span class="line">].groupBy &#123; it.city &#125; == [</span><br><span class="line"><span class="symbol">        London:</span> [[<span class="string">name:</span> <span class="string">'Clark'</span>, <span class="string">city:</span> <span class="string">'London'</span>],</span><br><span class="line">                 [<span class="string">name:</span> <span class="string">'Sharma'</span>, <span class="string">city:</span> <span class="string">'London'</span>]],</span><br><span class="line">        <span class="string">LA    :</span> [[<span class="string">name:</span> <span class="string">'Maradona'</span>, <span class="string">city:</span> <span class="string">'LA'</span>]],</span><br><span class="line">        <span class="string">HK    :</span> [[<span class="string">name:</span> <span class="string">'Zhang'</span>, <span class="string">city:</span> <span class="string">'HK'</span>],</span><br><span class="line">                 [<span class="string">name:</span> <span class="string">'Ali'</span>, <span class="string">city:</span> <span class="string">'HK'</span>],</span><br><span class="line">                 [<span class="string">name:</span> <span class="string">'Liu'</span>, <span class="string">city:</span> <span class="string">'HK'</span>]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h3><p>Ranges allow you to create a list of sequential values. These can be used as List since Range extends java.util.List.</p>
<p>Ranges defined with the .. notation are inclusive (that is the list contains the from and to value).</p>
<p>Ranges defined with the ..&lt; notation are half-open, they include the first value but not the last value.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an inclusive range</span></span><br><span class="line"><span class="keyword">def</span> range = <span class="number">5.</span><span class="number">.8</span></span><br><span class="line"><span class="keyword">assert</span> range.size() == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> range.get(<span class="number">2</span>) == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> range[<span class="number">2</span>] == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> range <span class="keyword">instanceof</span> java.util.List</span><br><span class="line"><span class="keyword">assert</span> range.contains(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> range.contains(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// lets use a half-open range</span></span><br><span class="line">range = <span class="number">5.</span>.&lt;<span class="number">8</span></span><br><span class="line"><span class="keyword">assert</span> range.size() == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> range.get(<span class="number">2</span>) == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> range[<span class="number">2</span>] == <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> range <span class="keyword">instanceof</span> java.util.List</span><br><span class="line"><span class="keyword">assert</span> range.contains(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> !range.contains(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the end points of the range without using indexes</span></span><br><span class="line">range = <span class="number">1.</span><span class="number">.10</span></span><br><span class="line"><span class="keyword">assert</span> range.from == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> range.to == <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Note that int ranges are implemented efficiently, creating a lightweight Java object containing a from and to value.</p>
<p>Ranges can be used for any Java object which implements java.lang.Comparable for comparison and also have methods next() and previous() to return the next / previous item in the range. For example, you can create a range of String elements:</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Groovy/">Groovy</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/04/08/groovy/groovy集合/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/04/08/groovy/groovy集合/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/7/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="ming15" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Groovy/" title="Groovy">Groovy<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Haskell/" title="Haskell">Haskell<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JMH/" title="JMH">JMH<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java工具/" title="Java工具">Java工具<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Netty/" title="Netty">Netty<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Php/" title="Php">Php<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Reids/" title="Reids">Reids<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCP-IP/" title="TCP IP">TCP IP<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ZooKeeper/" title="ZooKeeper">ZooKeeper<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/asm/" title="asm">asm<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/guice/" title="guice">guice<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/http客户端/" title="http客户端">http客户端<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/http服务器/" title="http服务器">http服务器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/memcached/" title="memcached">memcached<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/mgits/" title="mgits">mgits<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/mycat/" title="mycat">mycat<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/python2/" title="python2">python2<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发编程/" title="并发编程">并发编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/序列化工具/" title="序列化工具">序列化工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志工具/" title="日志工具">日志工具<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/构建工具/" title="构建工具">构建工具<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="http://www1.vertx3.cn" target="_blank" title="vertx3">vertx3</a>
            
          </li>
        
    </ul>
</div>

  

<div class="doubanshow">
<p class="asidetitle">Douban Show</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/xxxyy/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=3253370782&verifier=e9ca895b&dpc=1"></iframe>
</div>


  

<div class="lofter">
<p class="asidetitle">Lofter</p>

 <iframe width="100%" height="39" class="share_self"  frameborder="0" scrolling="no" src="http://ming15.lofter.com/"></iframe>
</div>




</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 博客,我选择重构 <br/>
			重构使事情变得更美,更加正确</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/3253370782" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/ming15" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xxxyy" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/ming15" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="ming15">ming15</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"wanggnim"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e8fca440159a2125668804e46682db4' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
