category: 
- collection
title: LinkedBlockingDequeʹʽ̰߳ȫб
---
# LinkedBlockingDeque 阻塞式并发列?

LinkedBlockingDeque是一个由链表结构组成的双向阻塞队?所谓双向队列指的你可以从队列的两端插入和移出元?
双端队列因为多了一个操作队列的入口,在多线程同时入队?也就减少了一半的竞争.相比其他的阻塞队?LinkedBlockingDeque多了addFirst
,addLast,offerFirst,offerLast,peekFirst,peekLast等方?以First单词结尾的方?表示插入,获取（peek）或移除双端队列的第一个元?以Last单词结尾的方?表示插入,获取或移除双端队列的最后一个元?另外插入方法add等同于addLast,移除方法remove等效于removeFirst.但是take方法却等同于takeFirst ,不知道是不是Jdk的bug,使用时还是用带有First和Last后缀的方法更清楚.
在初始化LinkedBlockingDeque时可以初始化队列的容?,用来防止其再扩容时过渡膨胀.另外双向阻塞队列可以运用在“工作窃取”模式中.

> 阻塞式并发列表与非阻塞式并发列表主要区别在于?
> 阻塞式并发列表在插入或者删除元素时,如果列表已满或者列表为?操作不会立即被执?而是将调用这个操作的线程阻塞队列直到操作可以执行成功.

* takeFirst();	// 返回并移除列表中的第一个元?列表为空线程将阻?
* takeLast();	// 返回并移除列表中的最后一个元?列表为空线程将阻?
* pollFirst();	// 返回并移除列表中的第一个元?列表为空返回null
* pollLast();  // 返回并移除列表中的最后一个元?列表为空返回null

* getFirst();	// 返回列表中的第一个元素但不移?列表为空抛出NoSuchElementException
* getLast();	// 返回列表中的最后一个元素但不移?列表为空抛出NoSuchElementException
* peek();		// 返回列表中的第一个元素但不移?列表为空返回null
* peekFirst();	// 返回列表中的第一个元素但不移?列表为空返回null
* peekLast();	// 返回列表中的最后一个元素但不移?列表为空返回null


LinkedBlockingQueue是一个用链表实现的有界阻塞队?此队列的默认和最大长度为Integer.MAX_VALUE.此队列按照先进先出的原则对元素进行排?

一种通过链表实现的阻塞队列，支持先进先出.队列的头部是队列中保持时间最长的元素，队列的尾部是保持时间最短的元素.新元素插入队列的尾部.
可选的容量设置可以有效防止队列过于扩张造成系统资源的过多消耗，如果不指定队列容量，队列默认使用Integer.MAX_VALUE.LinkedBlockingQueue的特定是，支持无限（理论上）容量.

LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实?此队列按FIFO（先进先出）排序元素.队列的头?是在队列中时间最长的元素.队列的尾?是在队列中时间最短的元素.

新元素插入到队列的尾?并且队列检索操作会获得位于队列头部的元?

链接队列的吞吐量通常要高于基于数组的队列,

但是在大多数并发应用程序?其可预知的性能要低.可选的容量范围构造方法参数作为防止队列过度扩展的一种方?如果未指定容?则它等于Integer.MAX_VALUE.除非插入节点会使队列超出容量,否则每次插入后会动态地创建链接节点.

1. 如果未指定容?默认容量为Integer.MAX_VALUE ,容量范围可以在构造方法参数中指定作为防止队列过度扩展.
2. 此对象是 线程阻塞-安全?
3. 不接?null 元素
4. 它实现了BlockingQueue接口.
5. 实现?Collection ?Iterator 接口的所有可?方法.

