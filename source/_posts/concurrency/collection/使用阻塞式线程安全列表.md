category: 
- collection
title: collection\ʹʽ̰߳ȫб
---
# LinkedBlockingDeque 阻塞式并发列表

LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列.所谓双向队列指的你可以从队列的两端插入和移出元素.
双端队列因为多了一个操作队列的入口,在多线程同时入队时,也就减少了一半的竞争.相比其他的阻塞队列,LinkedBlockingDeque多了addFirst
,addLast,offerFirst,offerLast,peekFirst,peekLast等方法,以First单词结尾的方法,表示插入,获取（peek）或移除双端队列的第一个元素.以Last单词结尾的方法,表示插入,获取或移除双端队列的最后一个元素.另外插入方法add等同于addLast,移除方法remove等效于removeFirst.但是take方法却等同于takeFirst ,不知道是不是Jdk的bug,使用时还是用带有First和Last后缀的方法更清楚.
在初始化LinkedBlockingDeque时可以初始化队列的容量 ,用来防止其再扩容时过渡膨胀.另外双向阻塞队列可以运用在“工作窃取”模式中.

> 阻塞式并发列表与非阻塞式并发列表主要区别在于：
> 阻塞式并发列表在插入或者删除元素时,如果列表已满或者列表为空,操作不会立即被执行,而是将调用这个操作的线程阻塞队列直到操作可以执行成功.

* takeFirst();	// 返回并移除列表中的第一个元素,列表为空线程将阻塞
* takeLast();	// 返回并移除列表中的最后一个元素,列表为空线程将阻塞
* pollFirst();	// 返回并移除列表中的第一个元素,列表为空返回null
* pollLast();  // 返回并移除列表中的最后一个元素,列表为空返回null

* getFirst();	// 返回列表中的第一个元素但不移除,列表为空抛出NoSuchElementException
* getLast();	// 返回列表中的最后一个元素但不移除,列表为空抛出NoSuchElementException
* peek();		// 返回列表中的第一个元素但不移除,列表为空返回null
* peekFirst();	// 返回列表中的第一个元素但不移除,列表为空返回null
* peekLast();	// 返回列表中的最后一个元素但不移除,列表为空返回null


LinkedBlockingQueue是一个用链表实现的有界阻塞队列.此队列的默认和最大长度为Integer.MAX_VALUE.此队列按照先进先出的原则对元素进行排序.

一种通过链表实现的阻塞队列，支持先进先出.队列的头部是队列中保持时间最长的元素，队列的尾部是保持时间最短的元素.新元素插入队列的尾部.
可选的容量设置可以有效防止队列过于扩张造成系统资源的过多消耗，如果不指定队列容量，队列默认使用Integer.MAX_VALUE.LinkedBlockingQueue的特定是，支持无限（理论上）容量.

LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实现.此队列按FIFO（先进先出）排序元素.队列的头部 是在队列中时间最长的元素.队列的尾部 是在队列中时间最短的元素.

新元素插入到队列的尾部,并且队列检索操作会获得位于队列头部的元素.

链接队列的吞吐量通常要高于基于数组的队列,

但是在大多数并发应用程序中,其可预知的性能要低.可选的容量范围构造方法参数作为防止队列过度扩展的一种方法.如果未指定容量,则它等于Integer.MAX_VALUE.除非插入节点会使队列超出容量,否则每次插入后会动态地创建链接节点.

1. 如果未指定容量,默认容量为Integer.MAX_VALUE ,容量范围可以在构造方法参数中指定作为防止队列过度扩展.
2. 此对象是 线程阻塞-安全的
3. 不接受 null 元素
4. 它实现了BlockingQueue接口.
5. 实现了 Collection 和 Iterator 接口的所有可选 方法.

