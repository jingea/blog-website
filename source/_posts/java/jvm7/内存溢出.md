category: java
tag: jvm7
title: 各种内存异常
---
## 各种内存异常
### java堆溢出

###### 溢出代码

```java
  public class HeapOOM {

	static class OOMObject {
	}

	/**
	 * -verbose:gc -Xms20M -Xmx20M -Xmn10M
	 * -XX:PrintGCDetails
	 * -XX:SurvivorRatio=8
	 * @param args
	 */
	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<>();
		while(true) {
			list.add(new OOMObject());
		}
	}

}
```
###### 执行代码
```
	javac HeapOOM.java
	java -verbose:gc -Xms20M -Xmx20M -Xmn10M   -XX:+PrintGCDetails  -XX:SurvivorRatio=8  HeapOOM
	pause
```
###### 解决方案
```
	解决java堆内存溢出,一般的手段是通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出的堆转储快照进行分析.
	重点是确认内存中的对象是否是必要的,也就是先分清楚是内存泄漏还是内存溢出.
	A: 如果是内存泄漏可通过工具查看泄漏对象到GC Roots的引用链.于是就能找到泄漏对象是通过怎样的路径与GC Toots相关联,
	   并导致垃圾收集器无法自动回收它们的. 掌握了泄漏对象的类型信息,以及GC Roots引用链信息,就可以比较准确地定位
	   出泄漏代码的位置.
	B: 如果不存在泄漏, 换句话说就是内存中的对象确实还都必须存货着, 那就应当检查虚拟机的堆参数,与物理机内存对比
	   查看是否还可以调大,从代码上检查是否存在某些生命周期过长,持有状态时间过长的情况,尝试减少程序运行周期的内存消耗.
```
### 虚拟机栈和本地方法栈溢出

###### 溢出代码

```java
	/**
	  * -Xoss 设置本地放发栈 但是此参数无效
	  * -Xss 虚拟机栈 设置此参数
	  * @param args
	  */

	public class JavaVMStackSOF {

		private int stackLength = 1;

		public void stackLeak() {
			stackLength ++;
			stackLeak();
		}


		public static void main(String[] args) {
			JavaVMStackSOF oom = new JavaVMStackSOF();
			try {
				oom.stackLeak();
			} catch(Throwable e) {
				System.out.println("stack length:" + oom.stackLength);
				throw e;
			}
		}
	}

	public class JavaVMStackOOM {
		private void dontStop() {
			while(true) {

			}
		}

		public void stackLeakByThread() {
			while(true) {
				Thread t = new Thread(new Runnable(){
					@Override
					public void run() {
						dontStop();
					}
				});
			}
		}

		public static void main(String[] args) {
			JavaVMStackOM om = new JavaVMStackOM();
			om.stackLeakByThread();
		}
	}
```
###### 溢出剖析
```
	以上俩个实现都都无法让虚拟机产生OutOfMemoryError异常,只能产生StackOverflowError.
	实验结果表明: 单个线程下,无论由于栈帧太大还是虚拟机容量太小,当内存无法分配时,虚拟机抛出的都是StackOverflowError.
	如果测试时不是限于单线程,通过不断建立新线程的方式倒是可以产生内存溢出异常. 但是这样产生的内存溢出异常与栈空间是否
	足够大并不存在任何联系,或者准确说,在这种情况下,给每个线程的栈分配的内存越大,反而越容易产生内存溢出异常.

	当开发多线程应用时应该特别注意的是,出现StackOverflowError异常时有错误堆栈可以阅读,相对来说比较容易找到问题.
	如果使用虚拟机默认参数,栈深度在大多数情况下达到1000-2000完全没有问题,对于正常的方法调用(包括递归),这个深度
	应该够用了,但是如果建立过多的线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆
	和减少栈容量来换取更多的线程.
```
### 运行时常量池溢出

###### 溢出代码

```java
	/**
	 * 运行时常量溢出
	 * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M
	 * @author mingwang
	 *
	 */
	public class RuntimeConstantPoolOOM {

		public static void main(String[] args) {
			List<String> list = new ArrayList<>();
			int i = 0;
			while(true) {
				list.add(String.valueOf(i++).intern());
			}
		}
	}
```
###### 溢出剖析
```
	如果想运行时常量池添加内容最简单的方式就是String.intern()这个native方法.
	该方法的作用是:如果池中已经包含一个等于此String对象的字符串,则返回池中这个字符串的String对象.否则将次String
	对象包含的字符串添加到常量池中,并返回次String对象音乐.
```
### 方法区溢出

###### 溢出代码

```java
	/**
	 * 借助CGLib使得方法区内存溢出异常
	 * -XX:PermSize10M -XX:MaxPermSize10M
	 * @author mingwang
	 *
	 */
	public class JavaMethodAreaOOM {

		public static void main(String[] args) {
			while(true) {
				Enhancer enhancer = new Enhancer();
				enhancer.setSuperclass(OOMObject.class);
				enhancer.setUseCache(false);
				enhancer.setCallBack(new MethodInterceptor(){
					public Object intercept(Object obj, Method method, Object[] objs,
					MethodProxy proxy) throws Throwable {
						return proxy.invokeSuper(obj, args);
					}
				});
			}
		}

		static class OOMObject {

		}
	}
```
###### 执行代码
```
	javac JavaMethodAreaOOMRun.java
	java -XX:PermSize10M -XX:MaxPermSize10M JavaMethodAreaOOMRun
pause
```
###### 原因剖析
```
	方法区用于存放Class信息,为了测试这个区域,基本思路是产生大量的类去填充方法区,直到溢出.
	本例中使用的是CGLib, 还可以使用ASM等框架进行测试.
	方法区溢出也是一种常见的内存溢出异常.一个类如果被垃圾收集器回收,其条件是非常苛刻的. 在经常动态生成大量Class的应用
	中,需要特别注意类的回收状况. (基于OSGI的应用即使是同一个类文件被不同的加载器加载也会视为不同的类)
```

### 本地内存直接溢出

###### 溢出代码

```java
	/**
	 * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
	 */
	public class DirectMemoryOOM {
	    private static final int _1MB = 1024 * 1024;

	    public static void main(String[] args) throws Exception {
	        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
	        unsafeField.setAccessible(true);
	        Unsafe unsafe = (Unsafe)unsafeField.get(null);
	        while(true)
	            unsafe.allocateMemory(_1MB);
	    }
}
```
###### 剖析原因
```
	直接通过反射获取Unsafe实例并进行内存分配,Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例,也就是
	设计者希望只有rt.jar中的类才能使用unsafe的功能. 因为虽然使用DirectbyeBuffer分配内存也会抛出内存异常,但抛出异常时
	并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配,于是手动抛出异常,真正申请分配内存的方法是:
	unsafe.allocateMemory(_1MB);
```
