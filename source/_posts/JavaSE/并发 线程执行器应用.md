category: JavaSE
date: 2015-03-18
title: 线程执行器应用
---

* 创建固定大小的线程执行器
* 创建线程执行器
* 在执行器中分离任务的启动与结果的处理
* 在执行器中取消任务
* 在执行器中周期执行任务
* 在执行器中延迟执行任务
* 运行并发任务并返回结果
* 在执行器中控制任务的完成
* 处理在执行器中被拒绝的任务
* 运行多个任务并处理所有结果
* 运行多个任务并处理第一个结果

## 在执行器中延迟执行任务
```java
// 创建执行器线程数量最大为1的执行器
ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

System.out.println("start:" + new Date());

for (int i = 0; i < 5; i++) {
	// 每个线程延迟i + 1秒执行
	executor.schedule(() -> {
		System.out.println(new Date());
		return "finish";
	}, i + 1, TimeUnit.SECONDS);
}

// 在默认的情况下,调用shutdown()之后不论执行器是否结束,待处理的任务仍将被执行
executor.shutdown();

// 等待所有任务结束
try {
	executor.awaitTermination(1, TimeUnit.DAYS);
} catch (InterruptedException e) {
	e.printStackTrace();
}

System.out.println("end:" + new Date());
```

## 运行并发任务并返回结果
Callable 接口声明了call()方法,可以在这个方法里实现任务的具体逻辑

1.控制任务状态,可以取消任务和检查任务是否完成.(通过isDone()检查任务是否完成)
2.使用get()方法获取call()方法返回的结果,这个方法一直等到call()方法执行完成并返回结果.   如果在等待过程中线程中断了,则抛出一个InterruptedException 如果call()方法抛出异常,get()则抛出ExecutionException
