category: JavaSE
date: 2015-03-12
title: 线程同步辅助类
---

# 在集合点的同步
CyclicBarrier使用一个整数进行初始化,这个数是需要在某个点上同步线程数.当线程完成工作,它可以调用await()方法等待其他线程.当最后一个线程完成工作调用await()方法时,CyclicBarrier将唤醒所有等待的线程,然后这些线程将继续执行

还有一点值得说明的是：可以在CyclicBarrier的构造参数里传入Runnable对象.当所有线程都达到集合点后,CyclicBarrier将这个Runnable对象作为线程执行.

CyclicBarrier还有一种await()方式,就是指定结束时间点.
如果CyclicBarrier的内部计数器不为0,但是时间到后,就可以唤醒现在被中断的线程

可以通过reset()方法重置CyclicBarrier

如果已经在阻塞的线程,被其他的线程中断了,CyclicBarrier将会抛出BrokenBarrierException状态
可以通过isBroken()来检查CyclicBarrier是否处于Broken状态

## 并发任务间的数据交换

## 并发阶段任务中的阶段切换

## 并发阶段任务的运行
Phaser提供了onAdvance()方法,它在phaser阶段改变的时候会自动运行.
Phaser允许执行并发任务多阶段任务.在每一步结束的位置进行同步,当所有线程都完成了这一步,才允许执行下一步

new Phaser(3),初始化3个线程参与的Phaser对象.个数字通知Phaser对象在唤醒所以休眠线程以进行下一个阶段之前,须执行arriveAndAwaitAdvance()的次数

Phaser有俩种状态：
1.活跃态. 当存在参与同步的线程的时候,Phaser对象就是活跃的,并且在每个阶段结束的时候进行同步
2.终止态. 当所有参与同步的线程都取消注册的时候,Phaser就处于终止状态,在这种状态下,Phaser没有任何参与者当Phaser对象的onAdvance()方法返回true,Phaser就处于终止态.覆盖通过onAdvance()方法可以改变默认的行为,当Phaser处于终止态,同步方法arriveAndAwaitAdvance()会立即返回,而且不会做任何同步的操作

arriveAndAwaitAdvance() Phaser对象计数器减一,并且把这个线程置为休眠状态,直到其他线程完成了这个阶段arriveAndDeregister()  通知Phaser对象,当前线程已经完成了当前任务,并且不会在下一个阶段中参与,因而Phaser对象在开始下一个阶段不会等待这个线程

arrive()
awaitAdvance(phase)
awaitAdvanceInterruptibly(phase)
register()
bulkRegister(parties)

## 等待多个并发事件的完成
CountDownLatch是一个同步辅助类. 在完成一组正在其他线程执行的操作之前,它允许线程一直等待.

该类使用一个整数初始化,这个整数就是线程要等待完成的操作数目.

当一个线程要等待某些操作先执行时,需要调用await()方法,这个方法让线程进行睡眠,直到所有的操作都完成

当某一个操作完成后,他它将调用countDown(),将CountDownLatch里的计数器减一.

当计数器为0时,CountDownLatch将唤醒所有调用await()方法而进入休眠的线程

CountDownLatch对象内部的计数器被初始化之后就不能再次初始化或者修改. 而且当计数器为0后也不能在调用countDown()方法

对比同步方法 1.CountDownLatch不是用来保护共享资源或者临界区的.它是用来同步执行多个任务的一个或者多个线程
2.CountDownLatch只准许进入一次
,一旦CountDownLatch的内部计数器为0,就不可再调用countDown(),如果想要做类似的同步,必须再重新创建一个对象

## 资源的多副本的并发访问控制

## 资源的并发访问控制


本例中使用Semaphore来实现二进制信号量(一种特殊信号量,用来保护唯一共享资源的访问).
本例使用了Java提供的信号量机制.信号量是一种计数器,用来保护一个或者多个共享资源的访问.

如果线程要访问一个共享资源,它必须首先获得它的信号量(内含计数器C).C > 0 --> C--,然后允许线程访问该共享变量(C>0 有可用资源,线程被允许使用其中一个资源)C== 0 --> 信号量将线程置为睡眠,直至C<0(C=0, 所以的共享资源都被其他线程使用了,以想要访问该共享资源的线程必须等待).

当线程使用完某个共享资源,信号量必须被释放(C++),以便其他的线程能够访问共享资源.

获取信号量
1.acquire()
2.acqu
