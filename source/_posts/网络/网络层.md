category: 网络
date: 2015-11-08
title: 网络层
---

网络层通过地址将数据从众多链路中传送到最终地址上.它实现的是终端节点之间的通信. 相比于数据链路层的只能在同一种数据链路中进行数据传输,网络层可以跨数据链路进行数据传输(这一点是通过下面介绍的路由器实现的).说的更加通俗一点是:数据链路层只是负责俩个设备之间的通信,但是如果想要跨多个设备通信的话,就只能借助网络层了.

> 至于为什么需要网络层呢?是这样的,数据链路只能在同一种介质中进行通信,如果无线想要和以太网进行数据传输的话,单靠数据链路层是没办法完成这个需求的,此时就需要借助网络层的路由器了.

网络层相关协议:
* ARP
* IP
* ICMP

### IP
IP的作用分作三部分:
* IP寻址
* 路由
* IP分包,组包
我们知道MAC地址是用来在同一链路中识别不同计算机的,那么IP地址就是在连接到网络中的所有主机相互识别用的. 因此在连接到网络的所有的主机和路由器必须都设置上自己的IP地址.我们必须时刻记住IP地址只在网络层有效,网络层只是将主机的IP地址放到了数据包的IP首部位置,IP包在网桥或者中继器或者数据链路层是不会被使用到的,在硬件部分只是将IP包转化成一个个的0,1的数据流,在链路层只是对数据连绝真的数据部分进行转发.

由于不同的数据链路的MTU值(Maximum Transmission Unit,最大传输单位)是不一样的,比如以太网的MTU为1500bytes,而FDDI则是4352Bytes,ATM则为9180bytes.IP包的长度有可能大于或者小于这些长度,于是就出现了IP包的分片处理. 网络层会将IP包分成一个个相等的较小的包,由链路层发送出去,到了终端网络层再组装起来.

当IP包生成之后,会根据接收端IP从路由表里边查找接受该数据包的路由或者主机. 然后IP包会被发送给连接路由器或者NIC的驱动程序,实现真正的数据传输.

网络层接受到传输层发送过来的数据(如:TCP首部+应用层数据),如果由UP模块处理,IP模块就会在数据首部再添加IP首部:
* 接收端IP
* 发送端IP
* 判断传输层数据是TCP还是UDP数据的信息
 
#### IP地址
IPV4地址由32位正整数(0/1)表示,每8位一组,分成4组,每一组用`.`分隔.每一组的最大值是2的8次方也就是255,最小值是0. 

理论上2的32次方,大概是43亿,那么每个NIC都配置一个IP的话(NIC最少可以配置一个IP)那么就会有43亿的计算机可以连接到网络上(但实际上,能连接到网络上的计算机远远达不到这个数量).

实际上IP地址是由网络和主机俩部分标志组成的.

### 路由器
路由器在网络层上连接网络,并对分组报文进行转发. 路由器使用IP地址进行进行处理. 路由器可以连接不同的数据链路,例如连接以太网和一个FDDI.

### ARP
当我们在写网络程序的时候,无论是HTTP协议还是TCP协议,我们只需要知道对方的IP地址就可以向其发送消息,但是在数据链路层在实际通信时,必须知道对方的MAC地址.

我们就是通过ARP协议来通过IP地址找到对方的MAC地址的. 当主机A要向主机B发送一个消息时,主机A会尝试从自己的ARP表中查找目标IP的MAC地址. 如果找到了目标MAC地址,就直接向该MAC地址发送消息. 如果找不到MAC地址,主机A就向链路中发送ARP请求,链路中的所有主机和路由器都会对其进行解析. 当主机B与主机A在同一链路中,此时主机B会发送主机A发出的ARP请求与自己的IP地址一致,主机B就会回应一个ARP响应,响应中包含着主机B的MAC地址. 主机A接收到主机B的ARP响应后,会将主机B的MAC地址和IP地址的对应关系,缓存到自己的ARP表中.
> ARP是为了提高性能而设计的. 如果每次IP通信都需要进行一次ARP请求,会造成非常大的网络流量

上面我们只是阐述了,在同一链路中找到了目标主机,但是如果找不到呢?

> 其实还有一种RARP协议,这个协议是将MAC地址定位IP地址的协议,与ARP协议恰恰相反. 平常我们在电脑里设置IP地址时,可以通过设置为自动获取IP地址(通过DHCP实现),但是使用嵌入式设备,我们可能就没有办法通过DHCP来获取IP地址了,那么,我们就需要架设一台RARP服务器,从而在这个设备上注册设备的MAC地址及其IP地址.

## NAT
网络地址转换(NAT,Network Address Translation)是用于在本地网络中使用私有地址,在连接互联网时转而使用全局IP地址的技术.NAT技术的踢出是为了解决IPV4地址日益枯竭的问题,即可以使用网关来完成NAT也可以使用NAT路由器来完成.

首先我们来说说NAT路由器,NAT路由器内部有一张自动生成的用来转换地址的表. 例如在TCP情况下,建立TCP连接首次握手时的SYN包一旦发出,就会在路由器内部生成这个表. 随后收到关闭连接发出FIN包的确认应答时又从表中将其删除.

> 说到这里,我们要谈一下,IPV4和IPV6之间通信的问题. IPV6的主机是没办法直接与IPV4的主机进行通信的,我們首先要使用NAT-PT技術將IPV6首部替換為IPV4首部,這樣他們二者才能進行通信. NAT-PT技術有很多實現方式,例如結合DNS和IP首部替換的DNS-ALG技術.

NAT有俩种实现方式：
* NAT: 将内网的IP地址替换为网关的IP地址，但是将内网的端口与网关端口进行绑定,也就是公网见到的端口是内网的端口,但是见到的IP是网关的地址.
* NAPT：	使用网关的IP，但端口会选择一个和临时会话对应的临时端口. 这种公网见到的IP地址和端口都是网关设定的.

由于内网可能会跟公网建立俩个连接都采用不同的端口,因此NAPT针对这种情况又分为了俩种类型(需要说明的是不管是那种类型只要建立一个连接就会在网关中建立一个session)
* Symmetric NAT型 (对称型): 来自同一个内网的ip俩个seesion会在网关上分配到俩个不同的端口.
* Cone NAT型（圆锥型）:来自同一个内网的ip俩个seesion会在网关上分配同一个端口

Cone NAT又分了3种类型：
* Full Cone NAT（完全圆锥型）：这种NAT，网关会根据session信息将公网发送过来的数据报都都发送到某个内网主机上.
* Address Restricted Cone NAT （地址限制圆锥型）：这种NAT上的内网不会主动接受陌生公网主机的数据报,只有内网向公网主机发送过请求,才会接受那个公网的数据报.
* Port Restricted Cone NAT（端口限制圆锥型）：和第二种NAT类似同样是不会主动接受陌生公网主机的数据报,但是这种NAT更加严苛的是还有端口限制,也就是说它只会接受向某个公网端口发送给请求的数据报.

Linux的NAT是对称NAT，而不是锥形NAT. 且完全依赖ip_conntrack.

NAT還有很多潛在的問題:
1. 無法從NAT的外部向NAT內部直接建立連接.
2. 轉換表的生成和轉換操作都有一定的开销.
3. 通信过程中一旦NAT遇到异常需要重新启动时,所有的TCP连接都将被重置
4. 即使准备俩台NAT做容灾备份,TCP连接还是会被断开.

## 路由
我们知道网络其实就是由一个个路由组成的. IP包就是在这一个个的路由间传输,每当路过一个路由的时候我们就说IP数据包经过了一跳. 每当IP包完成一跳时,当前路由器就会指定下一个路由器或者主机.
> 一跳(Hop)的范围就是从一个主机或者一个路由器的网卡到另一个主机或者路由器网卡之间的区间.

每个主机中都有一个路由控制表,这个表记录着IP数据包在下一步发给哪个路由器.IP包根据这个路由器在各个链路上进行传输.
