category: JavaSE 并发
date: 2016-03-28
title: 线程执行器原理
---

## Executor
我们首先从`Executor`接口看起.

`Executor`定义了执行`Runnable`类型任务的接口. 这个接口实现了对任务的提交和执行(包含任务的线程执行细节以及线程调度等等)的解耦.

`Executor`接口一般不会显式地创建线程(例如`new Thread(new(RunnableTask())).start()`), 而是会采取如下方式
```java
Executor executor = <em>anExecutor</em>;
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
```
在`Executor`接口中并没有强制要求, 任务的执行必须是异步的, 因此在`Executor`接口的最简单实现中, 我们可以直接在调用线程中执行任务, 例如
```java
class DirectExecutor implements Executor {
 public void execute(Runnable r) {
   r.run();
 }
}}
```
但是在一般情况下, 任务会在非调用线程中执行, 例如
```java
class SerialExecutor implements Executor {
 final Queue<Runnable> tasks = new ArrayDeque<Runnable>();
 final Executor executor;
 Runnable active;

 SerialExecutor(Executor executor) {
   this.executor = executor;
 }

 public synchronized void execute(final Runnable r) {
   tasks.offer(new Runnable() {
     public void run() {
       try {
         r.run();
       } finally {
         scheduleNext();
       }
     }
   });
   if (active == null) {
     scheduleNext();
   }
 }

 protected synchronized void scheduleNext() {
   if ((active = tasks.poll()) != null) {
     executor.execute(active);
   }
 }
}
```

> 内存一致性影响:

## ExecutorService
