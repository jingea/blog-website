category: 杂记
date: 2016-03-04
title: Java游戏服务器设计
---
从毕业就开始在游戏行业摸爬滚打,至今4年将至,今天特意总结一下这四年来的心得.

现在的游戏服务器大多采用Netty作为网络传输层,然后采用Reactor模型将消息转发到业务线程池中进行执行,然后在业务线程池中进行CPU计算,数据库IO操作,最后将结果返回给前端.

这样的游戏服务器在压测的时候在线玩家不会超过2000人,而且经常会出现比较大的延迟,因为有的IO操作真的很耗时. 

在上个项目中我见到了这样一种设计,仍然是采用Netty完成网络层Socket数据读取发送工作,然后将解码出的数据扔到俩个消息队列里面去(采用Vertx的EventBus实现). 一个消息队列负责登录请求,一个消息队列负责整个游戏的业务逻辑. 这么着一来整个游戏的业务就不会出现数据竞争的情况. 然后再定时的将数据写到redis里面去. 这种设计在压测的时候达到了10000人的同时在线规模. (当然还有很多优化的地方, 例如在消息查找的时候采取ASM而不是低效的JDK反射, 但是并没有对JVM和Netty进行过特殊优化, 只是对JVM的新生代的分区将8:1:1改成了6:2:2)

前俩天和一些游戏团队的人聊了聊,他们一致认为这种设计方式没有能充分的利用上主机多核的优势, 但是在Reactor的模型中, 主线程池和工作线程池都是需要CPU来运算的, 如果所有的CPU运算都来支持业务逻辑, 那么玩家一样会感觉到卡顿. 而且我们还可以对刚才的设计进行优化, 将不同模块业务放到不同的线程进行. 例如在Thread1中进行玩家自己的业务逻辑运算, 在Thread2中进行公会模块的业务计算, 当公会对玩家本身数据产生影响的时候, 我们可以让公会线程给玩家的业务线程发送消息(同样的使用消息队列). 这么着也能最大可能的利用多核优势同时让开发人员少的思考数据竞争出现的问题, 现在大多数的开发人员在处理数据竞争的时候还是较多的使用synchronized这种加锁方式(有些底层的接口也有可能使用读写锁, 但是使用锁, 在大规模用户的情况下,真的比较耗时).

还有一点需要说的是, 在上个项目中,只使用到了很少的数据库表, 基本上玩家数据都存储到了一张表里, 当定时存储的时候,将玩家数据整个序列化成一个JSON串, 然后入库. 这么做有显而易见的好处,在分服的游戏中, 合服很容易而且在线上出现问题的时候,也很容易拿到一个玩家的数据进行问题排查. 而且在线上的时候也会出现因为异常而导致玩家刷材料等等, 因此如果在处理消息之前, 拿一个玩家备份的数据让玩家去操作,一旦出现数据异常也不会对玩家自己的数据造成影响. (需要考虑的是大量的序列号和反序列化会造成大量的GC操作.)