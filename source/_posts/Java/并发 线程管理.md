category: Java
date: 2015-03-09
title: 线程管理
---
## 线程的创建和运行
创建一个线程
```java
public class Main {

	public static void main(String[] args) {

		for (int i = 1; i <= 10; i++) {
			Calculator calculator = new Calculator(i);
			Thread thread = new Thread(calculator);
			thread.start();
		}
	}
}

class Calculator implements Runnable {

	private int number;

	public Calculator(int number) {
		this.number = number;
	}

	@Override
	public void run() {

		for (int i = 1; i <= 10; i++) {
			System.out.printf("%s: %d * %d = %d\n", Thread.currentThread()
					.getName(), number, i, i * number);
		}
	}

}
```

## 使用工厂类创建线程
```java
public class Main {

	public static void main(String[] args) {

		ThreadFactory factory = new ThreadFactory() {
			@Override
			public Thread newThread(Runnable r) {
				Thread t = new Thread(r);
				return t;
			}
		};

		Runnable task = new Runnable() {

			@Override
			public void run() {
				System.out.println("1");
			}
		};
		for (int i = 0; i < 10; i++) {
			Thread thread = factory.newThread(task);
			thread.start();
		}
	}
}
```

## 守护线程的创建和运行
守护线程的优先级很低,通常来说,同一个应用程序中没有其他的线程运行,守护线程才运行. 当守护线程运行结束后,JVM也就结束了这个应用程序

守护线程通常用来作为同一程序中普通线程的服务提供者,因为没有办法确定守护线程什么时候才能获取CPU时钟, 而且在没有其他线程运行的时候,守护线程随时可能会结束

>  一个典型的守护线程就是java的垃圾回收器

`setDeamon()`方法只能在`start()`方法之前被调用,一旦线程开始运行,将不能再修改其状态

> 注: 需要注意的是,只有在没有用户线程运行的时候,而不是没有用户线程存在的时候守护线程才运行. 例如当所有用户线程多沉睡后,也会被视为没有用户线程执行

1. hread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
2. 在Daemon线程中产生的新线程也是Daemon的
3. 不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。
4. 当用户线程都运行完后,守护线程也就跟着结束了

```java
public class Main {
	public static void main(String[] args) {
		DeameanThread dt = new DeameanThread();
		NormalThread nt = new NormalThread();
		nt.start();
		dt.start();
		System.out.println("main");
	}
}

class NormalThread extends Thread {
	NormalThread() {
		setDaemon(false);
	}
	@Override
	public void run() {
		long old = System.currentTimeMillis();
		while((System.currentTimeMillis() - old) < 3000) {}
		System.out.println("NormalThread");
	}
}

class DeameanThread extends Thread {
	DeameanThread() {
		setDaemon(true);
	}
	@Override
	public void run() {
		while(true){}
	}
}

```

## 线程中断的控制

```java
public class Main {

	public static void main(String[] args) {

		Thread thread = new Thread(new Check());
		thread.start();

		try {
			TimeUnit.SECONDS.sleep(10);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		thread.interrupt();
	}
}

class Check implements Runnable {

	@Override
	public void run() {
		try {
			checkProcess();
		} catch (InterruptedException e) {
			System.out.printf("%s: Check has been interrupted", Thread
					.currentThread().getName());
		}
	}

	private void checkProcess() throws InterruptedException {

		while(true) {
			String str = System.currentTimeMillis() / 1000 + "";
			int last = str.indexOf(str.length() - 1);
			if (last % 2 == 0) {
				checkProcess();
				return;
			}

			System.out.println(System.currentTimeMillis());
			if (Thread.interrupted()) {
				throw new InterruptedException();
			}
		}

	}

}
```

## 线程局部变量
Threead类的join()方法被调用时,调用它的线程将被挂起,直到这个线程对象完成它的任务join(long millseconds)如果使用这种方法,被挂起的线程只要满足指定的毫秒数到,或者join线程运行完,被挂起线程恢复运行

```java
public class Main {

	public static void main(String[] args) {

		Thread dataThread = new Thread(new DataSourcesLoader(), "Data");
		Thread netThread = new Thread(new NetworkConnectionsLoader(), "Network");

		try {
			dataThread.start();
			dataThread.join();
			System.out.println("Network join");
			netThread.start();
			netThread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out.println("Main");
	}
}

class DataSourcesLoader implements Runnable {

	@Override
	public void run() {

		System.out.println("Data run");
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Data over");
	}
}

class NetworkConnectionsLoader implements Runnable {

	@Override
	public void run() {

		System.out.println("Network run");
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Network over");
	}
}

```


## 线程中断
Java 提供了中断机制,可以使用中断来结束一个线程.

```java
/**
 * 使用PrimeGenerator线程生成素数,当主线程sleep 3秒之后,打断PrimeGenerator线程
 *
 */
public class Main {

	public static void main(String[] args) {

		// 开始执行素数生成器线程
		Thread task = new PrimeGenerator();
		task.start();

		// 主线程沉睡5秒
		try {
			TimeUnit.SECONDS.sleep(5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		// 打断素数生成器线程
		task.interrupt();
		System.out.println("PrimeGenerator state : " + task.getState());
	}

}

class PrimeGenerator extends Thread {

	@Override
	public void run() {
		long number = 1L;

		while (true) {
			if (isPrime(number)) {
				System.out.printf("Number %d is Prime\n", number);
			}

			/*
			 * 使用中断来结束一个线程,要求线程检查它是否被中断了,然后决定是否响应这个中断请求.
			 * 线程允许忽略中断并继续执行(将if语句注掉就可忽略中断请求)
			 */
			if (isInterrupted()) {
				System.out.printf("素数生成器被Interrupte. state: " + getState());
				return;
			}
			number++;
		}
	}

	/**
	 * 检查数字是否是素数
	 */
	private boolean isPrime(long number) {
		if (number <= 2) {
			return true;
		}
		for (long i = 2; i < number; i++) {
			if ((number % i) == 0) {
				return false;
			}
		}
		return true;
	}

}
```

## 线程休眠和恢复
使用sleep()方法中断线程的运行. sleep()中断线程后,直到CPU时钟来临JVM选中它继续执行的这段期间, 该线程不会占用任何资源

sleep()方法接受整型数值作为参数,以表明线程挂起执行的毫秒数. sleep()还可使用TimeUnit枚举元素来进行调用

yield()方法通知JVM该线程对象可以释放CPU了

```java

public class Main {

	public static void main(String[] args) {
		Thread thread = new Thread(new FileClock());
		thread.start();

		try {
			TimeUnit.SECONDS.sleep(5);
		} catch (InterruptedException e) {
			e.printStackTrace();
		};

		// 发送中断线程
		System.out.println("send interrupt");
		thread.interrupt();
	}
}

class FileClock implements Runnable {

	@Override
	public void run() {

		for (int i = 0; i < 10; i++) {

			System.out.printf("%s\n", new Date());
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				System.out.println("The FileClock has been interrupted : " + i);
			}
		}
	}
}
```

## 线程的分组
Java提供了ThreadGroup类表示一组线程, 线程组可以包含线程对象,可以包含线程组对象,也可以其他线程组对象 它是一个树形结构
