category: Java
date: 2015-03-10
title: Java 1.5 中的Lock
---
Java提供了同步代码块的另一种机制,它比synchronized关键字更加强大也更加灵活. 这种机制基于Lock接口以及其实现类.

Lock相比Synchronized：
1. 更灵活的同步代码块结构.使用synchronized关键字只能在同一个synchronized块结构中获取和释放控制. Lock接口允许实现更复杂的临界区结构.(例如可以在不同的方法中加锁和释放锁)
2. Lock接口提供了tryLock()方法.这个方法试图获取锁,如果锁已被其他线程获取,它将返回false并继续往下执行代码. 但在使用synchronized关键字时,如果A想要执行一个同步块,但是B恰好在使用她,A就会一直被堵塞到B执行完该同步块
3. Lock接口允许分离读操作和写操作,允许多个读线程和一个写线程
4. 而且Lock接口拥有更好的性能

# ReentrantLock
* `lock()`: A尝试获取锁的时候,如果B在执行同步块,A将被锁住,直到B执行完 

```java
public class TestReentrantLock {

	public static void main(String args[]) throws InterruptedException {
		final ReentrantLock queueLock = new ReentrantLock();
		Runnable runnable = () -> {
			// 使用锁实现一个临界区,并且保证同一时间只有一个执行线程访问这个临界区.
			queueLock.lock();
			try {
				int random = ThreadLocalRandom.current().nextInt(2);
				lockInfo(queueLock, random);
				TimeUnit.SECONDS.sleep(random);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} finally { // 在执行完的最后必须释放锁
				queueLock.unlock();
			}
		};
		for (int i = 0; i < 20; i++) {
			Thread thread = new Thread(runnable);
			thread.start();
		}
		Thread.currentThread().join();
	}
	private static void lockInfo(ReentrantLock queueLock, int sleep) {
		Map<String, Object> map = new HashMap<>();
		map.put("hasQueuedThreads", queueLock.hasQueuedThreads());
		map.put("isFair", queueLock.isFair());
		map.put("isHeldByCurrentThread", queueLock.isHeldByCurrentThread());
		map.put("isLocked", queueLock.isLocked());
		map.put("HoldCount", queueLock.getHoldCount());
		map.put("QueueLength", queueLock.getQueueLength());
		System.out.println(LocalDateTime.now() + " -> " + sleep + " -> " + map);
	}
}
```
结果为
```bash
2016-09-08T13:50:50.440 -> 0 -> {isLocked=true, QueueLength=1, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:50.442 -> 0 -> {isLocked=true, QueueLength=18, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:50.442 -> 0 -> {isLocked=true, QueueLength=17, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:50.442 -> 1 -> {isLocked=true, QueueLength=16, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:51.442 -> 1 -> {isLocked=true, QueueLength=15, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:52.443 -> 1 -> {isLocked=true, QueueLength=14, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:53.443 -> 1 -> {isLocked=true, QueueLength=13, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:54.443 -> 1 -> {isLocked=true, QueueLength=12, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:55.443 -> 1 -> {isLocked=true, QueueLength=11, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:56.444 -> 1 -> {isLocked=true, QueueLength=10, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:57.444 -> 0 -> {isLocked=true, QueueLength=9, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:57.444 -> 1 -> {isLocked=true, QueueLength=8, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:58.445 -> 0 -> {isLocked=true, QueueLength=7, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:58.446 -> 1 -> {isLocked=true, QueueLength=6, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:50:59.446 -> 1 -> {isLocked=true, QueueLength=5, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:51:00.446 -> 0 -> {isLocked=true, QueueLength=4, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:51:00.446 -> 1 -> {isLocked=true, QueueLength=3, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:51:01.446 -> 0 -> {isLocked=true, QueueLength=2, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:51:01.447 -> 1 -> {isLocked=true, QueueLength=1, isHeldByCurrentThread=true, hasQueuedThreads=true, HoldCount=1, isFair=false}
2016-09-08T13:51:02.448 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=true, hasQueuedThreads=false, HoldCount=1, isFair=false}
```

* `tryLock()`: 这个方法试图获取锁,如果锁已被其他线程获取,它将返回false并继续往下执行代码
```java
public class TestReentrantLock {

	public static void main(String args[]) throws InterruptedException {
		final ReentrantLock queueLock = new ReentrantLock();
		Runnable runnable = () -> {
			// 使用锁实现一个临界区,并且保证同一时间只有一个执行线程访问这个临界区.
			boolean isLocked = queueLock.tryLock();
			try {
				int random = ThreadLocalRandom.current().nextInt(2);
				lockInfo(queueLock, random);
				TimeUnit.SECONDS.sleep(random);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} finally { // 在执行完的最后必须释放锁
				if (isLocked) {
					queueLock.unlock();
				}
			}
		};
		for (int i = 0; i < 20; i++) {
			Thread thread = new Thread(runnable);
			thread.start();
		}
		Thread.currentThread().join();
	}
	private static void lockInfo(ReentrantLock queueLock, int sleep) {
		Map<String, Object> map = new HashMap<>();
		map.put("hasQueuedThreads", queueLock.hasQueuedThreads());
		map.put("isFair", queueLock.isFair());
		map.put("isHeldByCurrentThread", queueLock.isHeldByCurrentThread());
		map.put("isLocked", queueLock.isLocked());
		map.put("HoldCount", queueLock.getHoldCount());
		map.put("QueueLength", queueLock.getQueueLength());
		System.out.println(LocalDateTime.now() + " -> " + sleep + " -> " + map);
	}
}
```
结果为
```
2016-09-08T13:55:39.038 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.039 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.039 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.037 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.039 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=true, hasQueuedThreads=false, HoldCount=1, isFair=false}
2016-09-08T13:55:39.039 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.039 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.037 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.038 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.040 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.040 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.040 -> 1 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
2016-09-08T13:55:39.040 -> 0 -> {isLocked=true, QueueLength=0, isHeldByCurrentThread=false, hasQueuedThreads=false, HoldCount=0, isFair=false}
```
当使用`tryLock()`的时候, 我们必须使用它的返回值来最后判定是否进行unlock操作. 

通过最后的时间我们也可以看到当`tryLock()`失败之后就直接进行了后续代码的执行.

## Condition
`Condition`将`Object`的监视器方法`wait, notify, notifyAll` 抽象出来. 每个`Condition`对象都有一个监视器. 

`Condition`重点有如下俩个方法
* `await()` : 执行了`await()`方法之后, 当前线程会自动释放锁同时该线程会进入休眠装备不再被线程调度, 直到有其他线程执行了`signal(), signalAll(), interrupts` 等.
* `signal()` : 唤醒等待的线程. 这个方法会从诸多等待该条件的线程中选择一个进行唤醒. 但是被唤醒的线程从`await()`方法返回之前必须重新获得锁.

我们直接看`Condition`API中给出的示例
```java
class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length)
         notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0)
         notEmpty.await();
       Object x = items[takeptr];
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   }
 }
```

## 锁的公平性

`ReentrantLock`和`ReentrantReadWriteLock` 类的构造器都含有一个布尔参数fair.

ReentrantLock的实现不仅可以替代隐式的synchronized关键字,而且能够提供超过关键字本身的多种功能。这里提到一个锁获取的公平性问题,如果在绝对时间上,先对锁进行获取的请求一定被先满足, 那么这个锁是公平的,反之,是不公平的,也就是说等待时间最长的线程最有机会获取锁,也可以说锁的获取是有序的。

ReentrantLock这个锁提供了一个构造函数,能够控制这个锁是否是公平的。而锁的名字也是说明了这个锁具备了重复进入的可能,也就是说能够让当前线程多次的进行对锁的获取操作,
这样的最大次数限制是Integer.MAX_VALUE,约21亿次左右。

事实上公平的锁机制往往没有非公平的效率高,因为公平的获取锁没有考虑到操作系统对线程的调度因素,这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配

对于锁的快速且重复的获取过程中,连续获取的概率是非常高的,而公平锁会压制这种情况, 虽然公平性得以保障,但是响应比却下降了,但是并不是任何场景都是以TPS作为唯一指标的,因为公平锁能够减少“饥饿”发生的概率,等待越久的请求越是能够得到优先满足。

* fair --> true : 公平模式,当有很多线程在等待锁的时候,锁将选择它们中的一个来访问临界区,选择的是等待时间最长的
* fair --> false: 非公平模式,当有很多线程在等待锁的时候,锁将选择它们中的一个来访问临界区,该选择是没有任何约束的

这俩种模式只适用于lock(),unlock()方法.

`Lock`接口的`tryLock()`方法并没有将线程置为睡眠,所以fair属性并不影响这个方法
```java
public class Main {

	public static void main(String args[]) {
		final PrintQueue printQueue = new PrintQueue();

		for (int i = 0; i < 10; i++) {
			Runnable r = new Runnable() {

				@Override
				public void run() {
					System.out.printf("%s:begin print\n", Thread
							.currentThread().getName());
					printQueue.printJob(new Object());
					System.out.printf("%s:print over\n", Thread.currentThread()
							.getName());
				}
			};
			Thread t = new Thread(r);
			t.start();

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

}

class PrintQueue {

	private final Lock queueLock = new ReentrantLock(false);

	public void printJob(Object document) {
		queueLock.lock();

		try {
			Long duration = (long) (Math.random() * 10000);
			System.out.printf("%s:Printing a Job during %d seconds\n", Thread
					.currentThread().getName(), (duration / 1000));
			Thread.sleep(duration);

		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			queueLock.unlock();
		}
	}
}
```


# ReadWriteLock
读写锁只有一个实现ReentrantReadWriteLock(可重入读写锁)

读写锁有俩个锁
* 读操作锁,使用读操作锁的时候可以允许多个线程同时访问
* 写操作锁,只允许一个线程运行,即其他线程既不能执行读操作也不能执行写操作

